<para>
  <inlinemediaobject>
    <imageobject>
      <imagedata fileref="media/image2.png" width="1in" depth="0.54926in" />
    </imageobject>
  </inlinemediaobject>
</para>
<para>
  Build Your Own Blocks
</para>
<para>
  8.0
</para>
<para>
  <emphasis role="smallcaps">Snap<emphasis>!</emphasis></emphasis>
  Reference Manual
</para>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="section">
  <title></title>
  <para>
  </para>
</section>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="table-of-contents">
  <title><inlinemediaobject>
    <imageobject>
      <imagedata fileref="media/image3.png" width="5.47778in" depth="4.50139in" />
    </imageobject>
  </inlinemediaobject>
  Table of Contents</title>
  <para>
    Brian Harvey
  </para>
  <para>
    Jens Mönig
  </para>
  <para>
    I. Blocks, Scripts, and Sprites
    <link linkend="blocks-scripts-and-sprites">5</link>
  </para>
  <para>
    Hat Blocks and Command Blocks
    <link linkend="hat-blocks-and-command-blocks">6</link>
  </para>
  <para>
    A. Sprites and Parallelism
    <link linkend="sprites-and-parallelism">8</link>
  </para>
  <para>
    Costumes and Sounds <link linkend="costumes-and-sounds">8</link>
  </para>
  <para>
    Inter-Sprite Communication with Broadcast
    <link linkend="inter-sprite-communication-with-broadcast">9</link>
  </para>
  <para>
    B. Nesting Sprites: Anchors and Parts
    <link linkend="nesting-sprites-anchors-and-parts">10</link>
  </para>
  <para>
    C. Reporter Blocks and Expressions
    <link linkend="reporter-blocks-and-expressions">10</link>
  </para>
  <para>
    D. Predicates and Conditional Evaluation
    <link linkend="predicates-and-conditional-evaluation">12</link>
  </para>
  <para>
    E. Variables <link linkend="variables">13</link>
  </para>
  <para>
    Global Variables <link linkend="global-variables">14</link>
  </para>
  <para>
    Script Variables <link linkend="script-variables">15</link>
  </para>
  <para>
    Renaming variables <link linkend="renaming-variables">15</link>
  </para>
  <para>
    Transient variables <link linkend="transient-variables">16</link>
  </para>
  <para>
    F. Debugging <link linkend="debugging">17</link>
  </para>
  <para>
    The pause button <link linkend="the-pause-button">17</link>
  </para>
  <para>
    Breakpoints: the pause all block
    <link linkend="breakpoints-the-pause-all-block">17</link>
  </para>
  <para>
    Visible stepping <link linkend="visible-stepping">18</link>
  </para>
  <para>
    G. Etcetera <link linkend="etcetera">18</link>
  </para>
  <para>
    H. Libraries <link linkend="libraries">25</link>
  </para>
  <para>
    II. Saving and Loading Projects and Media
    <link linkend="saving-and-loading-projects-and-media">37</link>
  </para>
  <para>
    A. Local Storage <link linkend="local-storage">37</link>
  </para>
  <para>
    B. Creating a Cloud Account
    <link linkend="creating-a-cloud-account">37</link>
  </para>
  <para>
    C. Saving to the Cloud <link linkend="saving-to-the-cloud">38</link>
  </para>
  <para>
    D. Loading Saved Projects
    <link linkend="loading-saved-projects">38</link>
  </para>
  <para>
    E. <emphasis role="strong">If you lose your project, do this
    first!</emphasis>
    <link linkend="if-you-lose-your-project-do-this-first">39</link>
  </para>
  <para>
    F. Private and Public Projects
    <link linkend="private-and-public-projects">39</link>
  </para>
  <para>
    III. Building a Block <link linkend="building-a-block">40</link>
  </para>
  <para>
    A. Simple Blocks <link linkend="simple-blocks">40</link>
  </para>
  <para>
    Custom Blocks with Inputs
    <link linkend="custom-blocks-with-inputs">42</link>
  </para>
  <para>
    Editing Block Properties
    <link linkend="editing-block-properties">43</link>
  </para>
  <para>
    B. Recursion <link linkend="recursion">43</link>
  </para>
  <para>
    C. Block Libraries <link linkend="block-libraries">44</link>
  </para>
  <para>
    D. Custom blocks and Visible Stepping
    <link linkend="custom-blocks-and-visible-stepping">45</link>
  </para>
  <para>
    IV. First class lists <link linkend="first-class-lists">46</link>
  </para>
  <para>
    A. The list Block <link linkend="the-list-block">46</link>
  </para>
  <para>
    B. Lists of Lists <link linkend="lists-of-lists">47</link>
  </para>
  <para>
    C. Functional and Imperative List Programming
    <link linkend="functional-and-imperative-list-programming">48</link>
  </para>
  <para>
    D. Higher Order List Operations and Rings
    <link linkend="higher-order-list-operations-and-rings">49</link>
  </para>
  <para>
    E. Table View vs. List View
    <link linkend="table-view-vs.-list-view">51</link>
  </para>
  <para>
    Comma-Separated Values
    <link linkend="comma-separated-values">54</link>
  </para>
  <para>
    Multi-dimensional lists and JSON
    <link linkend="multi-dimensional-lists-and-json">54</link>
  </para>
  <para>
    F. Hyperblocks <link linkend="hyperblocks">55</link>
  </para>
  <para>
    V. Typed Inputs <link linkend="typed-inputs">59</link>
  </para>
  <para>
    A. Scratch’s Type Notation
    <link linkend="scratchs-type-notation">59</link>
  </para>
  <para>
    B. The Snap! Input Type Dialog
    <link linkend="the-snap-input-type-dialog">59</link>
  </para>
  <para>
    Procedure Types <link linkend="procedure-types">60</link>
  </para>
  <para>
    Pulldown inputs
    <link linkend="macintosh-hdusersbhdesktopgear-part.pngpulldown-inputs">61</link>
  </para>
  <para>
    Input variants <link linkend="input-variants">63</link>
  </para>
  <para>
    Prototype Hints <link linkend="prototype-hints">64</link>
  </para>
  <para>
    Title Text and Symbols
    <link linkend="title-text-and-symbols">64</link>
  </para>
  <para>
    VI. Procedures as Data <link linkend="procedures-as-data">65</link>
  </para>
  <para>
    A. Call and Run <link linkend="call-and-run">65</link>
  </para>
  <para>
    Call/Run with inputs <link linkend="callrun-with-inputs">65</link>
  </para>
  <para>
    Variables in Ring Slots
    <link linkend="variables-in-ring-slots">66</link>
  </para>
  <para>
    B. Writing Higher Order Procedures
    <link linkend="writing-higher-order-procedures">66</link>
  </para>
  <para>
    Recursive Calls to Multiple-Input Blocks
    <link linkend="recursive-calls-to-multiple-input-blocks">68</link>
  </para>
  <para>
    C. Formal Parameters <link linkend="formal-parameters">69</link>
  </para>
  <para>
    D. Procedures as Data <link linkend="procedures-as-data-1">70</link>
  </para>
  <para>
    E. Special Forms <link linkend="special-forms">71</link>
  </para>
  <para>
    Special Forms in Scratch
    <link linkend="special-forms-in-scratch">72</link>
  </para>
  <para>
    VII. Object Oriented Programming with Sprites
    <link linkend="object-oriented-programming-with-sprites">73</link>
  </para>
  <para>
    A. First Class Sprites <link linkend="first-class-sprites">73</link>
  </para>
  <para>
    B. Permanent and Temporary Clones
    <link linkend="permanent-and-temporary-clones">74</link>
  </para>
  <para>
    C. Sending Messages to Sprites
    <link linkend="sending-messages-to-sprites">74</link>
  </para>
  <para>
    Polymorphism <link linkend="polymorphism">75</link>
  </para>
  <para>
    D. Local State in Sprites: Variables and Attributes
    <link linkend="local-state-in-sprites-variables-and-attributes">76</link>
  </para>
  <para>
    E. Prototyping: Parents and Children
    <link linkend="prototyping-parents-and-children">76</link>
  </para>
  <para>
    F. Inheritance by Delegation
    <link linkend="inheritance-by-delegation">77</link>
  </para>
  <para>
    G. List of attributes
    <link linkend="attrib.pnglist-of-attributes">78</link>
  </para>
  <para>
    H. First Class Costumes and Sounds
    <link linkend="first-class-costumes-and-sounds">79</link>
  </para>
  <para>
    Media Computation with Costumes
    <link linkend="media-computation-with-costumes">79</link>
  </para>
  <para>
    Media Computation with Sounds
    <link linkend="media-computation-with-sounds">82</link>
  </para>
  <para>
    VIII. OOP with Procedures
    <link linkend="oop-with-procedures">85</link>
  </para>
  <para>
    A. Local State with Script Variables
    <link linkend="local-state-with-script-variables">85</link>
  </para>
  <para>
    B. Messages and Dispatch Procedures
    <link linkend="messages-and-dispatch-procedures">86</link>
  </para>
  <para>
    C. Inheritance via Delegation
    <link linkend="inheritance-via-delegation">87</link>
  </para>
  <para>
    D. An Implementation of Prototyping OOP
    <link linkend="an-implementation-of-prototyping-oop">88</link>
  </para>
  <para>
    IX. The Outside World <link linkend="the-outside-world">91</link>
  </para>
  <para>
    A. The World Wide Web <link linkend="the-world-wide-web">91</link>
  </para>
  <para>
    B. Hardware Devices <link linkend="hardware-devices">92</link>
  </para>
  <para>
    C. Date and Time <link linkend="date-and-time">92</link>
  </para>
  <para>
    X. Continuations <link linkend="continuations">93</link>
  </para>
  <para>
    A. Continuation Passing Style
    <link linkend="continuation-passing-style">94</link>
  </para>
  <para>
    B. Call/Run w/Continuation
    <link linkend="callrun-wcontinuation">97</link>
  </para>
  <para>
    Nonlocal exit <link linkend="nonlocal-exit">99</link>
  </para>
  <para>
    XI. Metaprogramming <link linkend="metaprogramming">101</link>
  </para>
  <para>
    A. Reading a block <link linkend="reading-a-block">101</link>
  </para>
  <para>
    B. Writing a block <link linkend="writing-a-block">102</link>
  </para>
  <para>
    C. Macros <link linkend="macros">105</link>
  </para>
  <para>
    XII. User Interface Elements
    <link linkend="user-interface-elements">107</link>
  </para>
  <para>
    A. Tool Bar Features <link linkend="tool-bar-features">107</link>
  </para>
  <para>
    The Snap<emphasis>!</emphasis> Logo Menu
    <link linkend="the-snap-logo-menu">107</link>
  </para>
  <para>
    The File Menu <link linkend="the-file-menu">108</link>
  </para>
  <para>
    The Cloud Menu <link linkend="the-cloud-menu">113</link>
  </para>
  <para>
    The Settings Menu <link linkend="the-settings-menu">114</link>
  </para>
  <para>
    Visible Stepping Controls
    <link linkend="visible-stepping-controls">117</link>
  </para>
  <para>
    Stage Resizing Buttons
    <link linkend="stage-resizing-buttons">118</link>
  </para>
  <para>
    Project Control Buttons
    <link linkend="project-control-buttons">118</link>
  </para>
  <para>
    B. The Palette Area <link linkend="the-palette-area">119</link>
  </para>
  <para>
    Buttons in the Palette
    <link linkend="buttons-in-the-palette">119</link>
  </para>
  <para>
    Context Menus for Palette Blocks
    <link linkend="context-menus-for-palette-blocks">119</link>
  </para>
  <para>
    Context Menu for the Palette Background
    <link linkend="context-menu-for-the-palette-background">120</link>
  </para>
  <para>
    C. The Scripting Area <link linkend="the-scripting-area">122</link>
  </para>
  <para>
    Sprite Appearance and Behavior Controls
    <link linkend="sprite-appearance-and-behavior-controls">122</link>
  </para>
  <para>
    Scripting Area Tabs <link linkend="scripting-area-tabs">122</link>
  </para>
  <para>
    Scripts and Blocks Within Scripts
    <link linkend="scripts-and-blocks-within-scripts">122</link>
  </para>
  <para>
    Controls in the Costumes Tab
    <link linkend="controls-in-the-costumes-tab">126</link>
  </para>
  <para>
    The Paint Editor <link linkend="the-paint-editor">128</link>
  </para>
  <para>
    Controls in the Sounds Tab
    <link linkend="controls-in-the-sounds-tab">130</link>
  </para>
  <para>
    D. Keyboard Editing <link linkend="keyboard-editing">130</link>
  </para>
  <para>
    Starting and stopping the keyboard editor
    <link linkend="starting-and-stopping-the-keyboard-editor">130</link>
  </para>
  <para>
    Navigating in the keyboard editor
    <link linkend="navigating-in-the-keyboard-editor">130</link>
  </para>
  <para>
    Editing a script <link linkend="editing-a-script">131</link>
  </para>
  <para>
    Running the selected script
    <link linkend="running-the-selected-script">132</link>
  </para>
  <para>
    E. Controls on the Stage
    <link linkend="controls-on-the-stage">132</link>
  </para>
  <para>
    Sprites <link linkend="sprites">132</link>
  </para>
  <para>
    Variable watchers
    <link linkend="macintosh-hdusersbhdesktopwatcher-menu.pngvariable-watchers">134</link>
  </para>
  <para>
    The stage itself <link linkend="the-stage-itself">135</link>
  </para>
  <para>
    F. The Sprite Corral and Sprite Creation Buttons
    <link linkend="the-sprite-corral-and-sprite-creation-buttons">135</link>
  </para>
  <para>
    G. Preloading a Project when Starting Snap!
    <link linkend="preloading-a-project-when-starting-snap">136</link>
  </para>
  <para>
    H. Mirror Sites <link linkend="mirror-sites">137</link>
  </para>
  <para>
    Appendix A. Snap<emphasis>!</emphasis> color library
    <link linkend="appendix-a.-snap-color-library">138</link>
  </para>
  <para>
    Introduction to Color
    <link linkend="introduction-to-color">138</link>
  </para>
  <para>
    Crayons and Color Numbers
    <link linkend="crayons-and-color-numbers">139</link>
  </para>
  <para>
    Perceptual Spaces: HSV and HSL
    <link linkend="perceptual-spaces-hsv-and-hsl">142</link>
  </para>
  <para>
    Mixing Colors <link linkend="mixing-colors">144</link>
  </para>
  <para>
    tl;dr <link linkend="tldr">145</link>
  </para>
  <para>
    Subappendix: Geeky details on fair hue
    <link linkend="subappendix-geeky-details-on-fair-hue">145</link>
  </para>
  <para>
    Subappendix: Geeky details on color numbers
    <link linkend="subappendix-geeky-details-on-color-numbers">146</link>
  </para>
  <para>
    Appendix B. APL features
    <link linkend="appendix-b.-apl-features">148</link>
  </para>
  <para>
    Boolean values <link linkend="boolean-values">150</link>
  </para>
  <para>
    Scalar functions <link linkend="scalar-functions">150</link>
  </para>
  <para>
    Mixed functions <link linkend="mixed-functions">151</link>
  </para>
  <para>
    Higher order functions
    <link linkend="higher-order-functions">157</link>
  </para>
  <para>
    Index ……………………………………………………. 159
  </para>
  <para>
    Copyright © 2020 Jens Mönig and Brian Harvey.
  </para>
  <para>
    <inlinemediaobject>
      <imageobject>
        <imagedata fileref="media/image4.png" width="0.61111in" depth="0.21528in" />
      </imageobject>
      <textobject>
        <phrase>Macintosh HD:Users:bh:Desktop:cc.png</phrase>
      </textobject>
    </inlinemediaobject> This work is licensed under a
    <link xlink:href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative
    Commons Attribution-NonCommercial-ShareAlike 4.0 International
    License</link>.
  </para>
</section>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="acknowledgements">
  <title>Acknowledgements</title>
  <para>
    <emphasis role="smallcaps">W</emphasis>e have been extremely lucky
    in our mentors. Jens cut his teeth in the company of the Smalltalk
    pioneers: Alan Kay, Dan Ingalls, and the rest of the gang who
    invented personal computing and object oriented programming in the
    great days of Xerox PARC. He worked with John Maloney, of the MIT
    Scratch Team, who developed the Morphic graphics framework that’s
    still at the heart of Snap<emphasis>!</emphasis>.
  </para>
  <para>
    <emphasis role="strong"><emphasis>The brilliant design of Scratch,
    from the Lifelong Kindergarten Group at the MIT Media Lab, is
    crucial to</emphasis> Snap<emphasis>!. Our earlier version, BYOB,
    was a direct modification of the Scratch source code.</emphasis>
    Snap<emphasis>! is a complete rewrite, but its code structure and
    its user interface remain deeply indebted to Scratch. And the
    Scratch Team, who could have seen us as rivals, have been entirely
    supportive and welcoming to us.</emphasis></emphasis>
  </para>
  <para>
    Brian grew up at the MIT and Stanford Artificial Intelligence Labs,
    learning from Lisp inventor John McCarthy, Scheme inventors Gerald
    J. Sussman and Guy Steele, and the authors of the world’s best
    computer science book, <emphasis>Structure and Interpretation of
    Computer Programs,</emphasis> Hal Abelson and Gerald J. Sussman with
    Julie Sussman, among many other heroes of computer science. (Brian
    was also lucky enough, while in high school, to meet Kenneth
    Iverson, the inventor of APL.)
  </para>
  <para>
    <emphasis role="strong"><emphasis>In the glory days of the MIT Logo
    Lab, we used to say, “Logo is Lisp disguised as BASIC.” Now, with
    its first class procedures, lexical scope, and first class
    continuations,</emphasis> Snap<emphasis>! is Scheme disguised as
    Scratch.</emphasis></emphasis>
  </para>
  <para>
    Four people have made such massive contributions to the
    implementation of Snap<emphasis>!</emphasis> that we have officially
    declared them members of the team: Michael Ball and Bernat Romagosa,
    in addition to contributions throughout the project, have primary
    responsibility for the web site and cloud storage. Joan Guillén i
    Pelegay has contributed very careful and wise analysis of
    outstanding issues, including help in taming the management of
    translations to non-English languages. Jadga Hügle, has
    energetically contributed to online mini-courses about
    Snap<emphasis>!</emphasis> and leading workshops for kids and for
    adults. Jens, Jadga, and Bernat are paid to work on
    Snap<emphasis>!</emphasis> by SAP, which also supports our computing
    needs.
  </para>
  <para>
    We have been fortunate to get to know an amazing group of brilliant
    middle school(!) and high school students through the Scratch
    Advanced Topics forum, several of whom (since grown up) have
    contributed code to Snap<emphasis>!</emphasis>: Kartik Chandra,
    Nathan Dinsmore, Connor Hudson, Ian Reynolds, and Deborah Servilla.
    Many more have contributed ideas and alpha-testing bug reports. UC
    Berkeley students who’ve contributed code include Achal Dave. Kyle
    Hotchkiss, Ivan Motyashov, and Yuan Yuan. Contributors of
    translations are too numerous to list here, but they’re in the
    “About…” box in Snap<emphasis>!</emphasis> itself.
  </para>
  <para>
    This material is based upon work supported in part by the National
    Science Foundation under Grants
    No<emphasis role="smallcaps">.</emphasis> 1138596, 1143566, and
    1441075; and in part by MioSoft, Arduino.org, SAP, and YC Research.
    Any opinions, findings, and conclusions or recommendations expressed
    in this material are those of the author(s) and do not necessarily
    reflect the views of the National Science Foundation or other
    funders.
  </para>
<literallayout><emphasis role="smallcaps">
</emphasis><emphasis role="strong"><emphasis role="underline">Snap<emphasis>!</emphasis> Reference Manual</emphasis></emphasis></literallayout>
  <para>
    <emphasis role="strong">Version 8.0</emphasis>
  </para>
  <para>
    Snap<emphasis>!</emphasis> (formerly BYOB) is an extended
    reimplementation of Scratch
    (<emphasis role="underline">https://scratch.mit.edu</emphasis>) that
    allows you to Build Your Own Blocks. It also features ﬁrst class
    lists, ﬁrst class procedures, first class sprites, first class
    costumes, first class sounds, and first class continuations. These
    added capabilities make it suitable for a serious introduction to
    computer science for high school or college students.
  </para>
  <para>
    In this manual we sometimes make reference to Scratch, e.g., to
    explain how some Snap<emphasis>!</emphasis> feature extends
    something familiar in Scratch. It’s very helpful to have some
    experience with Scratch before reading this manual, but not
    essential.
  </para>
  <para>
    To run
    Snap<emphasis>!</emphasis><emphasis role="smallcaps">,</emphasis>
    open a browser window and connect to https://snap.berkeley.edu/run.
    The Snap<emphasis>!</emphasis> community web site at
    https://snap.berkeley.edu is not part of this manual’s scope.
  </para>
</section>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="blocks-scripts-and-sprites">
  <title>Blocks, Scripts, and Sprites</title>
  <para>
    This chapter describes the Snap<emphasis>!</emphasis> features
    inherited from Scratch; experienced Scratch users can skip to
    Section B.
  </para>
  <para>
    Snap<emphasis>!</emphasis> is a programming language—a notation in
    which you can tell a computer what you want it to do. Unlike most
    programming languages, though, Snap<emphasis>!</emphasis> is a
    <emphasis>visual</emphasis> language; instead of writing a program
    using the keyboard, the Snap<emphasis>!</emphasis> programmer uses
    the same drag-and-drop interface familiar to computer users.
  </para>
  <para>
    <inlinemediaobject>
      <imageobject>
        <imagedata fileref="media/image5.png" width="4.32639in" depth="2.68958in" />
      </imageobject>
    </inlinemediaobject>Start
    Snap<emphasis>!</emphasis><emphasis role="smallcaps">.</emphasis>
    You should see the following arrangement of regions in the window:
  </para>
  <para>
    (The proportions of these areas may be different, depending on the
    size and shape of your browser window.)
  </para>
  <para>
    <inlinemediaobject>
      <imageobject>
        <imagedata fileref="media/image6.png" width="1.47917in" depth="1.35417in" />
      </imageobject>
    </inlinemediaobject>A Snap<emphasis>!</emphasis> program consists of
    one or more <emphasis>scripts,</emphasis> each of which is made of
    <emphasis>blocks.</emphasis> Here’s a typical script:
  </para>
  <para>
    <inlinemediaobject>
      <imageobject>
        <imagedata fileref="media/image7.png" width="2.24653in" depth="1.46944in" />
      </imageobject>
    </inlinemediaobject><inlinemediaobject>
      <imageobject>
        <imagedata fileref="media/image8.png" width="2.20833in" depth="1.13889in" />
      </imageobject>
    </inlinemediaobject>The five blocks that make up this script have
    three different colors, corresponding to three of the eight
    <emphasis>palettes</emphasis> in which blocks can be found. The
    palette area at the left edge of the window shows one palette at a
    time, chosen with the eight buttons just above the palette area. In
    this script, the gold blocks are from the Control palette; the green
    block is from the Pen palette; and the blue blocks are from the
    Motion palette. A script is assembled by dragging blocks from a
    palette into the <emphasis>scripting area</emphasis> in the middle
    part of the window. Blocks snap together (hence the name
    Snap<emphasis>!</emphasis> for the language) when you drag a block
    so that its indentation is near the tab of the one above it:
  </para>
  <para>
    The white horizontal line is a signal that if you let go of the
    green block it will snap into the tab of the gold one.
  </para>
  <section xml:id="hat-blocks-and-command-blocks" role="unnumbered">
    <title>Hat Blocks and Command Blocks</title>
    <para>
      At the top of the script is a <emphasis>hat</emphasis> block,
      which indicates when the script should be carried out. Hat block
      names typically start with the word “when”; in the square-drawing
      example on page 5, the script should be run when the green flag
      near the right end of the Snap<emphasis>!</emphasis> tool bar is
      clicked. (The Snap<emphasis>!</emphasis> tool bar is part of the
      Snap<emphasis>!</emphasis> window, not the same as the browser’s
      or operating system’s menu bar.) A script isn’t required to have a
      hat block, but if not, then the script will be run only if the
      user clicks on the script itself. A script can’t have more than
      one hat block, and the hat block can be used only at the top of
      the script; its distinctive shape is meant to remind you of
      that.<footnote>
        <para>
          One of the hat blocks, the generic “when anything” block , is
          subtly different from the others. When the stop sign is
          clicked, or when a project or sprite is loaded, this block
          doesn’t test whether the condition in its hexagonal input slot
          is true, so the script beneath it will not run, until some
          <emphasis>other</emphasis> script in the project runs
          (because, for example, you click the green flag). When generic
          when blocks are disabled, the stop sign will be square instead
          of octagonal.
        </para>
      </footnote><anchor xml:id="generic_when" />
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image9.png" width="1.16667in" depth="0.25in" />
        </imageobject>
      </inlinemediaobject>The other blocks in our example script are
      <emphasis>command</emphasis> blocks. Each command block
      corresponds to an action that Snap<emphasis>!</emphasis> already
      knows how to carry out. For example, the block tells the sprite
      (the arrowhead shape on the <emphasis>stage</emphasis> at the
      right end of the window) to move ten steps (a step is a very small
      unit of distance) in the direction in which the arrowhead is
      pointing. We’ll see shortly that there can be more than one
      sprite, and that each sprite has its own scripts. Also, a sprite
      doesn’t have to look like an arrowhead, but can have any picture
      as a <emphasis>costume.</emphasis> The shape of the move block is
      meant to remind you of a Lego™ brick; a script is a stack of
      blocks. (The word “block” denotes both the graphical shape on the
      screen and the procedure, the action, that the block carries out.)
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image10.png" width="1.09722in" depth="0.35417in" />
        </imageobject>
      </inlinemediaobject>The number 10 in the move block above is
      called an <emphasis>input</emphasis> to the block. By clicking on
      the white oval, you can type any number in place of the 10. The
      sample script on the previous page uses 100 as the input value.
      We’ll see later that inputs can have non-oval shapes that accept
      values other than numbers. We’ll also see that you can compute
      input values, instead of typing a particular value into the oval.
      A block can have more than one input slot. For example, the glide
      block located about halfway down the Motion palette has three
      inputs.
    </para>
    <para>
      Most command blocks have that brick shape, but some, like the
      repeat block in the sample script, are
      <emphasis>C‑shaped.</emphasis> Most C-shaped blocks are found in
      the Control palette. The slot inside the C shape is a special kind
      of input slot that accepts a <emphasis>script</emphasis> as the
      input.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image6.png" width="1.47917in" depth="1.35417in" />
        </imageobject>
      </inlinemediaobject>
    </para>
    <para>
      the repeat block has two inputs: the number 4 and the script
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image11.png" width="1.40625in" depth="0.48958in" />
        </imageobject>
      </inlinemediaobject>In the sample script
    </para>
    <para>
      C-shaped blocks can be put in a script in two ways. If you see a
      white line and let go, the block will be inserted into the script
      like any command block:
    </para>
    <para>
      But if you see an orange halo and let go, the block will
      <emphasis>wrap</emphasis> around the haloed blocks:
    </para>
    <para>
      The halo will always extend from the cursor position to the bottom
      of the script:
    </para>
    <para>
      If you want only some of those blocks, after wrapping you can grab
      the first block you don’t want wrapped, pull it down, and snap it
      under the C-shaped block.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image24.png" width="2.31111in" depth="1.36667in" />
        </imageobject>
      </inlinemediaobject>For “E-shaped” blocks with more than one
      C-shaped slot, only the first slot will wrap around existing
      blocks in a script, and only if that C-shaped slot is empty before
      wrapping. (You can fill the other slots by dragging blocks into
      the desired slot.)
    </para>
  </section>
  <section xml:id="sprites-and-parallelism">
    <title>
    <inlinemediaobject>
      <imageobject>
        <imagedata fileref="media/image25.png" width="0.34028in" depth="0.24306in" />
      </imageobject>
    </inlinemediaobject>Sprites and Parallelism</title>
    <para>
      Just below the stage is the “new sprite” button . Click the button
      to add a new sprite to the stage. The new sprite will appear in a
      random position on the stage, with a random color, but always
      facing to the right.
    </para>
    <para>
      Each sprite has its own scripts. To see the scripts for a
      particular sprite in the scripting area, click on the picture of
      that sprite in the <emphasis>sprite corral</emphasis> in the
      bottom right corner of the window. Try putting one of the
      following scripts in each sprite’s scripting area:
    </para>
    <blockquote>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image26.png" width="1.55069in" depth="0.99375in" />
          </imageobject>
        </inlinemediaobject> <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image27.png" width="1.54167in" depth="1.16667in" />
          </imageobject>
        </inlinemediaobject>
      </para>
    </blockquote>
    <para>
      When you click the green flag, you should see one sprite rotate
      while the other moves back and forth. This experiment illustrates
      the way different scripts can run in parallel. The turning and the
      moving happen together. Parallelism can be seen with multiple
      scripts of a single sprite also. Try this example:
    </para>
    <blockquote>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image28.png" width="1.72917in" depth="0.875in" />
          </imageobject>
        </inlinemediaobject> <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image29.png" width="1.72917in" depth="0.89583in" />
          </imageobject>
        </inlinemediaobject>
      </para>
    </blockquote>
    <para>
      When you press the space key, the sprite should move forever in a
      circle, because the move and turn blocks are run in parallel. (To
      stop the program, click the red stop sign at the right end of the
      tool bar.)
    </para>
    <section xml:id="costumes-and-sounds">
      <title>Costumes and Sounds</title>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image30.png" width="0.31944in" depth="0.21528in" />
          </imageobject>
        </inlinemediaobject><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image31.png" width="1.76667in" depth="1.875in" />
          </imageobject>
        </inlinemediaobject><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image32.png" width="0.29167in" depth="0.16667in" />
          </imageobject>
          <textobject>
            <phrase>Macintosh HD:Users:bh:Desktop:paintbutton.png</phrase>
          </textobject>
        </inlinemediaobject>To change the appearance of a sprite, paint
        or import a new <emphasis>costume</emphasis> for it. To paint a
        costume, click on the Costumes tab above the scripting area, and
        click the paint button . The <emphasis>Paint Editor</emphasis>
        that appears is explained on page
        <link linkend="the-paint-editor">128</link>. There are three
        ways to import a costume. First select the desired sprite in the
        sprite corral. Then, one way is to click on the file icon in the
        tool bar , then choose the “Costumes…”menu item. You will see a
        list of costumes from the public media library, and can choose
        one. The second way, for a costume stored on your own computer,
        is to click on the file icon and choose the “Import…” menu item.
        You can then select a file in any picture format (PNG, JPEG,
        etc.) supported by your browser. The third way is quicker if the
        file you want is visible on the desktop: Just drag the file onto
        the Snap<emphasis>!</emphasis> window. In any of these cases,
        the scripting area will be replaced by something like this:
      </para>
      <para>
        Just above this part of the window is a set of three tabs:
        Scripts, Costumes, and Sounds. You’ll see that the Costumes tab
        is now selected. In this view, the sprite’s
        <emphasis>wardrobe,</emphasis> you can choose whether the sprite
        should wear its Turtle costume or its Alonzo costume. (Alonzo,
        the Snap<emphasis>!</emphasis> mascot, is named after Alonzo
        Church, a mathematician who invented the idea of procedures as
        data, the most important way in which Snap<emphasis>!</emphasis>
        is different from Scratch.) You can give a sprite as many
        costumes as you like, and then choose which it will wear either
        by clicking in its wardrobe or by using the or block in a
        script. (Every costume has a number as well as a name. The next
        costume block selects the next costume by number; after the
        highest-numbered costume it switches to costume 1. The Turtle,
        costume 0, is never chosen by next costume.) The Turtle costume
        is the only one that changes color to match a change in the
        sprite’s pen color. Protip: switches to the
        <emphasis>previous</emphasis> costume, wrapping like next
        costume.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image33.png" width="1.80556in" depth="0.27778in" />
          </imageobject>
        </inlinemediaobject><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image38.png" width="1.89583in" depth="0.26042in" />
          </imageobject>
        </inlinemediaobject><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image39.png" width="1.23958in" depth="0.26042in" />
          </imageobject>
        </inlinemediaobject>In addition to its costumes, a sprite can
        have <emphasis>sounds;</emphasis> the equivalent for sounds of
        the sprite’s wardrobe is called its
        <emphasis>jukebox.</emphasis> Sound files can be imported in any
        format (WAV, OGG, MP3, etc.) supported by your browser. Two
        blocks accomplish the task of playing sounds. If you would like
        a script to continue running while the sound is playing, use the
        block . In contrast, you can use the block to wait for the
        sound's completion before continuing the rest of the
        script<emphasis>.</emphasis>
      </para>
    </section>
    <section xml:id="inter-sprite-communication-with-broadcast">
      <title>Inter-Sprite Communication with Broadcast</title>
      <para>
        Earlier we saw an example of two sprites moving at the same
        time. In a more interesting program, though, the sprites on
        stage will <emphasis>interact</emphasis> to tell a story, play a
        game, etc. Often one sprite will have to tell another sprite to
        run a script. Here’s a simple example:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image40.png" width="1.71875in" depth="0.24939in" />
          </imageobject>
        </inlinemediaobject><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image41.png" width="0.56944in" depth="1.11111in" />
          </imageobject>
        </inlinemediaobject> <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image42.png" width="2.78418in" depth="1.51042in" />
          </imageobject>
        </inlinemediaobject> <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image43.png" width="1.24306in" depth="0.86111in" />
          </imageobject>
        </inlinemediaobject> <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image44.png" width="1.52083in" depth="0.60417in" />
          </imageobject>
        </inlinemediaobject>
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image45.png" width="1.78958in" depth="0.2in" />
          </imageobject>
        </inlinemediaobject><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image46.png" width="1.8in" depth="0.19167in" />
          </imageobject>
        </inlinemediaobject>In the block, the word “bark” is just an
        arbitrary name I made up. When you click on the downward
        arrowhead in that input slot, one of the choices (the only
        choice, the first time) is “new,” which then prompts you to
        enter a name for the new broadcast. When this block is run, the
        chosen message is sent to <emphasis>every</emphasis> sprite,
        which is why the block is called “broadcast.” (But if you click
        the right arrow after the message name, the block becomes , and
        you can change it to  to send the message just to one sprite.)
        In this program, though, only one sprite has a script to run
        when that broadcast is sent, namely the dog. Because the boy’s
        script uses broadcast and wait rather than just broadcast, the
        boy doesn’t go on to his next say block until the dog’s script
        finishes. That’s why the two sprites take turns talking, instead
        of both talking at once. In Chapter VII, “Object-Oriented
        Programming with Sprites,” you’ll see a more flexible way to
        send a message to a specific sprite using the tell and ask
        blocks.
      </para>
      <para>
        Notice, by the way, that the say block’s first input slot is
        rectangular rather than oval. This means the input can be any
        text string, not only a number. In text input slots, a space
        character is shown as a brown dot, so that you can count the
        number of spaces between words, and in particular you can tell
        the difference between an empty slot and one containing spaces.
        The brown dots are <emphasis>not</emphasis> shown on the stage
        if the text is displayed.
      </para>
      <para>
        The stage has its own scripting area. It can be selected by
        clicking on the Stage icon at the left of the sprite corral.
        Unlike a sprite, though, the stage can’t move. Instead of
        costumes, it has <emphasis>backgrounds:</emphasis> pictures that
        fill the entire stage area. The sprites appear in front of the
        current background. In a complicated project, it’s often
        convenient to use a script in the stage’s scripting area as the
        overall director of the action.
      </para>
    </section>
  </section>
  <section xml:id="nesting-sprites-anchors-and-parts">
    <title>Nesting Sprites: Anchors and Parts</title>
    <para>
      Sometimes it’s desirable to make a sort of “super-sprite” composed
      of pieces that can move together but can also be separately
      articulated. The classic example is a person’s body made up of a
      torso, limbs, and a head. Snap<emphasis>!</emphasis> allows one
      sprite to be designated as the <emphasis>anchor</emphasis> of the
      combined shape, with other sprites as its
      <emphasis>parts.</emphasis> To set up sprite nesting, drag the
      sprite corral icon of a <emphasis>part</emphasis> sprite onto the
      stage display (not the sprite corral icon!) of the desired
      <emphasis>anchor</emphasis> sprite. The precise place where you
      let go of the mouse button will be the attachment point of the
      part on the anchor.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image47.png" width="1.63056in" depth="0.96528in" />
        </imageobject>
      </inlinemediaobject>Sprite nesting is shown in the sprite corral
      icons of both anchors and parts:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image56.png" width="1.44444in" depth="1.5625in" />
        </imageobject>
      </inlinemediaobject>In this illustration, it is desired to animate
      Alonzo’s arm. (The arm has been colored green in this picture to
      make the relationship of the two sprites clearer, but in a real
      project they’d be the same color, probably.) Sprite, representing
      Alonzo’s body, is the anchor; Sprite(2) is the arm. The icon for
      the anchor shows small images of up to three attached parts at the
      bottom. The icon for each part shows a small image of the anchor
      in its top left corner, and a <emphasis>synchronous/dangling
      rotation flag</emphasis> in the top right corner. In its initial,
      synchronous setting, as shown above, it means that the when the
      anchor sprite rotates, the part sprite also rotates as well as
      revolving around the anchor. When clicked, it changes from a
      circular arrow to a straight arrow, and indicates that when the
      anchor sprite rotates, the part sprite revolves around it, but
      does not rotate, keeping its original orientation. (The part can
      also be rotated separately, using its turn blocks.) Any change in
      the position or size of the anchor is always extended to its
      parts. Also, cloning the anchor (see Section VII. B) will also
      clone all its parts.
    </para>
    <para>
      <emphasis>Top: turning the part: the green arm. Bottom: turning
      the anchor, with the arm synchronous (left) and dangling
      (right).</emphasis>
    </para>
  </section>
  <section xml:id="reporter-blocks-and-expressions">
    <title>Reporter Blocks and Expressions</title>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image65.png" width="1.47in" depth="0.52in" />
        </imageobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image66.png" width="0.72917in" depth="0.15625in" />
        </imageobject>
      </inlinemediaobject>So far, we’ve used two kinds of blocks: hat
      blocks and command blocks. Another kind is the
      <emphasis>reporter</emphasis> block, which has an oval shape: .
      It’s called a “reporter” because when it’s run, instead of
      carrying out an action, it reports a value that can be used as an
      input to another block. If you drag a reporter into the scripting
      area by itself and click on it, the value it reports will appear
      in a speech balloon next to the block:
    </para>
    <para>
      When you drag a reporter block over another block’s input slot, a
      white “halo” appears around that input slot, analogous to the
      white line that appears when snapping command blocks together:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image71.png" width="2.11111in" depth="0.61806in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:Google Chrome001.png</phrase>
        </textobject>
      </inlinemediaobject>Don’t drop the input over a
      <emphasis>red</emphasis> halo:
    </para>
    <para>
      That’s used for a purpose explained on page
      <link linkend="recursive-calls-to-multiple-input-blocks">68</link>.
    </para>
    <para>
      Here’s a simple script that uses a reporter block:
    </para>
    <para>
      Here the x position reporter provides the first input to the say
      block. (The sprite’s X position is its horizontal position, how
      far left (negative values) or right (positive values) it is
      compared to the center of the stage. Similarly, the Y position is
      measured vertically, in steps above (positive) or below (negative)
      the center.)
    </para>
    <para>
      You can do arithmetic using reporters in the Operators palette:
    </para>
    <para>
      The round block rounds 35.3905… to 35, and the + block adds 100 to
      that. (By the way, the round block is in the Operators palette,
      just like +, but in this script it’s a lighter color with black
      lettering because Snap<emphasis>!</emphasis> alternates light and
      dark versions of the palette colors when a block is nested inside
      another block from the same palette:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image80.png" width="4.85417in" depth="1.90625in" />
        </imageobject>
      </inlinemediaobject>
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image81.png" width="1.91667in" depth="0.23958in" />
        </imageobject>
      </inlinemediaobject>This aid to readability is called
      <emphasis>zebra coloring.</emphasis>) A reporter block with its
      inputs, maybe including other reporter blocks, such as , is called
      an <emphasis>expression.</emphasis>
    </para>
  </section>
  <section xml:id="predicates-and-conditional-evaluation">
    <title>
    Predicates and Conditional Evaluation</title>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image82.png" width="0.66667in" depth="0.1875in" />
        </imageobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image83.png" width="1.20833in" depth="0.1875in" />
        </imageobject>
      </inlinemediaobject>Most reporters report either a number, like ,
      or a text string, like . A <emphasis>predicate</emphasis> is a
      special kind of reporter that always reports true or false.
      Predicates have a hexagonal shape:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image84.png" width="1.94792in" depth="0.26042in" />
        </imageobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image85.png" width="1.07292in" depth="0.15625in" />
        </imageobject>
      </inlinemediaobject>The special shape is a reminder that
      predicates don’t generally make sense in an input slot of blocks
      that are expecting a number or text. You wouldn’t say , although
      (as you can see from the picture) Snap<emphasis>!</emphasis> lets
      you do it if you really want. Instead, you normally use predicates
      in special hexagonal input slots like this one:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image86.png" width="0.66667in" depth="0.56944in" />
        </imageobject>
      </inlinemediaobject>The C-shaped if block runs its input script if
      (and only if) the expression in its hexagonal input reports true.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image87.png" width="1.59375in" depth="0.61458in" />
        </imageobject>
      </inlinemediaobject>A really useful block in animations runs its
      input script <emphasis>repeatedly</emphasis> until a predicate is
      satisfied:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image88.png" width="2.28194in" depth="1.46875in" />
        </imageobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image89.png" width="2.29167in" depth="0.84375in" />
        </imageobject>
      </inlinemediaobject>If, while working on a project, you want to
      omit temporarily some commands in a script, but you don’t want to
      forget where they belong, you can say
    </para>
    <para>
      Sometimes you want to take the same action whether some condition
      is true or false, but with a different input value. For this
      purpose you can use the <emphasis>reporter</emphasis> if block:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image90.png" width="4.20833in" depth="0.38542in" />
        </imageobject>
      </inlinemediaobject>The technical term for a true or false value
      is a “Boolean” value; it has a capital B because it’s named after
      a person, George Boole, who developed the mathematical theory of
      Boolean values. Don’t get confused; a hexagonal block is a
      <emphasis>predicate,</emphasis> but the value it reports is a
      <emphasis>Boolean.</emphasis>
    </para>
    <para>
      Another quibble about vocabulary: Many programming languages
      reserve the name “procedure” for Commands (that carry out an
      action) and use the name “function” for Reporters and Predicates.
      In this manual, a <emphasis>procedure</emphasis> is any
      computational capability, including those that report values and
      those that don’t. Commands, Reporters, and Predicates are all
      procedures. The words “a Procedure type” are shorthand for
      “Command type, Reporter type, or Predicate type.”
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image91.png" width="1.375in" depth="0.24306in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:turbo-false.png</phrase>
        </textobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image92.png" width="1.375in" depth="0.24306in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:turbo-true.png</phrase>
        </textobject>
      </inlinemediaobject>If you want to put a
      <emphasis>constant</emphasis> Boolean value in a hexagonal slot
      instead of a predicate-based expression, hover the mouse over the
      block and click on the control that appears:
    </para>
  </section>
  <section xml:id="variables">
    <title>Variables</title>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image93.png" width="1.58333in" depth="1.41667in" />
        </imageobject>
      </inlinemediaobject>Try this script:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image94.png" width="1.88542in" depth="1.4375in" />
        </imageobject>
      </inlinemediaobject>The input to the move block is an orange oval.
      To get it there, drag the orange oval that’s part of the for
      block:
    </para>
    <para>
      The orange oval is a <emphasis>variable:</emphasis> a symbol that
      represents a value. (I took this screenshot before changing the
      second number input to the for block from the default 10 to 200,
      and before dragging in a turn block.) For runs its script input
      repeatedly, just like repeat, but before each repetition it sets
      the variable i to a number starting with its first numeric input,
      adding 1 for each repetition, until it reaches the second numeric
      input. In this case, there will be 200 repetitions, first with
      i=1, then with i=2, then 3, and so on until i=200 for the final
      repetition. The result is that each move draws a longer and longer
      line segment, and that’s why the picture you see is a kind of
      spiral. (If you try again with a turn of 90 degrees instead of 92,
      you’ll see why this picture is called a “squiral.”)
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image95.png" width="3.1875in" depth="1.5in" />
        </imageobject>
      </inlinemediaobject>The variable i is created by the for block,
      and it can only be used in the script inside the block’s C-slot.
      (By the way, if you don’t like the name i, you can change it by
      clicking on the orange oval without dragging it, which will pop up
      a dialog window in which you can enter a different name:
    </para>
    <para>
      “I” isn’t a very descriptive name; you might prefer “length” to
      indicate its purpose in the script. “I” is traditional because
      mathematicians tend to use letters between i and n to represent
      integer values, but in programming languages we don’t have to
      restrict ourselves to single-letter variable names.)
    </para>
    <section xml:id="global-variables">
      <title>
      Global Variables</title>
      <para>
        You can create variables “by hand” that aren’t limited to being
        used within a single block. At the top of the Variables palette,
        click the “Make a variable” button:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image96.png" width="3.1875in" depth="1.84375in" />
          </imageobject>
        </inlinemediaobject><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image97.png" width="2.05208in" depth="2.27083in" />
          </imageobject>
        </inlinemediaobject>This will bring up a dialog window in which
        you can give your variable a name:
      </para>
      <para>
        The dialog also gives you a choice to make the variable
        available to all sprites (which is almost always what you want)
        or to make it visible only in the current sprite. You’d do that
        if you’re going to give several sprites individual variables
        <emphasis>with the same name,</emphasis> so that you can share a
        script between sprites (by dragging it from the current sprite’s
        scripting area to the picture of another sprite in the sprite
        corral), and the different sprites will do slightly different
        things when running that script because each has a different
        value for that variable name.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image98.png" width="1.65833in" depth="2.29167in" />
          </imageobject>
        </inlinemediaobject>If you give your variable the name “name”
        then the Variables palette will look like this:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image99.png" width="1.04167in" depth="0.40625in" />
          </imageobject>
        </inlinemediaobject>There’s now a “Delete a variable” button,
        and there’s an orange oval with the variable name in it, just
        like the orange oval in the for block. You can drag the variable
        into any script in the scripting area. Next to the oval is a
        checkbox, initially checked. When it’s checked, you’ll also see
        a <emphasis>variable watcher</emphasis> on the stage:
      </para>
      <para>
        When you give the variable a value, the orange box in its
        watcher will display the value.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image100.png" width="1.92708in" depth="0.47917in" />
          </imageobject>
        </inlinemediaobject>How <emphasis>do</emphasis> you give it a
        value? You use the set block:
      </para>
      <para>
        Note that you <emphasis>don’t</emphasis> drag the variable’s
        oval into the set block! You click on the downarrow in the first
        input slot, and you get a menu of all the available variable
        names.
      </para>
      <para>
        If you do choose “For this sprite only” when creating a
        variable, its block in the palette looks like this:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image101.png" width="0.65833in" depth="0.14167in" />
          </imageobject>
          <textobject>
            <phrase>Macintosh HD:Users:bh:Desktop:local-var.png</phrase>
          </textobject>
        </inlinemediaobject> The <emphasis>location</emphasis>-pin icon
        is a bit of a pun on a sprite-<emphasis>local</emphasis>
        variable. It’s shown only in the palette.
      </para>
    </section>
    <section xml:id="script-variables">
      <title>Script Variables</title>
      <para>
        In the name example above, our project is going to carry on an
        interaction with the user, and we want to remember their name
        throughout the project. That’s a good example of a situation in
        which a <emphasis>global</emphasis> variable (the kind you make
        with the “Make a variable” button) is appropriate. Another
        common example is a variable called “score” in a game project.
        But sometimes you only need a variable temporarily, during the
        running of a particular script. In that case you can use the
        script variables block to make the variable:
      </para>
      <para>
        As in the for block, you can click on an orange oval in the
        script variables block without dragging to change its name. You
        can also make more than one temporary variable by clicking on
        the right arrow at the end of the block to add another variable
        oval:
      </para>
    </section>
    <section xml:id="renaming-variables">
      <title><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image106.png" width="2.08333in" depth="0.30208in" />
        </imageobject>
      </inlinemediaobject>Renaming variables</title>
      <para>
        There are several reasons why you might want to change the name
        of a variable:
      </para>
      <orderedlist numeration="arabic">
        <listitem>
          <para>
            It has a default name, such as the “a” in script variables
            or the “i” in for.
          </para>
        </listitem>
        <listitem>
          <para>
            It conflicts with another name, such as a global variable,
            that you want to use in the same script.
          </para>
        </listitem>
        <listitem>
          <para>
            You just decide a different name would be more
            self-documenting.
          </para>
        </listitem>
      </orderedlist>
      <para>
        In the first and third case, you probably want to change the
        name everywhere it appears in that script, or even in all
        scripts. In the second case, if you’ve already used both
        variables in the script before realizing that they have the same
        name, you’ll want to look at each instance separately to decide
        which ones to rename. Both of these operations are possible by
        right-clicking or control-clicking on a variable oval.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image107.png" width="1.61389in" depth="1.50764in" />
          </imageobject>
        </inlinemediaobject><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image108.png" width="2.82639in" depth="1.25694in" />
          </imageobject>
        </inlinemediaobject><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image109.png" width="1.38194in" depth="0.74306in" />
          </imageobject>
        </inlinemediaobject>If you right-click on an orange oval in a
        context in which the variable is <emphasis>used,</emphasis> then
        you are able to rename just that one orange oval:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image110.png" width="1.70833in" depth="0.83333in" />
          </imageobject>
        </inlinemediaobject><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image111.png" width="1.49306in" depth="0.74306in" />
          </imageobject>
        </inlinemediaobject>If you right-click on the place where the
        variable is <emphasis>defined</emphasis> (a script variables
        block, the orange oval for a global variable in the Variables
        palette, or an orange oval that’s built into a block such as the
        “i” in for), then you are given two renaming options, “rename”
        and “rename all.” If you choose “rename,” then the name is
        changed only in that one orange oval, as in the previous case:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image112.png" width="1.49306in" depth="0.74306in" />
          </imageobject>
        </inlinemediaobject><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image113.png" width="1.70833in" depth="0.83333in" />
          </imageobject>
        </inlinemediaobject>But if you choose “rename all,” then the
        name will be changed throughout the scope of the variable (the
        script for a script variable, or everywhere for a global
        variable):
      </para>
    </section>
    <section xml:id="transient-variables">
      <title>Transient variables</title>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image114.png" width="1.29167in" depth="1.05556in" />
          </imageobject>
        </inlinemediaobject>So far we’ve talked about variables with
        numeric values, or with short text strings such as someone’s
        name. But there’s no limit to the amount of information you can
        put in a variable; in Chapter IV you’ll see how to use
        <emphasis>lists</emphasis> to collect many values in one data
        structure, and in Chapter VIII you’ll see how to read
        information from web sites. When you use these capabilities,
        your project may take up a lot of memory in the computer. If you
        get close to the amount of memory available to
        Snap<emphasis>!</emphasis>, then it may become impossible to
        save your project. (Extra space is needed temporarily to convert
        from Snap<emphasis>!</emphasis> ’s internal representation to
        the form in which projects are exported or saved.) If your
        program reads a lot of data from the outside world that will
        still be available when you use it next, you might want to have
        values containing a lot of data removed from memory before
        saving the project. To do this, right-click or control-click on
        the orange oval in the Variables palette, to see this menu:
      </para>
      <para>
        You already know about the rename options, and help… displays a
        help screen about variables in general. Here we’re interested in
        the check box next to transient. If you check it, this
        variable’s value will not be saved when you save your project.
        Of course, you’ll have to ensure that when your project is
        loaded, it recreates the needed value and sets the variable to
        it.
      </para>
    </section>
  </section>
  <section xml:id="debugging">
    <title>Debugging</title>
    <para>
      Snap<emphasis>!</emphasis> provides several tools to help you
      debug a program. They center around the idea of
      <emphasis>pausing</emphasis> the running of a script partway
      through, so that you can examine the values of variables.
    </para>
    <section xml:id="the-pause-button">
      <title>The pause button</title>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image115.png" width="0.29167in" depth="0.16667in" />
          </imageobject>
        </inlinemediaobject><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image116.png" width="0.29167in" depth="0.16667in" />
          </imageobject>
        </inlinemediaobject>The simplest way to pause a program is
        manually, by clicking the pause button in the top right corner
        of the window. While the program is paused, you can run other
        scripts by clicking on them, show variables on stage with the
        checkbox next to the variable in the Variables palette or with
        the show variable block, and do all the other things you can
        generally do, including modifying the paused scripts by adding
        or removing blocks. The button changes shape to and clicking it
        again resumes the paused scripts.
      </para>
    </section>
    <section xml:id="breakpoints-the-pause-all-block">
      <title>Breakpoints: the pause all block</title>
      <para>
        <anchor xml:id="pause_all" /><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image117.png" width="0.81944in" depth="0.21528in" />
          </imageobject>
        </inlinemediaobject>The pause button is great if your program
        seems to be in an infinite loop, but more often you’ll want to
        set a <emphasis>breakpoint,</emphasis> a particular point in a
        script at which you want to pause. The block, near the bottom of
        the Control palette, can be inserted in a script to pause when
        it is run. So, for example, if your program is getting an error
        message in a particular block, you could use pause all just
        before that block to look at the values of variables just before
        the error happens.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image118.png" width="1.88333in" depth="0.91111in" />
          </imageobject>
        </inlinemediaobject>The pause all block turns bright cyan while
        paused. Also, during the pause, you can right-click on a running
        script and the menu that appears will give you the option to
        show watchers for temporary variables of the script:
      </para>
      <para>
        But what if the block with the error is run many times in a
        loop, and it only errors when a particular condition is
        true—say, the value of some variable is negative, which
        shouldn’t ever happen. In the iteration library (see page
        <link linkend="libraries-1">25</link> for more about how to use
        libraries) is a breakpoint block that lets you set a
        <emphasis>conditional</emphasis> breakpoint, and automatically
        display the relevant variables before pausing. Here’s a sample
        use of it:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image119.png" width="1.19444in" depth="1.33333in" />
          </imageobject>
        </inlinemediaobject>(In this contrived example, variable zot
        comes from outside the script but is relevant to its behavior.)
        When you continue (with the pause button), the temporary
        variable watchers are removed by this breakpoint block before
        resuming the script. The breakpoint block isn’t magic; you could
        alternatively just put a pause all inside an if.<footnote>
          <para>
            The hide variable and show variable blocks can also be used
            to hide and show primitives in the palette. The pulldown
            menu doesn’t include primitive blocks, but there’s a
            generally useful technique to give a block input values it
            wasn’t expecting using run or call:<inlinemediaobject>
              <imageobject>
                <imagedata fileref="media/image120.png" width="3.9375in" depth="0.38889in" />
              </imageobject>
            </inlinemediaobject>
          </para>
          <para>
            In order to use a block as an input this way, you must
            explicitly put a ring around it, by right-clicking on it and
            choosing ringify. More about rings in Chapter VI.
          </para>
        </footnote>
      </para>
    </section>
    <section xml:id="visible-stepping">
      <title>Visible stepping</title>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image121.png" width="0.29167in" depth="0.16667in" />
          </imageobject>
        </inlinemediaobject><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image122.png" width="0.54563in" depth="0.15278in" />
          </imageobject>
        </inlinemediaobject><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image123.png" width="0.29167in" depth="0.16667in" />
          </imageobject>
        </inlinemediaobject>Sometimes you’re not exactly sure where the
        error is, or you don’t understand how the program got there. To
        understand better, you’d like to watch the program as it runs,
        at human speed rather than at computer speed. You can do this by
        clicking the <emphasis>visible stepping button</emphasis> ( ),
        before running a script or while the script is paused. The
        button will light up ( ) and a speed control slider will appear
        in the toolbar. When you start or continue the script, its
        blocks and input slots will light up cyan one at a time:
      </para>
      <para>
        In this simple example, the inputs to the blocks are constant
        values, but if an input were a more complicated expression
        involving several reporter blocks, each of those would light up
        as they are called. Note that the input to a block is evaluated
        before the block itself is called, so, for example, the 100
        lights up before the move.
      </para>
      <para>
        <emphasis role="strong">. . .</emphasis>
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image134.png" width="0.29167in" depth="0.16667in" />
          </imageobject>
        </inlinemediaobject>The speed of stepping is controlled by the
        slider. If you move the slider all the way to the left, the
        speed is zero, the pause button turns into a step button , and
        the script takes a single step each time you push it. The name
        for this is <emphasis>single stepping.</emphasis>
      </para>
      <para>
        If several scripts that are visible in the scripting area are
        running at the same time, all of them are stepped in parallel.
        However, consider the case of two repeat loops with different
        numbers of blocks. While not stepping, each script goes through
        a complete cycle of its loop in each display cycle, despite the
        difference in the length of a cycle. In order to ensure that the
        visible result of a program on the stage is the same when
        stepped as when not stepped, the shorter script will wait at the
        bottom of its loop for the longer script to catch up.
      </para>
      <para>
        When we talk about custom blocks in Chapter III, we’ll have more
        to say about visible stepping as it affects those blocks.
      </para>
    </section>
  </section>
  <section xml:id="etcetera">
    <title>Etcetera</title>
    <para>
      This manual doesn’t explain every block in detail. There are many
      more motion blocks, sound blocks, costume and graphics effects
      blocks, and so on. You can learn what they all do by
      experimentation, and also by reading the “help screens” that you
      can get by right-clicking or control-clicking a block and
      selecting “help…” from the menu that appears. If you forget what
      palette (color) a block is, but you remember at least part of its
      name, type control-F and enter the name in the text block that
      appears in the palette area.
    </para>
    <para>
      Here are the primitive blocks that don’t exist in Scratch:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image135.png" width="1.25in" depth="0.22917in" />
        </imageobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image136.png" width="1.05208in" depth="0.22917in" />
        </imageobject>
      </inlinemediaobject> reports a new costume consisting of
      everything that’s drawn on the stage by any sprite. Right-clicking
      the block in the scripting area gives the option to change it to
      if vector logging is enabled. See page
      <link linkend="logpenvectors">116</link>.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image137.png" width="2.08333in" depth="0.375in" />
        </imageobject>
      </inlinemediaobject>Print characters in the given point size on
      the stage, at the sprite’s position and in its direction. The
      sprite moves to the end of the text. (That’s not always what you
      want, but you can save the sprite’s position before using it, and
      sometimes you need to know how big the text turned out to be, in
      turtle steps.) If the pen is down, the text will be underlined.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image138.png" width="1.20069in" depth="0.51389in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:paste-on.png</phrase>
        </textobject>
      </inlinemediaobject>Takes a sprite as input. Like stamp except
      that the costume is stamped onto the selected sprite instead of
      onto the stage. (Does nothing if the current sprite doesn’t
      overlap the chosen sprite.)
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image139.png" width="1.19167in" depth="0.33889in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:cut-from.png</phrase>
        </textobject>
      </inlinemediaobject>Takes a sprite as input. Erases from that
      sprite’s costume the area that overlaps with the current sprite’s
      costume. (Does not affect the costume in the chosen sprite’s
      wardrobe, only the copy currently visible.)
    </para>
    <para>
      Runs only this script
    </para>
    <para>
      until finished. In the Control palette even though it’s gray.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image140.png" width="0.52986in" depth="0.5in" />
        </imageobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image141.png" width="0.98958in" depth="0.25972in" />
        </imageobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image142.png" width="1.32986in" depth="0.42986in" />
        </imageobject>
        <textobject>
          <phrase>Icon Description automatically generated</phrase>
        </textobject>
      </inlinemediaobject> See page
      <link linkend="generic_when">6</link>. See page
      <link linkend="pause_all">17</link>.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image143.png" width="1.71in" depth="0.23in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:pix:reporter-if.png</phrase>
        </textobject>
      </inlinemediaobject>Reporter version of the if/else primitive
      command block. Only one of the two branches is evaluated,
      depending on the value of the first input.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image144.png" width="1.83in" depth="0.61in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:pix:for.png</phrase>
        </textobject>
      </inlinemediaobject>Looping block like repeat but with an index
      variable.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image145.png" width="1.37986in" depth="0.28958in" />
        </imageobject>
        <textobject>
          <phrase>Graphical user interface, application, logo Description automatically generated</phrase>
        </textobject>
      </inlinemediaobject>Declare local variables in a script.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image146.png" width="0.86in" depth="0.19in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:report-effect.png</phrase>
        </textobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image147.png" width="0.72in" depth="0.2in" />
        </imageobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image148.png" width="1.17in" depth="0.18in" />
        </imageobject>
      </inlinemediaobject> See page <link linkend="url">91</link>.
    </para>
    <para>
      reports the value of a graphics effect.
    </para>
    <para>
      Constant true or false value. See page
      <link linkend="predicates-and-conditional-evaluation">12</link>.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image153.png" width="2.13in" depth="0.18in" />
        </imageobject>
      </inlinemediaobject> Create a primitive using JavaScript. (This
      block is disabled by default; the user must check “Javascript
      extensions” in the setting menu <emphasis>each time</emphasis> a
      project is loaded.)
    </para>
    <para>
      The at block lets you examine the screen pixel directly behind the
      rotation center of a sprite, the mouse, or an arbitrary (x,y)
      coordinate pair dropped onto the second menu slot. The first five
      items of the left menu let you examine the color visible at the
      position. (The “RGBA” option reports a list.) The “sprites” option
      reports a list of all sprites, including this one, any point of
      which overlaps this sprite’s rotation center (behind or in front).
      This is a hyperblock with respect to its second input.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image162.png" width="2.44583in" depth="1.32639in" />
        </imageobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image163.png" width="2.35556in" depth="0.38889in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:set-on.png</phrase>
        </textobject>
      </inlinemediaobject> Checks the data type of a value.
    </para>
    <para>
      <emphasis role="strong">Blocks only for the Stage:</emphasis>
    </para>
    <para>
      Get or set selected global flags.
    </para>
    <para>
      Turn the text into a list, using the second input as the delimiter
      between items. The default delimiter, indicated by the brown dot
      in the input slot, is a single space character. “Letter” puts each
      character of the text in its own list item. “Word” puts each word
      in an item. (Words are separated by any number of consecutive
      space, tab, carriage return, or newline characters.) “Line” is a
      newline character (0xa); “tab” is a tab character (0x9); “cr” is a
      carriage return (0xd). “Csv” and “json” split formatted text into
      lists of lists; see page
      <link linkend="comma-separated-values">54</link>. “Blocks” takes a
      script as the first input, reporting a list structure representing
      the structure of the script. See Chapter XI.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image170.png" width="1.47986in" depth="0.18958in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:identical.png</phrase>
        </textobject>
      </inlinemediaobject>For lists, reports true only if its two input
      values are the very same list, so changing an item in one of them
      is visible in the other. (For =, lists that look the same are the
      same.) For text strings, uses case-sensitive comparison, unlike =,
      which is case-independent.
    </para>
    <para>
      These <emphasis>hidden</emphasis> blocks can be found with the
      relabel option of any dyadic arithmetic block. They’re hidden
      partly because writing them in Snap<emphasis>!</emphasis> is a
      good, pretty easy programming exercise. Note: the two inputs to
      atan2 are Δ<emphasis>x</emphasis> and Δ<emphasis>y</emphasis> in
      that order, because we measure angles clockwise from north. Max
      and min are <emphasis>variadic;</emphasis> by clicking the
      arrowhead, you can provide additional inputs.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image177.png" width="0.63in" depth="0.19in" />
        </imageobject>
        <textobject>
          <phrase>Logo Description automatically generated with medium confidence</phrase>
        </textobject>
      </inlinemediaobject> <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image178.png" width="0.63in" depth="0.19in" />
        </imageobject>
        <textobject>
          <phrase>A picture containing text, monitor, screenshot Description automatically generated</phrase>
        </textobject>
      </inlinemediaobject> <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image179.png" width="0.63in" depth="0.19in" />
        </imageobject>
        <textobject>
          <phrase>Logo Description automatically generated</phrase>
        </textobject>
      </inlinemediaobject> Similarly, these hidden predicates can be
      found by relabeling the relational predicates.
    </para>
    <para>
      <emphasis role="strong">Metaprogramming (see Chapter
      XI.</emphasis> <emphasis role="strong">, page
      <link linkend="metaprogramming">101</link>)</emphasis>
    </para>
    <para>
      These blocks support <emphasis>metaprogramming,</emphasis> which
      means manipulating blocks and scripts as data. This is not the
      same as manipulating procedures (see Chapter VI. ), which are what
      the blocks <emphasis>mean;</emphasis> in metaprogramming the
      actual blocks, what you see on the screen, are the data. This
      capability is new in version 8.0.
    </para>
    <para>
      <emphasis role="strong">First class list blocks (see Chapter IV,
      page <link linkend="first-class-lists">46</link>):</emphasis>
    </para>
    <para>
      Numbers from will count up or down.
    </para>
    <para>
      The script input to for each can refer to an
    </para>
    <para>
      item of the list with the item variable.
    </para>
<literallayout><emphasis role="strong">
</emphasis><inlinemediaobject>
<imageobject>
<imagedata fileref="media/image224.png" width="0.83in" depth="0.21in" />
</imageobject>
</inlinemediaobject> <inlinemediaobject>
<imageobject>
<imagedata fileref="media/image225.png" width="1.43in" depth="0.21in" />
</imageobject>
</inlinemediaobject> report the sprite or mouse position as a two-item vector (x,y).</literallayout>
    <para>
      <emphasis role="strong">First class procedure blocks (see Chapter
      VI, page <link linkend="procedures-as-data">65</link>):</emphasis>
    </para>
    <para>
      <emphasis role="strong">First class continuation blocks (see
      Chapter X, page
      <link linkend="continuations">93</link>):</emphasis>
    </para>
    <para>
      <emphasis role="strong">First class sprite, costume, and sound
      blocks (see Chapter VII, page
      <link linkend="object-oriented-programming-with-sprites">73</link>):</emphasis>
    </para>
    <para>
      Object is a hyperblock.
    </para>
    <para>
      <emphasis role="strong">Scenes:</emphasis>
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image280.png" width="2.38in" depth="1.32in" />
        </imageobject>
      </inlinemediaobject>The major new feature of version 7.0 is
      <emphasis>scenes:</emphasis> A project can include within it
      sub-projects, called scenes, each with its own stage, sprites,
      scripts, and so on. This block makes another scene active,
      replacing the current one.
    </para>
    <para>
      Nothing is automatically shared between scenes: no sprites, no
      blocks, no variables. But the old scene can send a message to the
      new one, to start it running, with optional payload as in
      broadcast (page <link linkend="broadcast">23</link>).
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image281.png" width="2.54in" depth="0.31in" />
        </imageobject>
      </inlinemediaobject>In particular, you can say
    </para>
    <blockquote>
      <para>
        if the new scene expects to be started with a green flag signal.
      </para>
    </blockquote>
<literallayout><emphasis role="strong">
These aren’t new blocks but they have a new feature:</emphasis></literallayout>
    <para>
      These accept two-item (x,y) lists as input, and have extended
      menus (also including other sprites):
    </para>
    <para>
      “Center” means the center of the stage, the point at (0,0).
      “Direction” is in the point in direction sense, the direction that
      would leave this sprite pointing toward another sprite, the mouse,
      or the center. “Ray length” is the distance from the center of
      this sprite to the nearest point on the other sprite, in the
      current direction.
    </para>
    <para>
      The stop block has two extra menu choices. Stop this block is used
      inside the definition of a custom block to stop just this
      invocation of this custom block and continue the script that
      called it. Stop all but this script is good at the end of a game
      to stop all the game pieces from moving around, but keep running
      this script to provide the user’s final score. The last two menu
      choices add a tab at the bottom of the block because the current
      script can continue after it.
    </para>
    <para>
      The new “pen trails” option is true if the sprite is touching any
      drawn or stamped ink on the stage. Also, touching will not detect
      hidden sprites, but a hidden sprite can use it to detect visible
      sprites.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image304.png" width="1.05972in" depth="0.27986in" />
        </imageobject>
        <textobject>
          <phrase>Icon Description automatically generated</phrase>
        </textobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image305.png" width="2.43333in" depth="0.3in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:video-on.png</phrase>
        </textobject>
      </inlinemediaobject>The video block has a snap option that takes a
      snapshot and reports it as a costume. It is hyperized with
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image306.png" width="1.05208in" depth="0.28125in" />
        </imageobject>
      </inlinemediaobject>respect to its second input.
    </para>
    <para>
      The “neg” option is a monadic negation operator, equivalent to .
      “lg” is log<subscript>2</subscript>. “id” is the identity
      function, which reports its input. “sign” reports 1 for positive
      input, 0 for zero input, or -1 for negative input.
    </para>
    <para>
      name changed to clarify that it’s different from
    </para>
    <para>
      + and × are <emphasis>variadic:</emphasis> they take two or more
      inputs. If you drop a list on the arrowheads, the block name
      changes to sum or product.
    </para>
    <para>
      I
    </para>
    <para>
      Extended mouse interaction events, sensing clicking, dragging,
      hovering, etc. The “stopped” option triggers when all scripts are
      stopped, as with the stop button; it is useful for robots whose
      hardware interface must be told to turn off motors. A when I am
      stopped script can run only for a limited time.
    </para>
    <para>
      <anchor xml:id="broadcast" />Extended broadcast: Click the right
      arrowhead to direct the message to a single sprite or the stage.
      Click again to add any value as a payload to the message.
    </para>
    <para>
      Extended when I receive: Click the right arrowhead to expose a
      script variable (click on it to change its name, like any script
      variable) that will be set to the data of a matching broadcast. If
      the first input is set to “any message,” then the data variable
      will be set to the message, if no payload is included with the
      broadcast, or to a two-item list containing the message and the
      payload.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image355.png" width="1.68in" depth="0.38in" />
        </imageobject>
        <textobject>
          <phrase>A picture containing text, clipart Description automatically generated</phrase>
        </textobject>
      </inlinemediaobject> If the input is set to “any key,” then a
      right arrowhead appears:
    </para>
    <blockquote>
<literallayout><inlinemediaobject>
<imageobject>
<imagedata fileref="media/image356.png" width="2.25in" depth="0.41944in" />
</imageobject>
<textobject>
<phrase>Website Description automatically generated with medium confidence</phrase>
</textobject>
</inlinemediaobject><inlinemediaobject>
<imageobject>
<imagedata fileref="media/image357.png" width="1.81944in" depth="0.37986in" />
</imageobject>
<textobject>
<phrase>Logo Description automatically generated</phrase>
</textobject>
</inlinemediaobject>and if you click it, a script variable key is created whose value is the key that was pressed. (If the key is one that’ represented in the input menu by a word or phrase, e.g., “enter” or “up arrow,” then the value of key will be that word or phrase, <emphasis>except for</emphasis> the space character, which is represented as itself in key.)
<anchor xml:id="ask_lists" /></literallayout>
    </blockquote>
    <para>
      The RGB(A) option accepts a single number, which is a grayscale
      value 0-255; a two-number list, grayscale plus opacity 0-255; a
      three-item RGB list, or a four-item RGBA list.
    </para>
    <para>
      These ask features and more in the Menus library.
    </para>
    <para>
      The of block has an extended menu of attributes of a sprite.
      Position reports an (x,y) vector. Size reports the percentage of
      normal size, as controlled by the set size block in the Looks
      category. Left, right, etc. report the stage coordinates of the
      corresponding edge of the sprite’s bounding box. Variables reports
      a list of the names of all variables in scope (global,
      sprite-local, and script variables if the right input is a script.
    </para>
  </section>
  <section xml:id="libraries">
    <title>
    Libraries</title>
    <para>
      <anchor xml:id="libraries-1" /><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image384.png" width="0.31944in" depth="0.18056in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:real-desktop:Everything Snap:manual:filebutton.png</phrase>
        </textobject>
      </inlinemediaobject>There are several collections of useful
      procedures that aren’t Snap<emphasis>!</emphasis> primitives, but
      are provided as libraries. To include a library in your project,
      choose the Libraries… option in the file ( ) menu.
    </para>
    <para>
      The library menu is divided into five broad categories. The first
      is, broadly, utilities: blocks that might well be primitives. They
      might be useful in all kinds of projects.
    </para>
    <para>
      The second category is blocks related to media computation: ones
      that help in dealing with costumes and sounds (a/k/a Jens
      libraries). There is some overlap with “big data” libraries, for
      dealing with large lists of lists.
    </para>
    <para>
      The third category is, roughly, specific to non-media applications
      (a/k/a Brian libraries). Three of them are imports from other
      programming languages: words and sentences from Logo, array
      functions from APL, and streams from Scheme. Most of the others
      are to meet the needs of the BJC curriculum.
    </para>
    <para>
      The fourth category is major packages (extensions) provided by
      users.
    </para>
    <para>
      The fifth category provides support for hardware devices such as
      robots, through general interfaces, replacing specific hardware
      libraries in versions before 7.0.
    </para>
    <para>
      When you click on the one-line description of a library, you are
      shown the actual blocks in the library and a longer explanation of
      its purpose. You can browse the libraries to find one that will
      satisfy your needs.
    </para>
    <para>
      The libraries and their contents may change, but as of this
      writing the list library has these blocks:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image387.png" width="1.84861in" depth="2.49236in" />
        </imageobject>
      </inlinemediaobject> (The lightning bolt before the name in
      several of these blocks means that they use compiled HOFs or
      JavaScript primitives to achieve optimal speed. They are
      officially considered experimental.) Remove duplicates from
      reports a list in which no two items are equal. The sort block
      takes a list and a two-input comparison predicate, such as &lt;,
      and reports a list with the items sorted according to that
      comparison. The assoc block is for looking up a key in an
      <emphasis>association list:</emphasis> a list of two-item lists.
      In each two-item list, the first is a <emphasis>key</emphasis> and
      the second is a <emphasis>value.</emphasis> The inputs are a key
      and an association list; the block reports the first key-value
      pair whose key is equal to the input key.
    </para>
    <para>
      For each item is a variant of the primitive version that provides
      a # variable containing the position in the input list of the
      currently considered item. Multimap is a version of map that
      allows multiple list inputs, in which case the mapping function
      must take as many inputs as there are lists; it will be called
      with all the first items, all the second items, and so on. Zip
      takes any number of lists as inputs; it reports a list of lists:
      all the first items, all the second items, and so on. The no-name
      identity function reports its input.
    </para>
    <para>
      Sentence and sentence➔list are borrowed from the word and sentence
      library (page <link linkend="wordsent">27</link>) to serve as a
      variant of append that accepts non-lists as inputs. Printable
      takes a list structure of any depth as input and reports a compact
      representation of the list as a text string.
    </para>
    <para>
      The iteration, composition library has these blocks:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image388.png" width="1.68889in" depth="4.75in" />
        </imageobject>
      </inlinemediaobject>Catch and throw provide a nonlocal exit
      facility. You can drag the tag from a catch block to a throw
      inside its C-slot, and the throw will then jump directly out to
      the matching catch without doing anything in between.
    </para>
    <para>
      If do and pause all is for setting a breakpoint while debugging
      code. The idea is to put show variable blocks for local variables
      in the C-slot; the watchers will be deleted when the user
      continues from the pause.
    </para>
    <para>
      Ignore is used when you need to call a reporter but you don’t care
      about the value it reports. (For example, you are writing a script
      to time how long the reporter takes.)
    </para>
    <para>
      The cascade blocks take an initial value and call a function
      repeatedly on that value,
      <emphasis>f</emphasis>(<emphasis>f</emphasis>(<emphasis>f</emphasis>(<emphasis>f</emphasis>…(<emphasis>x</emphasis>)))).
    </para>
    <para>
      The compose block takes two functions and reports the function
      <emphasis>f</emphasis>(<emphasis>g</emphasis>(<emphasis>x</emphasis>)).
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image389.png" width="1.04444in" depth="0.16111in" />
        </imageobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image390.png" width="3.15278in" depth="0.29861in" />
        </imageobject>
      </inlinemediaobject>The first three repeat blocks are variants of
      the primitive repeat until block, giving all four combinations of
      whether the first test happens before or after the first
      repetition, and whether the condition must be true or false to
      continue repeating. The last repeat block is like the repeat
      primitive, but makes the number of repetitions so far available to
      the repeated script. The next two blocks are variations on for:
      the first allows an explicit step instead of using ±1, and the
      second allows any values, not just numbers; inside the script you
      say
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image391.png" width="3.44097in" depth="1.36111in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:untitled script pic (2).png</phrase>
        </textobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image392.png" width="3.70972in" depth="1.17153in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:untitled script pic (1).png</phrase>
        </textobject>
      </inlinemediaobject>replacing the grey block in the picture with
      an expression to give the next desired value for the loop index.
      Pipe allows reordering a nested composition with a left-to-right
      one:
    </para>
    <para>
      The stream library has these blocks:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image393.png" width="3.16111in" depth="2.15347in" />
        </imageobject>
      </inlinemediaobject><emphasis>Streams</emphasis> are a special
      kind of list whose items are not computed until they are needed.
      This makes certain computations more efficient, and also allows
      the creation of lists with infinitely many items, such as a list
      of all the positive integers. The first five blocks are stream
      versions of the list blocks in front of, item 1 of, all but first
      of, map, and keep. Show stream takes a stream and a number as
      inputs, and reports an ordinary list of the first
      <emphasis>n</emphasis> items of the stream. Stream is like the
      primitive list; it makes a finite stream from explicit items.
      Sieve is an example block that takes as input the stream of
      integers starting with 2 and reports the stream of all the prime
      numbers. Stream with numbers from is like the numbers from block
      for lists, except that there is no endpoint; it reports an
      infinite stream of numbers.
    </para>
    <para>
      The <anchor xml:id="wordsent" />word and sentence library has
      these blocks:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image394.png" width="1.67986in" depth="3.64306in" />
        </imageobject>
      </inlinemediaobject>This library has the goal of recreating the
      Logo approach to handling text: A text isn’t best viewed as a
      string of characters, but rather as a
      <emphasis>sentence</emphasis>, made of <emphasis>words,</emphasis>
      each of which is a string of <emphasis>letters.</emphasis> With a
      few specialized exceptions, this is why people put text into
      computers: The text is sentences of natural (i.e., human)
      language, and the emphasis is on words as constitutive of
      sentences. You barely notice the letters of the words, and you
      don’t notice the spaces between them at all, unless you’re
      proof-reading. (Even then: Proofreading is
      <emphasis>diffciult,</emphasis> because you see what you expect to
      see, what will make the snetence make sense, rather than the
      misspelling in front of of your eyes.) Internally, Logo stores a
      sentence as a list of words, and a word as a string of letters.
    </para>
    <para>
      Inexplicably, the designers of Scratch chose to abandon that
      tradition, and to focus on the representation of text as a string
      of characters. The one vestige of the Logo tradition from which
      Scratch developed is the block named letter (1) of (world), rather
      than character (1) of (world). Snap<emphasis>!</emphasis> inherits
      its text handling from Scratch.
    </para>
    <para>
      In Logo, the visual representation of a sentence (a list of words)
      looks like a natural language sentence: a string of words with
      spaces between them. In Snap<emphasis>!</emphasis>, the visual
      representation of a list looks nothing at all like natural
      language. On the other hand, representing a sentence as a string
      means that the program must continually re-parse the text on every
      operation, looking for spaces, treating multiple consecutive
      spaces as one, and so on. Also, it’s more convenient to treat a
      sentence as a list of words rather than a string of words because
      in the former case you can use the higher order functions map,
      keep, and combine on them. This library attempts to be agnostic as
      to the internal representation of sentences. The sentence
      selectors accept any combination of lists and strings; there are
      two sentence constructors, one to make a string (join words) and
      one to make a list (sentence).
    </para>
    <para>
      The selector names come from Logo, and should be self-explanatory.
      However, because in a block language you don’t have to type the
      block name, instead of the terse butfirst or the cryptic bf we
      spell out “all but first of” and include “word” or “sentence” to
      indicate the intended domain. There’s no first letter of block
      because letter 1 of serves that need. Join words (the
      sentence-as-string constructor) is like the primitive join except
      that it puts a space in the reported value between each of the
      inputs. Sentence (the List-colored sentence-as-list constructor)
      accepts any number of inputs, which can be words,
      sentences-as-lists, or sentences-as-strings. (If inputs are lists
      of lists, only one level of flattening is done.) Sentence reports
      a list of words; there will be no empty words or words containing
      spaces. The four blocks with right-arrows in their names convert
      back and forth between text strings (words or sentences) and
      lists. (Splitting a word into a list of letters is unusual unless
      you’re a linguist investigating orthography.) Printable takes a
      list (including a deep list) of words as input and reports a text
      string in which parentheses are used to show the structure, as in
      Lisp/Scheme.
    </para>
    <para>
      The pixels library has one block:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image395.png" width="0.77917in" depth="0.62986in" />
        </imageobject>
      </inlinemediaobject>Costumes are first class data in
      Snap<emphasis>!</emphasis>. Most of the processing of costume data
      is done by primitive blocks in the Looks category. (See page
      <link linkend="media-computation-with-costumes">79</link>.) This
      library provides snap, which takes a picture using your computer’s
      camera and reports it as a costume.
    </para>
    <para>
      The bar charts library has these blocks:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image396.png" width="3.43056in" depth="1.91667in" />
        </imageobject>
      </inlinemediaobject>Bar chart takes a table (typically from a CSV
      data set) as input and reports a summary of the table grouped by
      the field in the specified column number. The remaining three
      inputs are used only if the field values are numbers, in which
      case they can be grouped into buckets (e.g., decades, centuries,
      etc.). Those inputs specify the smallest and largest values of
      interest and, most importantly, the width of a bucket (10 for
      decades, 100 for centuries). If the field isn't numeric, leave
      these three inputs empty or set them to zero. Each string value of
      the field is its own bucket, and they appear sorted
      alphabetically.
    </para>
    <para>
      Bar chart reports a new table with three columns. The first column
      contains the bucket name or smallest number. The second column
      contains a nonnegative integer that says how many records in the
      input table fall into this bucket. The third column is a subtable
      containing the actual records from the original table that fall
      into the bucket. Plot bar chart takes the table reported by bar
      chart and graphs it on the stage, with axes labelled
      appropriately. The remaining blocks are helpers for those.
    </para>
    <para>
      If your buckets aren't of constant width, or you want to group by
      some function of more than one field, load the &quot;Frequency
      Distribution Analysis&quot; library instead.
    </para>
    <para>
      The multi-branched conditional library has these blocks:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image397.png" width="1.85in" depth="2.47986in" />
        </imageobject>
      </inlinemediaobject>The catch and throw blocks duplicate ones in
      the iteration library, and are included because they are used to
      implement the others. The cases block sets up a multi-branch
      conditional, similar to cond in Lisp or switch in C-family
      languages. The first branch is built into the cases block; it
      consists of a Boolean test in the first hexagonal slot and an
      action script, in the C-slot, to be run if the test reports true.
      The remaining branches go in the variadic hexagonal input at the
      end; each branch consists of an else if block, which includes the
      Boolean test and the corresponding action script, except possibly
      for the last branch, which can use the unconditional else block.
      As in other languages, once a branch succeeds, no other branches
      are tested.
    </para>
    <section xml:id="section-1">
      <title></title>
      <para>
        The variadic library has these blocks:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image398.png" width="1.19653in" depth="0.41667in" />
          </imageobject>
        </inlinemediaobject>These are versions of the associative
        operators and, and or that take any number of inputs instead of
        exactly two inputs. As with any variadic input, you can also
        drop a list of values onto the arrowheads instead of providing
        the inputs one at a time As of version 8.0, the arithmetic
        operators sum, product, minimum, and maximum are no longer
        included, because the primitive operators +. ×, min, and max are
        themselves variadic.
      </para>
      <para>
        The colors and crayons library has these blocks:
      </para>
      <para>
        It is intended as a more powerful replacement for the primitive
        set pen block, including <emphasis>first class color</emphasis>
        support; HSL color specification as a better alternative to the
        HSV that Snap<emphasis>!</emphasis> inherits from JavaScript; a
        “fair hue” scale that compensates for the eye’s grouping a wide
        range of light frequencies as green while labelling mere slivers
        as orange or yellow; the X11/W3C standard color names; RGB in
        hexadecimal; a linear color scale (as in the old days, but
        better) based on fair hues and including shades (darker colors)
        and grayscale. Another linear scale is a curated set of 100
        “crayons,” explained further on the next page.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image413.png" width="1.13333in" depth="0.23333in" />
          </imageobject>
          <textobject>
            <phrase>Macintosh HD:Users:bh:Desktop:pen-color.png</phrase>
          </textobject>
        </inlinemediaobject><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image414.png" width="0.95in" depth="0.225in" />
          </imageobject>
          <textobject>
            <phrase>Macintosh HD:Users:bh:Desktop:color picker.png</phrase>
          </textobject>
        </inlinemediaobject>Colors are created by the block (for direct
        user selection), the color from block to specify a color
        numerically, or by , which reports the color currently in use by
        the pen. The from color block reports names or numbers
        associated with a color:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image415.png" width="4.83333in" depth="0.43056in" />
          </imageobject>
        </inlinemediaobject>Colors can be created from other colors:
      </para>
      <para>
        The three blocks with pen in their names are improved versions
        of primitive Pen blocks. In principle set pen, for example,
        could be implemented using a (hypothetical) set pen to color
        composed with the color from block, but in fact set pen benefits
        from knowing how the pen color was set in its previous
        invocation, so it’s implemented separately from color from.
        Details in Appendix A.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image416.png" width="7.5in" depth="0.25in" />
          </imageobject>
        </inlinemediaobject>The recommended way to choose a color is
        from one of two linear scales: the continuous <emphasis>color
        numbers</emphasis> and the discrete
        <emphasis>crayons:</emphasis>
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image417.png" width="7.5in" depth="0.25in" />
          </imageobject>
        </inlinemediaobject>
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image418.png" width="4in" depth="0.20833in" />
          </imageobject>
        </inlinemediaobject>Color numbers are based on <emphasis>fair
        hues,</emphasis> a modification of the spectrum (rainbow) hue
        scale that devotes less space to green and more to orange and
        yellow, as well as promoting brown to a real color. Here is the
        normal hue scale, for reference:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image419.png" width="4in" depth="0.20833in" />
          </imageobject>
        </inlinemediaobject>Here is the fair hue scale:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image416.png" width="5in" depth="0.20833in" />
          </imageobject>
        </inlinemediaobject>Here is the color number scale:
      </para>
      <para>
        (The picture is wider so that pure spectral colors line up with
        the fair hue scale.)
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image417.png" width="5in" depth="0.20833in" />
          </imageobject>
        </inlinemediaobject>And here are the 100 crayons:
      </para>
      <para>
        The color from block, for example, provides different pulldown
        menus depending on which scale you choose:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image420.png" width="2.41667in" depth="0.34444in" />
          </imageobject>
          <textobject>
            <phrase>Macintosh HD:Users:bh:Desktop:color-by-name.png</phrase>
          </textobject>
        </inlinemediaobject>You can also type the crayon name: There are
        many scales:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image427.png" width="4.29167in" depth="1.90972in" />
          </imageobject>
        </inlinemediaobject>
      </para>
      <para>
        The white slot at the end of some of the blocks has two
        purposes. It can be used to add a transparency to a color
        (0=opaque, 100=transparent):
      </para>
      <para>
        or it can be expanded to enter three or four numbers for a
        vector directly into the block, so these are equivalent:
      </para>
      <para>
        But note that a transparency number in a four-number RGBA vector
        is on the scale 255=opaque, 0=transparent, so the following are
        <emphasis>not</emphasis> equivalent:
      </para>
      <para>
        Set pen crayon to provides the equivalent of a box of 100
        crayons. They are divided into color groups, so the menu in the
        set pen crayon to input slot has submenus. The colors are chosen
        so that starting <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image440.png" width="4.36528in" depth="0.51528in" />
          </imageobject>
          <textobject>
            <phrase>Macintosh HD:Users:bh:Desktop:pix:10-crayons.png</phrase>
          </textobject>
        </inlinemediaobject>from crayon 0, change pen crayon by 10
        rotates through an interesting, basic set of ten colors:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image441.png" width="4.35556in" depth="0.28194in" />
          </imageobject>
        </inlinemediaobject>Using change pen crayon by 5 instead gives
        ten more colors, for a total of 20:
      </para>
      <para>
        (Why didn’t we use the colors of the 100-crayon Crayola™ box? A
        few reasons, one of which is that some Crayola colors aren’t
        representable on RGB screens. Some year when you have nothing
        else to do, look up “color space” on Wikipedia. Also “crayon.”
        Oh, it’s deliberate that change pen crayon by 5 doesn’t include
        white, since that’s the usual stage background color. White is
        crayon 14.) Note that crayon 43 is “Variables”; all the standard
        block colors are included.
      </para>
      <para>
        See Appendix A (page
        <link linkend="crayons-and-color-numbers">139</link>) for more
        information.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image442.png" width="1.51in" depth="0.9in" />
          </imageobject>
          <textobject>
            <phrase>Graphical user interface, text, application, chat or text message Description automatically generated</phrase>
          </textobject>
        </inlinemediaobject>The <emphasis role="strong">crayon
        library</emphasis> has only the crayon features, without the
        rest of the colors package.
      </para>
      <para>
        The catch errors library has these blocks:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image443.png" width="0.43056in" depth="0.15278in" />
          </imageobject>
        </inlinemediaobject><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image444.png" width="3.04167in" depth="1.39583in" />
          </imageobject>
        </inlinemediaobject>The safely try block allows you to handle
        errors that happen when your program is run within the program,
        instead of stopping the script with a red halo and an obscure
        error message. The block runs the script in its first C-slot. If
        it finishes without an error, nothing else happens. But if an
        error happens, the code in the second C-slot is run. While that
        second script is running, the variable contains the text of the
        error message that would have been displayed if you weren’t
        catching the error. The error block is sort of the opposite: it
        lets your program <emphasis>generate</emphasis> an error
        message, which will be displayed with a red halo unless it is
        caught by safely try. Safely try reporting is the reporter
        version of safely try.
      </para>
      <para>
        The text costumes library has only two blocks:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image445.png" width="0.53472in" depth="0.20833in" />
          </imageobject>
          <textobject>
            <phrase>Macintosh HD:Users:bh:Desktop:Snaplabel.png</phrase>
          </textobject>
        </inlinemediaobject><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image446.png" width="1.92in" depth="0.45078in" />
          </imageobject>
          <textobject>
            <phrase>Macintosh HD:Users:bh:Desktop:textcostume.png</phrase>
          </textobject>
        </inlinemediaobject>Costume from text reports a costume that can
        be used with the switch to <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image447.png" width="3.25972in" depth="0.18958in" />
          </imageobject>
        </inlinemediaobject>costume block to make a button:
      </para>
      <para>
        Costume with background reports a costume made from another
        costume by coloring its background, taking a color input like
        the set pen color to RGB(A) block and a number of turtle steps
        of padding around the original costume. These two blocks work
        together to make even better buttons:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image448.png" width="5.51in" depth="0.68in" />
          </imageobject>
        </inlinemediaobject>
      </para>
      <para>
        The text to speech library has these blocks:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image449.png" width="2.275in" depth="0.8in" />
          </imageobject>
          <textobject>
            <phrase>Macintosh HD:Users:bh:Desktop:speechlib.png</phrase>
          </textobject>
        </inlinemediaobject>This library interfaces with a capability in
        up-to-date browsers, so it might not work for you. It works best
        if the accent matches the text!
      </para>
      <para>
        The parallelization library contains these blocks:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image450.png" width="1.17986in" depth="1.25972in" />
          </imageobject>
        </inlinemediaobject>The two do in parallel blocks take any
        number of scripts as inputs. Those scripts will be run in
        parallel, like ordinary independent scripts in the scripting
        area. The and wait version waits until all of those scripts have
        finished before continuing the script below the block.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image451.png" width="1.37778in" depth="1.48333in" />
          </imageobject>
        </inlinemediaobject>The create variables library has these
        blocks:
      </para>
      <para>
        These blocks allow a program to perform the same operation as
        the
      </para>
      <para>
        button, making global, sprite local, or script variables, but
        allowing the program to compute the variable name(s). It can
        also set and find the values of these variables, show and hide
        their stage watchers, delete them, and find out if they already
        exist.
      </para>
      <para>
        The getters and setters library has these blocks:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image452.png" width="1.875in" depth="1.05in" />
          </imageobject>
        </inlinemediaobject><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image453.png" width="0.29167in" depth="0.16667in" />
          </imageobject>
        </inlinemediaobject>The purpose of this library is to allow
        program access to the settings controlled by user interface
        elements, such as the settings menu. The setting block reports a
        setting; the set flag block sets yes-or-no options that have
        checkboxes in the user interface, while the set value block
        controls settings with numeric or text values, such as project
        name.
      </para>
      <para>
        Certain settings are ordinarily remembered on a per-user basis,
        such as the “zoom blocks” value. But when these settings are
        changed by this library, the change is in effect only while the
        project using the library is loaded. No permanent changes are
        made. Note: this library has not been converted for version 7.0,
        so you’ll have to enable Javascript extensions to use it.
      </para>
      <para>
        The bignums, rationals, complex #s library has these blocks:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image454.png" width="1.875in" depth="1.55in" />
          </imageobject>
        </inlinemediaobject>The USE BIGNUMS block takes a Boolean input,
        to turn the infinite precision feature on or off. When on, all
        of the arithmetic operators are redefined to accept and report
        integers of any number of digits (limited only by the memory of
        your computer) and, in fact, the entire Scheme numeric tower,
        with exact rationals and with complex numbers. The Scheme number
        block has a list of functions applicable to Scheme numbers,
        including subtype predicates such as rational? and infinite?,
        and selectors such as numerator and real-part.
      </para>
      <para>
        The ! block computes the factorial function, useful to test
        whether bignums are turned on. Without bignums:
      </para>
      <para>
        With bignums:
      </para>
      <para>
        The 375-digit value of 200! isn’t readable on this page, but if
        you right-click on the block and choose “result pic,” you can
        open the resulting picture in a browser window and scroll
        through it. (These values end with a bunch of zero digits.
        That’s not roundoff error; the prime factors of 100! and 200!
        include many copies of 2 and 5.) The block with no name is a way
        to enter things like 3/4 and 4+7i into numeric input slots by
        converting the slot to Any type.
      </para>
      <para>
        The strings, multi-line input library provides these blocks:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image463.png" width="3.9375in" depth="2.04167in" />
          </imageobject>
        </inlinemediaobject>All of these could be written in
        Snap<emphasis>!</emphasis> itself, but these are implemented
        using the corresponding JavaScript library functions directly,
        so they run fast. They can be used, for example, in scraping
        data from a web site. The command use case-independent
        comparisons applies only to this library. The multiline block
        accepts and reports a text input that can include newline
        characters.
      </para>
      <para>
        The animation library has these blocks:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image464.png" width="4.0125in" depth="2.33125in" />
          </imageobject>
        </inlinemediaobject>Despite the name, this isn’t only about
        graphics; you can animate the values of a variable, or anything
        else that’s expressed numerically.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image465.png" width="0.96528in" depth="0.19444in" />
          </imageobject>
          <textobject>
            <phrase>Macintosh HD:Users:bh:Desktop:pix:easing.png</phrase>
          </textobject>
        </inlinemediaobject>The central idea of this library is an
        <emphasis>easing function,</emphasis> a reporter whose domain
        and range are real numbers between 0 and 1 inclusive. The
        function represents what fraction of the “distance” (in quotes
        because it might be any numeric value, such as temperature in a
        simulation of weather) from here to there should be covered in
        what fraction of the time. A linear easing function means steady
        progression. A quadratic easing function means starting slowly
        and accelerating. (Note that, since it’s a requirement that
        <emphasis>f</emphasis>(0)=0 and <emphasis>f</emphasis>(1)=1,
        there is only one linear easing function,
        <emphasis>f</emphasis>(<emphasis>x</emphasis>)=<emphasis>x</emphasis>,
        and similarly for other categories.) The block reports some of
        the common easing functions.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image466.png" width="4.63194in" depth="0.63194in" />
          </imageobject>
          <textobject>
            <phrase>Macintosh HD:Users:bh:Desktop:pix:animate-control.png</phrase>
          </textobject>
        </inlinemediaobject>The two Motion blocks in this library
        animate a sprite. Glide always animates the sprite’s motion.
        Animate’s first pulldown menu input allows you to animate
        horizontal or vertical motion, but will also animate the
        sprite’s direction or size. The animate block in Control lets
        you animate any numeric quantity with any easing function. The
        getter and setter inputs are best explained by example:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image467.png" width="3.40972in" depth="0.25694in" />
          </imageobject>
          <textobject>
            <phrase>Macintosh HD:Users:bh:Desktop:pix:animate-motion.png</phrase>
          </textobject>
        </inlinemediaobject>is equivalent to
      </para>
      <para>
        The other blocks in the library are helpers for these four.
      </para>
      <para>
        The serial ports library contains these blocks:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image468.png" width="1.73264in" depth="1.03472in" />
          </imageobject>
          <textobject>
            <phrase>Graphical user interface, text, application, chat or text message Description automatically generated</phrase>
          </textobject>
        </inlinemediaobject>It is used to allow hardware developers to
        control devices such as robots that are
      </para>
      <para>
        connected to your computer via a serial port.
      </para>
      <para>
        The frequency distribution analysis library has these blocks:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image469.png" width="4.02708in" depth="2.39583in" />
          </imageobject>
        </inlinemediaobject>
      </para>
      <para>
        This is a collection of tools for analyzing large data sets and
        plotting histograms of how often some value is found in some
        column of the table holding the data.
      </para>
      <para>
        For more information go here:
      </para>
      <para>
        https://tinyurl.com/jens-data
      </para>
      <para>
        The audio comp library includes these blocks:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image470.png" width="3.54167in" depth="2.98125in" />
          </imageobject>
        </inlinemediaobject>This library takes a sound, one that you
        record or one from our collection of sounds, and manipulates it
        by systematically changing the intensity of the samples in the
        sound and by changing the sampling rate at which the sound is
        reproduced. Many of the blocks are helpers for the plot sound
        block, used to plot the waveform of a sound. The play sound
        (primitive) block plays a sound. __ Hz for reports a sine wave
        as a list of samples.
      </para>
      <para>
        The web services library has these blocks:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image471.png" width="3.40972in" depth="1.10417in" />
          </imageobject>
          <textobject>
            <phrase>Graphical user interface, text, application, chat or text message Description automatically generated</phrase>
          </textobject>
        </inlinemediaobject>The first block is a generalization of the
        primitive url block, allowing more control over the various
        options in web requests: GET, POST, PUT, and DELETE, and fine
        control over the content of the message sent to the server.
        Current location reports your latitude and longitude. Listify
        takes some text in JSON format (see page
        <link linkend="multi-dimensional-lists-and-json">54</link>) and
        converts it to a structured list. Value at key looks up a
        key-value pair in a (listified) JSON dictionary. The key:value:
        block is just a constructor for an abstract data type used with
        the other blocks
      </para>
      <para>
        The database library contains these blocks:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image472.png" width="2.26389in" depth="1.22222in" />
          </imageobject>
          <textobject>
            <phrase>Graphical user interface, text, application, chat or text message Description automatically generated</phrase>
          </textobject>
        </inlinemediaobject>It is used to keep data that persist from
        one Snap<emphasis>!</emphasis> session to the next, if you use
        the same browser and the same login.
      </para>
      <para>
        The world map library has these blocks:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image473.png" width="2.44236in" depth="3.40278in" />
          </imageobject>
        </inlinemediaobject>Using any of the command blocks puts a map
        on the screen, in a layer in front of the stage’s background but
        behind the pen trails layer (which is in turn behind all the
        sprites). The first block asks your browser for your current
        physical location, for which you may be asked to give
        permission. The next two blocks get and set the map’s zoom
        amount; the default zoom of 10 ﬁts from San Francisco not quite
        down to Palo Alto on the screen. A zoom of 1 ﬁts almost the
        entire world. A zoom of 3 fits the United States; a zoom of 5
        ﬁts Germany. The zoom can be changed in half steps, i.e., 5.5 is
        different from 5, but 5.25 isn’t.
      </para>
      <para>
        The next five blocks convert between stage coordinates (pixels)
        and Earth coordinates (latitude and longitude). The change by x:
        y: block shifts the map relative to the stage. The distance to
        block measures the map distance (in meters) between two sprites.
        The three reporters with current in their names find
        <emphasis>your</emphasis> actual location, again supposing that
        geolocation is enabled on your device. Update redraws the map;
        as costume reports the visible section of the map as a costume.
        Set style allows things like satellite pictures.
      </para>
      <para>
        The APL primitives library contains these blocks:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image474.png" width="5.73333in" depth="1.11333in" />
          </imageobject>
        </inlinemediaobject>
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image475.png" width="6.45333in" depth="2.04in" />
          </imageobject>
        </inlinemediaobject>
      </para>
      <para>
        For more information about APL, see Appendix B (page
        <link linkend="appendix-b.-apl-features">148</link>).
      </para>
      <para>
        The <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image476.png" width="1.2in" depth="0.48958in" />
          </imageobject>
          <textobject>
            <phrase>Logo Description automatically generated</phrase>
          </textobject>
        </inlinemediaobject><emphasis role="strong">list comprehension
        library</emphasis> has one block, zip. Its first input is a
        function of two inputs. The two Any-type inputs are deep lists
        (lists of lists of…) interpreted as trees, and the function is
        called with every possible combination of a leaf node of the
        first tree and a leaf node of the second tree. But instead of
        taking atoms (non-lists) as the leaves, zip allows the leaves of
        each tree to be vectors (one-dimensional lists), matrices
        (two-dimensional lists), etc. The Number-type inputs specify the
        leaf dimension for each tree, so the function input might be
        called with a vector from the first tree and an atom from the
        second tree.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image477.png" width="0.89in" depth="1.51in" />
          </imageobject>
          <textobject>
            <phrase>Icon Description automatically generated</phrase>
          </textobject>
        </inlinemediaobject>The <emphasis role="strong">bitwise
        library</emphasis> provides bitwise logic functions; each bit of
        the reported value is the result of applying the corresponding
        Boolean function to the corresponding bits of the input(s). The
        Boolean functions are not for ¬, and for ∧, or for ∨, and xor
        (exclusive or) for ⊻. The remaining functions shift their first
        input left or right by the number of bits given by the second
        input. &lt;&lt; is left shift, &gt;&gt; is arithmetic right
        shift (shifting in one bits from the left), and &gt;&gt;&gt; is
        logical right shift (shifting in zero bits from the left). If
        you don’t already know what these mean, find a tutorial online.
      </para>
      <para>
        The <emphasis role="strong">MQTT library</emphasis> supports the
        Message Queuing Telemetry Transport protocol, for connecting
        with IOT devices. See
        <link xlink:href="https://mqtt.org/">https://mqtt.org/</link>
        for more information.
      </para>
      <para>
        The <emphasis role="strong">Signada library</emphasis> allows
        you to control a microBit or similar device that works with the
        Signada MicroBlocks project.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image486.png" width="3.39in" depth="1.9in" />
          </imageobject>
          <textobject>
            <phrase>Graphical user interface, text, application, chat or text message Description automatically generated</phrase>
          </textobject>
        </inlinemediaobject>
      </para>
      <para>
        The <emphasis role="strong">menus library</emphasis> provides
        the ability to display hierarchical menus on the stage, using
        the ask block’s ability to take lists as inputs. See page
        <link linkend="ask_lists">24</link>.
      </para>
      <para>
        The <emphasis role="strong">SciSnap<emphasis>!</emphasis>
        library</emphasis> and the <emphasis role="strong">TuneScope
        library</emphasis> are too big to discuss here and are
        documented separately at
        <link xlink:href="http://emu-online.de/ProgrammingWithSciSnap.pdf">http://emu-online.de/ProgrammingWithSciSnap.pdf</link>
        and
        <link xlink:href="https://maketolearn.org/creating-art-animations-and-music/">https://maketolearn.org/creating-art-animations-and-music/</link>
        respectively.
      </para>
    </section>
  </section>
</section>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="saving-and-loading-projects-and-media">
  <title>Saving and Loading Projects and Media</title>
  <para>
    After you’ve created a project, you’ll want to save it, so that you
    can have access to it the next time you use
    Snap<emphasis>!</emphasis>. There are two ways to do that. You can
    save a project on your own computer, or you can save it at the
    Snap<emphasis>!</emphasis> web site. The advantage of saving on the
    net is that you have access to your project even if you are using a
    different computer, or a mobile device such as a tablet or
    smartphone. The advantage of saving on your computer is that you
    have access to the saved project while on an airplane or otherwise
    not on the net. Also, cloud projects are limited in size, but you
    can have all the costumes and sounds you like if you save locally.
    This is why we have multiple ways to save.
  </para>
  <para>
    <anchor xml:id="saveas" /><inlinemediaobject>
      <imageobject>
        <imagedata fileref="media/image487.png" width="3.54861in" depth="2.57639in" />
      </imageobject>
    </inlinemediaobject>In either case, if you choose “Save as…” from
    the File menu. You’ll see something like this:
  </para>
  <para>
    (If you are not logged in to your Snap<emphasis>!</emphasis> cloud
    account, Computer will be the only usable option.) The text box at
    the bottom right of the Save dialog allows you to enter project
    notes that are saved with the project.
  </para>
  <section xml:id="local-storage">
    <title>Local Storage</title>
    <para>
      Click on Computer and Snap<emphasis>!</emphasis>’s Save Project
      dialog window will be replaced by your operating system’s standard
      save window. If your project has a name, that name will be the
      default filename if you don’t give a different name. Another,
      equivalent way to save to disk is to choose “Export project” from
      the File menu.
    </para>
  </section>
  <section xml:id="creating-a-cloud-account">
    <title><inlinemediaobject>
      <imageobject>
        <imagedata fileref="media/image488.png" width="1.23403in" depth="2.32986in" />
      </imageobject>
    </inlinemediaobject>Creating a Cloud Account</title>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image489.png" width="0.29167in" depth="0.16667in" />
        </imageobject>
      </inlinemediaobject>The other possibility is to save your project
      “in the cloud,” at the Snap<emphasis>!</emphasis> web site. In
      order to do this, you need an account with us. Click on the Cloud
      button ( ) in the Tool Bar. Choose the “Signup…” option. This will
      show you a window that looks like the picture at the right.
    </para>
    <para>
      You must choose a user name that will identify you on the web
      site, such as Jens or bh. If you’re a Scratch user, you can use
      your Scratch name for Snap<emphasis>!</emphasis> too. If you’re a
      kid, don’t pick a user name that includes your family name, but
      first names or initials are okay. Don’t pick something you’d be
      embarrassed to have other users (or your parents) see! If the name
      you want is already taken, you’ll have to choose another one. You
      must also supply a password.
    </para>
    <para>
      We ask for your month and year of birth; we use this information
      only to decide whether to ask for your own email address or your
      parent’s email address. (If you’re a kid, you shouldn’t sign up
      for anything on the net, not even Snap<emphasis>!</emphasis>,
      without your parent’s knowledge.) We do not store your birthdate
      information on our server; it is used on your own computer only
      during this initial signup. We do not ask for your
      <emphasis>exact</emphasis> birthdate, even for this one-time
      purpose, because that’s an important piece of personally
      identifiable information.
    </para>
    <para>
      When you click OK, an email will be sent to the email address you
      gave, asking you to verify (by clicking a link) that it’s really
      your email address. We keep your email address on file so that, if
      you forget your password, we can send you a password-reset link.
      We will also email you if your account is suspended for violation
      of the Terms of Service. We do not use your address for any other
      purpose. You will never receive marketing emails of any kind
      through this site, neither from us nor from third parties. If,
      nevertheless, you are worried about providing this information, do
      a web search for “temporary email.”
    </para>
    <para>
      Finally, you must read and agree to the Terms of Service. A quick
      summary: Don’t interfere with anyone else’s use of the web site,
      and don’t put copyrighted media or personally identifiable
      information in projects that you share with other users. And we’re
      not responsible if something goes wrong. (Not that we
      <emphasis>expect</emphasis> anything to go wrong; since
      Snap<emphasis>!</emphasis> runs in JavaScript in your browser, it
      is strongly isolated from the rest of your computer. But the
      lawyers make us say this.)
    </para>
  </section>
  <section xml:id="saving-to-the-cloud">
    <title>Saving to the Cloud</title>
    <para>
      Once you’ve created your account, you can log into it using the
      “Login…” option from the Cloud menu:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image490.png" width="1.6875in" depth="2.02778in" />
        </imageobject>
      </inlinemediaobject>Use the user name and password that you set up
      earlier. If you check the “Stay signed in” box, then you will be
      logged in automatically the next time you run
      Snap<emphasis>!</emphasis> from the same browser on the same
      computer. Check the box if you’re using your own computer and you
      don’t share it with siblings. <emphasis>Don’t</emphasis> check the
      box if you’re using a public computer at the library, at school,
      etc.
    </para>
    <para>
      Once logged in, you can choose the “Cloud” option in the “Save
      Project” dialog shown on page <link linkend="saveas">37</link>.
      You enter a project name, and optionally project notes; your
      project will be saved online and can be loaded from anywhere with
      net access. The project notes will be visible to other users if
      you publish your project.
    </para>
  </section>
  <section xml:id="loading-saved-projects">
    <title>Loading Saved Projects</title>
    <para>
      Once you’ve saved a project, you want to be able to load it back
      into Snap<emphasis>!</emphasis>. There are two ways to do this:
    </para>
    <para>
      1. If you saved the project in your online
      Snap<emphasis>!</emphasis> account, choose the “Open…” option from
      the File menu. Choose the “Cloud” button, then select your project
      from the list in the big text box and click OK, or choose the
      “Computer” button to open an operating system open dialog. (A
      third button, “Examples,” lets you choose from example projects
      that we provide. You can see what each of these projects is about
      by clicking on it and reading its project notes.)
    </para>
    <para>
      2. If you saved the project as an XML file on your computer,
      choose “Import…” from the File menu. This will give you an
      ordinary browser file-open window, in which you can navigate to
      the file as you would in other software. Alternatively, find the
      XML file on your desktop, and just drag it onto the
      Snap<emphasis>!</emphasis> window.
    </para>
    <para>
      The second technique above also allows you to import media
      (costumes and sounds) into a project. Just choose “Import…” and
      then select a picture or sound file instead of an XML file.
    </para>
    <para>
      Snap<emphasis>!</emphasis> can also import projects created in
      BYOB 3.0 or 3.1, or (with some effort; see our web site) in
      Scratch 1.4, 2.0 or 3.0. Almost all such projects work correctly
      in Snap<emphasis>!</emphasis>, apart from a small number of
      incompatible blocks.
    </para>
    <para>
      If you saved projects in an earlier version of
      Snap<emphasis>!</emphasis> using the “Browser” option, then a
      Browser button will be shown in the Open dialog to allow you to
      retrieve those projects. But you can save them only with the
      Computer and Cloud options.
    </para>
  </section>
  <section xml:id="if-you-lose-your-project-do-this-first">
    <title>If you lose your project, do this first!</title>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image384.png" width="0.31944in" depth="0.18056in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:Dropbox:manual (1):filebutton.png</phrase>
        </textobject>
      </inlinemediaobject>If you are still in
      <emphasis role="strong">Snap<emphasis>!</emphasis></emphasis> and
      realize that you’ve loaded another project without saving the one
      you were working on: <emphasis><emphasis role="strong">Don’t edit
      the new project.</emphasis></emphasis> From the File menu choose
      the Restore unsaved project option.
    </para>
    <para>
      Restore unsaved project will also work if you log out of
      Snap<emphasis>!</emphasis> and later log back in, as long as you
      don’t edit another project meanwhile. Snap<emphasis>!</emphasis>
      remembers only the most recent project that you’ve edited (not
      just opened, but actually changed in the project editor).
    </para>
    <para>
      If your project on the cloud is missing, empty, or otherwise
      broken and isn’t the one you edited most recently, or if Restore
      unsaved project fails: <emphasis><emphasis role="strong">Don’t
      edit the broken project.</emphasis></emphasis> In the Open… box,
      enter your project name, then push the Recover button.
      <emphasis>Do this right away,</emphasis> because we save only the
      version before the most recent, and the latest before today. So
      don’t keep saving bad versions; Recover right away. The Recover
      feature works only on a project version that you actually saved,
      so Restore unsaved project is your first choice if you switch away
      from a project without saving it.
    </para>
    <para>
      To help you remember to save your projects, when you’ve edited the
      project and haven’t yet saved it, Snap<emphasis>!</emphasis>
      displays a pencil icon to the left of the project name on the
      toolbar at the top of the window:
    </para>
    <para>
      nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn
    </para>
  </section>
  <section xml:id="private-and-public-projects">
    <title>Private and Public Projects</title>
    <para>
      By default, a project you save in the cloud is private; only you
      can see it. There are two ways to make a project available to
      others. If you share a project, you can give your friends a
      project URL (in your browser’s URL bar after you open the project)
      they can use to read it. If you publish a project, it will appear
      on the Snap<emphasis>!</emphasis> web site, and the whole world
      can see it. In any case, nobody other than you can ever overwrite
      your project; if others ask to save it, they get their own copy in
      their own account.
    </para>
  </section>
</section>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="building-a-block">
  <title>
  Building a Block</title>
  <para>
    The first version of Snap<emphasis>!</emphasis> was called BYOB, for
    “Build Your Own Blocks.” This was the first and is still the most
    important capability we added to Scratch. (The name was changed
    because a few teachers have no sense of humor. ☹ You pick your
    battles.) Scratch 2.0 and later also has a partial custom block
    capability.
  </para>
  <section xml:id="simple-blocks">
    <title>Simple Blocks</title>
    <para>
      In every palette, at or near the bottom, is a button labeled “Make
      a block.” Also, floating near the top of the palette is a plus
      sign. Also, the menu you get by right-clicking on the background
      of the scripting area has a “make a block” option.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image501.png" width="2.27083in" depth="2.34722in" />
        </imageobject>
      </inlinemediaobject>Clicking any of these will display a dialog
      window in which you choose the block’s name, shape, and
      palette/color. You also decide whether the block will be available
      to all sprites, or only to the current sprite and its children.
    </para>
    <para>
      In this dialog box, you can choose the block's palette, shape, and
      name. With one exception, there is one color per palette, e.g.,
      all Motion blocks are blue. But the Variables palette includes the
      orange variable-related blocks and the red list-related blocks.
      Both colors are available, along with an “Other” option that makes
      grey blocks in the Variables palette for blocks that don’t fit any
      category.
    </para>
    <para>
      There are three block shapes, following a convention that should
      be familiar to Scratch users: The jigsaw-puzzle-piece shaped
      blocks are Commands, and don’t report a value. The oval blocks are
      Reporters, and the hexagonal blocks are Predicates, which is the
      technical term for reporters that report Boolean (true or false)
      values.
    </para>
    <para>
      Suppose you want to make a block named “square” that draws a
      square. You would choose Motion, Command, and type “square” into
      the name field. When you click OK, you enter the Block Editor.
      This works just like making a script in the sprite’s scripting
      area, except that the “hat” block at the top, instead of saying
      something like “when I am clicked,” has a picture of the block
      you’re building. This hat block is called the
      <emphasis>prototype</emphasis> of your custom block.<footnote>
        <para>
          This use of the word “prototype” is unrelated to the
          <emphasis>prototyping object oriented programming</emphasis>
          discussed later.
        </para>
      </footnote> You drag blocks under the hat to program your custom
      block, then click OK:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image502.png" width="4.21094in" depth="1.3364in" />
        </imageobject>
      </inlinemediaobject>
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image503.png" width="4.61556in" depth="3.64778in" />
        </imageobject>
      </inlinemediaobject>
    </para>
    <para>
      Your block appears at the bottom of the Motion palette. Here’s the
      block and the result of using it:
    </para>
    <section xml:id="custom-blocks-with-inputs">
      <title>
      Custom Blocks with Inputs</title>
      <para>
        But suppose you want to be able to draw squares of different
        sizes. Control-click or right-click on the block, choose “edit,”
        and the Block Editor will open. Notice the plus signs before and
        after the word square in the prototype block. If you hover the
        mouse over one, it lights up:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image508.png" width="3.44444in" depth="2.72222in" />
          </imageobject>
        </inlinemediaobject>
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image509.png" width="2.58333in" depth="1.60417in" />
          </imageobject>
        </inlinemediaobject>Click on the plus on the right. You will
        then see the “input name” dialog:
      </para>
      <para>
        Type in the name “size” and click OK. There are other options in
        this dialog; you can choose “title text” if you want to add
        words to the block name, so it can have text after an input
        slot, like the “move ( ) steps” block. Or you can select a more
        extensive dialog with a lot of options about your input name.
        But we’ll leave that for later. When you click OK, the new input
        appears in the block prototype:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image510.png" width="1.47917in" depth="1.48958in" />
          </imageobject>
        </inlinemediaobject>You can now drag the orange variable down
        into the script, then click okay:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image511.png" width="1.47472in" depth="1.4955in" />
          </imageobject>
        </inlinemediaobject>
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image512.png" width="0.69792in" depth="0.25in" />
          </imageobject>
        </inlinemediaobject>Your block now appears in the Motion palette
        with an input box: You can draw any size square by entering the
        length of its side in the box and running the block as usual, by
        clicking it or by putting it in a script.
      </para>
    </section>
    <section xml:id="editing-block-properties">
      <title>Editing Block Properties</title>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image513.png" width="0.99931in" depth="0.76042in" />
          </imageobject>
        </inlinemediaobject>What if you change your mind about a block’s
        color (palette) or shape (command, reporter, predicate)? If you
        click in the hat block at the top that holds the prototype, but
        not in the prototype itself, you’ll see a window in which you
        can change the color, and <emphasis>sometimes</emphasis> the
        shape, namely, if the block is not used in any script, whether
        in a scripting area or in another custom block. (This includes a
        one-block script consisting of a copy of the new block pulled
        out of the palette into the scripting area, seeing which made
        you realize it’s the wrong category. Just delete that copy (drag
        it back to the palette) and then change the category.)
      </para>
      <para>
        If you right-click/control-click the hat block, you get this
        menu:
      </para>
      <para>
        Script pic exports a picture of the script. (Many of the
        illustrations in this manual were made that way.) Translations
        opens a window in which you can specify how your block should be
        translated if the user chooses a language other than the one in
        which you are programming. Block variables lets you create a
        variant of script variables for this block: A script variable is
        created when a block is called, and it disappears when that call
        finishes. What if you want a variable that’s local to this
        block, as a script variable is, but doesn’t disappear between
        invocations? That’s a block variable. If the definition of a
        block includes a block variable, then every time that (custom)
        block is dragged from the palette into a script, the block
        variable is created. Every time <emphasis>that copy</emphasis>
        of the block is called, it uses the same block variable, which
        preserves its value between calls. Other copies of the block
        have their own block variables. The in palette checkbox
        determines whether or not this block will be visible in the
        palette. It’s normally checked, but you may want to hide custom
        blocks if you’re a curriculum writer creating a Parsons problem.
        To unhide blocks, choose “Hide blocks” from the File menu and
        uncheck the checkboxes. Edit does the same thing as regular
        clicking, as described earlier.
      </para>
    </section>
  </section>
  <section xml:id="recursion">
    <title>Recursion</title>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image514.png" width="2.96528in" depth="2.36319in" />
        </imageobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image515.png" width="1.95833in" depth="2.35417in" />
        </imageobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image516.png" width="1.42361in" depth="0.91181in" />
        </imageobject>
      </inlinemediaobject>Since the new custom block appears in its
      palette as soon as you <emphasis>start</emphasis> editing it, you
      can write recursive blocks (blocks that call themselves) by
      dragging the block into its own definition:
    </para>
    <para>
      (If you added inputs to the block since opening the editor, click
      Apply before finding the block in the palette, or drag the block
      from the top of the block editor rather than from the palette.)
    </para>
    <para>
      If recursion is new to you, here are a few brief hints: It’s
      crucial that the recursion have a <emphasis>base case,</emphasis>
      that is, some small(est) case that the block can handle without
      using recursion. In this example, it’s the case depth=0, for which
      the block does nothing at all, because of the enclosing if.
      Without a base case, the recursion would run forever, calling
      itself over and over.
    </para>
    <para>
      Don’t try to trace the exact sequence of steps that the computer
      follows in a recursive program. Instead, imagine that inside the
      computer there are many small people, and if Theresa is drawing a
      tree of size 100, depth 6, she hires Tom to make a tree of size
      70, depth 5, and later hires Theo to make another tree of size 70,
      depth 5. Tom in turn hires Tammy and Tallulah, and so on. Each
      little person has his or her own local variables size and depth,
      each with different values.
    </para>
    <para>
      You can also write recursive reporters, like this block to compute
      the factorial function:
    </para>
    <para>
      Note the use of the report block. When a reporter block uses this
      block, the reporter finishes its work and reports the value given;
      any further blocks in the script are not evaluated. Thus, the if
      else block in the script above could have been just an if, with
      the second report block below it instead of inside it, and the
      result would be the same, because when the ﬁrst report is seen in
      the base case, that finishes the block invocation, and the second
      report is ignored. There is also a stop this block block that has
      a similar purpose, ending the block invocation early, for command
      blocks. (By contrast, the stop this script block stops not only
      the current block invocation, but also the entire toplevel script
      that called it.)
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image521.png" width="4.29167in" depth="0.86458in" />
        </imageobject>
      </inlinemediaobject>Here’s a slightly more compact way to write
      the factorial function:
    </para>
    <para>
      For more on recursion, see <emphasis>Thinking
      Recursively</emphasis> by Eric Roberts. (The original edition is
      ISBN 978‑0471816522; a more recent <emphasis>Thinking Recursively
      in Java</emphasis> is ISBN 978-0471701460.)
    </para>
  </section>
  <section xml:id="block-libraries">
    <title>Block Libraries</title>
    <para>
      When you save a project (see Chapter II above), any custom blocks
      you’ve made are saved with it. But sometimes you’d like to save a
      collection of blocks that you expect to be useful in more than one
      project. Perhaps your blocks implement a particular data structure
      (a stack, or a dictionary, etc.), or they’re the framework for
      building a multilevel game. Such a collection of blocks is called
      a <emphasis>block library.</emphasis>
    </para>
<literallayout><emphasis>
</emphasis>To create a block library, choose “Export blocks…” from the File menu. You then see a window like this:</literallayout>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image522.png" width="2.02153in" depth="2.72222in" />
        </imageobject>
      </inlinemediaobject>The window shows all of your global custom
      blocks. You can uncheck some of the checkboxes to select exactly
      which blocks you want to include in your library. (You can
      right-click or control-click on the export window for a menu that
      lets you check or uncheck all the boxes at once.) Then press OK.
      An XML file containing the blocks will appear in your Downloads
      location.
    </para>
    <para>
      To import a block library, use the “Import…” command in the File
      menu, or just drag the XML file into the
      Snap<emphasis>!</emphasis> window.
    </para>
    <para>
      Several block libraries are included with
      Snap<emphasis>!</emphasis>; for details about them, see page
      <link linkend="libraries-1">25</link>.
    </para>
  </section>
  <section xml:id="custom-blocks-and-visible-stepping">
    <title>Custom blocks and Visible Stepping</title>
    <para>
      Visible stepping normally treats a call to a custom block as a
      single step. If you want to see stepping inside a custom block you
      must take these steps <emphasis>in order:</emphasis>
    </para>
    <orderedlist numeration="arabic">
      <listitem>
        <para>
          <inlinemediaobject>
            <imageobject>
              <imagedata fileref="media/image123.png" width="0.29167in" depth="0.16667in" />
            </imageobject>
            <textobject>
              <phrase>Macintosh HD:Users:bh:Desktop:pix:footprint-lit.png</phrase>
            </textobject>
          </inlinemediaobject>Turn on Visible Stepping.
        </para>
      </listitem>
      <listitem>
        <para>
          Select “Edit” in the context menu(s) of the block(s) you want
          to examine.
        </para>
      </listitem>
      <listitem>
        <para>
          Then start the program.
        </para>
      </listitem>
    </orderedlist>
    <para>
      The Block Editor windows you open in step 2 do not have full
      editing capability. You can tell because there is only one “OK”
      button at the bottom, not the usual three buttons. Use the button
      to close these windows when done stepping.
    </para>
  </section>
</section>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="first-class-lists">
  <title>First class lists</title>
  <para>
    A data type is <emphasis>ﬁrst class</emphasis> in a programming
    language if data of that type can be
  </para>
  <itemizedlist>
    <listitem>
      <para>
        the value of a variable
      </para>
    </listitem>
    <listitem>
      <para>
        an input to a procedure
      </para>
    </listitem>
    <listitem>
      <para>
        the value returned by a procedure
      </para>
    </listitem>
    <listitem>
      <para>
        a member of a data aggregate
      </para>
    </listitem>
    <listitem>
      <para>
        anonymous (not named)
      </para>
    </listitem>
  </itemizedlist>
  <para>
    In Scratch, numbers and text strings are ﬁrst class. You can put a
    number in a variable, use one as the input to a block, call a
    reporter that reports a number, or put a number into a list.
  </para>
  <para>
    But Scratch’s lists are not ﬁrst class. You create one using the
    “Make a list” button, which requires that you give the list a name.
    You can’t put the list into a variable, into an input slot of a
    block, or into a list item—you can’t have lists of lists. None of
    the Scratch reporters reports a list value. (You can use a reduction
    of the list into a text string as input to other blocks, but this
    loses the list structure; the input is just a text string, not a
    data aggregate.)
  </para>
  <para>
    A fundamental design principle in Snap<emphasis>!</emphasis> is that
    <emphasis><emphasis role="strong"><emphasis role="underline">all
    data should be ﬁrst class</emphasis></emphasis>.</emphasis> If it’s
    in the language, then we should be able to use it fully and freely.
    We believe that this principle avoids the need for many special-case
    tools, which can instead be written by Snap<emphasis>!</emphasis>
    users themselves.
  </para>
  <para>
    <inlinemediaobject>
      <imageobject>
        <imagedata fileref="media/image523.png" width="2.83958in" depth="0.41597in" />
      </imageobject>
    </inlinemediaobject>Note that it’s a data <emphasis>type</emphasis>
    that’s ﬁrst class, not an individual value. Don’t think, for
    example, that some lists are ﬁrst class, while others aren’t. In
    Snap<emphasis>!</emphasis>, lists are ﬁrst class, period.
  </para>
  <section xml:id="the-list-block">
    <title> The list Block</title>
    <para>
      At the heart of providing first class lists is the ability to make
      an “anonymous” list—to make a list without simultaneously giving
      it a name. The list reporter block does that.
    </para>
    <para>
      At the right end of the block are two left-and-right arrowheads.
      Clicking on these changes the number of inputs to list, i.e., the
      number of elements in the list you are building. Shift-clicking
      changes by three at a time.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image534.png" width="1.50347in" depth="1.8125in" />
        </imageobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image535.png" width="2.24375in" depth="0.32153in" />
        </imageobject>
      </inlinemediaobject>You can use this block as input to many other
      blocks:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image536.png" width="3.09375in" depth="0.77083in" />
        </imageobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image537.png" width="1.82292in" depth="0.29167in" />
        </imageobject>
      </inlinemediaobject>Snap<emphasis>!</emphasis> does not have a
      “Make a list” button like the one in Scratch. If you want a global
      “named list,” make a global variable and use the set block to put
      a list into the variable.
    </para>
  </section>
  <section xml:id="lists-of-lists">
    <title>Lists of Lists</title>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image538.png" width="5.88889in" depth="1.04861in" />
        </imageobject>
      </inlinemediaobject>Lists can be inserted as elements in larger
      lists. We can easily create ad hoc structures as needed:
    </para>
    <para>
      Notice that this list is presented in a different format from the
      “She Loves You” list above. A two-dimensional list is called a
      <emphasis>table</emphasis> and is by default shown in
      <emphasis>table view.</emphasis> We’ll have more to say about this
      later.
    </para>
    <para>
      We can also build any classic computer science data structure out
      of lists of lists, by defining <emphasis>constructors</emphasis>
      (blocks to make an instance of the structure),
      <emphasis>selectors</emphasis> (blocks to pull out a piece of the
      structure), and <emphasis>mutators</emphasis> (blocks to change
      the contents of the structure) as needed. Here we create binary
      trees with selectors that check for input of the correct data
      type; only one selector is shown but the ones for left and right
      children are analogous.
    </para>
  </section>
  <section xml:id="functional-and-imperative-list-programming">
    <title>
    Functional and Imperative List Programming</title>
    <para>
      There are two ways to create a list inside a program. Scratch
      users will be familiar with the <emphasis>imperative</emphasis>
      programming style, which is based on a set of command blocks that
      modify a list:
    </para>
    <para>
      As an example, here are two blocks that take a list of numbers as
      input, and report a new list containing only the even numbers from
      the original list:<footnote>
        <para>
          Note to users of earlier versions: From the beginning, there
          has been a tension in our work between the desire to provide
          tools such as for (used in this example) and the higher order
          functions introduced on the next page as primitives, to be
          used as easily as other primitives, and the desire to show how
          readily such tools can be implemented in
          Snap<emphasis>!</emphasis> itself. This is one instance of our
          general pedagogic understanding that learners should both use
          abstractions and be permitted to see beneath the abstraction
          barrier. Until version 5.0, we used the uneasy compromise of a
          library of tools written in Snap<emphasis>!</emphasis> and
          easily, but not easily enough, loaded into a project. By
          <emphasis>not</emphasis> loading the tools, users or teachers
          could explore how to program them. In 5.0 we made them true
          primitives, partly because that’s what some of us wanted all
          along and partly because of the increasing importance of fast
          performance as we explore “big data” and media computation.
          But this is not the end of the story for us. In a later
          version, after we get the design firmed up, we intend to
          introduce “hybrid” primitives, implemented in high speed
          Javascript but with an “Edit” option that will open, not the
          primitive implementation, but the version written in
          Snap<emphasis>!</emphasis>. The trick is to ensure that this
          can be done without dramatically slowing users’ projects.
        </para>
      </footnote>
    </para>
    <para>
      or
    </para>
    <para>
      In this script, we first create a temporary variable, then put an
      empty list in it, then go through the items of the input list
      using the add <emphasis role="strong">…</emphasis> to (result)
      block to modify the result list, adding one item at a time, and
      finally report the result.
    </para>
    <para>
      <emphasis>Functional</emphasis> programming is a different
      approach that is becoming important in “real world” programming
      because of parallelism, i.e., the fact that different processors
      can be manipulating the same data at the same time. This makes the
      use of mutation (changing the value associated with a variable, or
      the items of a list) problematic because with parallelism it’s
      impossible to know the exact sequence of events, so the result of
      mutation may not be what the programmer expected. Even without
      parallelism, though, functional programming is sometimes a simpler
      and more effective technique, especially when dealing with
      recursively defined data structures. It uses reporter blocks, not
      command blocks, to build up a list value:
    </para>
    <para>
      In a functional program, we often use recursion to construct a
      list, one item at a time. The in front of block makes a list that
      has one item added to the front of an existing list,
      <emphasis>without changing the value of the original
      list.</emphasis> A nonempty list is processed by dividing it into
      its first item (item 1 of) and all the rest of the items (all but
      first of), which are handled through a recursive call:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image555.png" width="4.75in" depth="2.24097in" />
        </imageobject>
      </inlinemediaobject>Snap<emphasis>!</emphasis> uses two different
      internal representations of lists, one (dynamic array) for
      imperative programming and the other (linked list) for functional
      programming. Each representation makes the corresponding built-in
      list blocks (commands or reporters, respectively) most efficient.
      It’s possible to mix styles in the same program, but if
      <emphasis>the same list</emphasis> is used both ways, the program
      will run more slowly because it converts from one representation
      to the other repeatedly. (The item ( ) of [ ] block doesn’t change
      the representation.) You don’t have to know the details of the
      internal representations, but it’s worthwhile to use each list in
      a consistent way.
    </para>
  </section>
  <section xml:id="higher-order-list-operations-and-rings">
    <title><inlinemediaobject>
      <imageobject>
        <imagedata fileref="media/image556.png" width="5.86458in" depth="1.07153in" />
      </imageobject>
    </inlinemediaobject>Higher Order List Operations and Rings</title>
    <para>
      There’s an even easier way to select the even numbers from a list:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image557.png" width="2.375in" depth="0.27778in" />
        </imageobject>
      </inlinemediaobject>The keep block takes a Predicate expression as
      its first input, and a list as its second input. It reports a list
      containing those elements of the input list for which the
      predicate returns true. Notice two things about the predicate
      input: First, it has a grey ring around it. Second, the mod block
      has an empty input. Keep puts each item of its input list, one at
      a time, into that empty input before evaluating the predicate.
      (The empty input is supposed to remind you of the “box” notation
      for variables in elementary school: ☐+3=7.) The grey ring is part
      of the keep block as it appears in the palette:
    </para>
    <para>
      What the ring means is that this input is a block (a predicate
      block, in this case, because the interior of the ring is a
      hexagon), rather than the value reported by that block. Here’s the
      difference:
    </para>
    <para>
      Evaluating the = block without a ring reports true or false;
      evaluating the block <emphasis>with</emphasis> a ring reports the
      block itself. This allows keep to evaluate the = predicate
      repeatedly, once for each list item. A block that takes another
      block as input is called a <emphasis>higher order</emphasis> block
      (or higher order procedure, or higher order function).
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image562.png" width="2.39in" depth="0.22in" />
        </imageobject>
      </inlinemediaobject> Snap<emphasis>!</emphasis> provides four
      higher order function blocks for operating on lists:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image571.emf" width="7.5in" depth="1.71389in" />
        </imageobject>
      </inlinemediaobject><anchor xml:id="map" />You’ve already seen
      keep. Find first is similar, but it reports just the first item
      that satisfies the predicate, not a list of all the matching
      items. It’s equivalent to but faster because it
    </para>
    <para>
      stops looking as soon as it finds a match. If there are no
      matching items, it returns an empty string.
    </para>
    <para>
      Map takes a Reporter block and a list as inputs. It reports a new
      list in which each item is the value reported by the Reporter
      block as applied to one item from the input list. That’s a
      mouthful, but an example will make its meaning clear:
    </para>
    <para>
      These examples use small lists, to fit the page, but the higher
      order blocks work for any size list.
    </para>
    <para>
      By the way, we’ve been using arithmetic examples, but the list
      items can be of any type, and any reporter can be used. We’ll make
      the plurals of some words:
    </para>
    <para>
      An <emphasis>empty</emphasis> gray ring represents the
      <emphasis>identity function,</emphasis> which just reports its
      input. Leaving the ring in map empty is the most concise way to
      make a shallow copy of a list (that is, in the case of a list of
      lists, the result is a new toplevel list whose items are the same
      (uncopied) lists that are items of the toplevel input list). To
      make a deep copy of a list (that is, one in which all the
      sublists, sublists of sublists, etc. are copied), use the list as
      input to the <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image576.png" width="0.74306in" depth="0.19444in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:id.png</phrase>
        </textobject>
      </inlinemediaobject> block (one of the variants of the sqrt of
      block). This works because id of is a hyperblock (page
      <link linkend="hyperblocks">55</link>).
    </para>
    <para>
      The third higher order block, combine, computes a single result
      from <emphasis>all</emphasis> the items of a list, using a
      <emphasis>two-input</emphasis> reporter as its second input. In
      practice, there are only a few blocks you’ll ever use with
      combine:
    </para>
    <para>
      These blocks take the sum of the list items, take their product,
      string them into one word, combine them into a sentence (with
      spaces between items), see if all items of a list of Booleans are
      true, see if any of the items is true, find the smallest, or find
      the largest.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image585.png" width="6.27917in" depth="0.37569in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:comma-list.png</phrase>
        </textobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image586.png" width="3.86806in" depth="0.34514in" />
        </imageobject>
      </inlinemediaobject>Why + but not −? It only makes sense to
      combine list items using an <emphasis>associative</emphasis>
      function: one that doesn’t care in what order the items are
      combined (left to right or right to left). (2+3)+4 = 2+(3+4), but
      (2−3)−4 ≠ 2−(3−4).
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image587.png" width="5.80833in" depth="1.19097in" />
        </imageobject>
      </inlinemediaobject>The functions map, keep, and find first have
      an advanced mode with rarely-used features: If their function
      input is given explicit input names (by clicking the arrowhead at
      the right end of the gray ring; see page
      <link linkend="formal-parameters">69</link>), then it will be
      called for each list item with <emphasis>three</emphasis> inputs:
      the item’s value (as usual), the item’s position in the input list
      (its index), and the entire input list. No more than three input
      names can be used in this contex
    </para>
  </section>
  <section xml:id="section-2" role="unnumbered">
    <title></title>
    <para>
    </para>
  </section>
  <section xml:id="table-view-vs.-list-view">
    <title>Table View vs. List View</title>
    <para>
      We mentioned earlier that there are two ways of representing lists
      visually. For one-dimensional lists (lists whose items are not
      themselves lists) the visual differences are small:
    </para>
    <para>
      For one-dimensional lists, it’s not really the appearance that’s
      important. What matters is that the <emphasis>list view</emphasis>
      allows very versatile direct manipulation of the list through the
      picture: you can edit the individual items, you can delete items
      by clicking the tiny buttons next to each item, and you can add
      new items at the end by clicking the tiny plus sign in the lower
      left corner. (You can just barely see that the item deletion
      buttons have minus signs in them.) Even if you have several
      watchers for the same list, all of them will be updated when you
      change anything. On the other hand, this versatility comes at an
      efficiency cost; a list view watcher for a long list would be way
      too slow. As a partial workaround, the list view can only contain
      100 items at a time; the downward-pointing arrowhead opens a menu
      in which you can choose which 100 to display.
    </para>
    <para>
      By contrast, because it doesn’t allow direct editing, the
      <emphasis>table view</emphasis> watcher can hold hundreds of
      thousands of items and still scroll through them efficiently. The
      table view has flatter graphics for the items to remind you that
      they’re not clickable to edit the values.
    </para>
    <para>
      Right-clicking on a list watcher (in either form) gives you the
      option to switch to the other form. The right-click menu also
      offers an open in dialog… option that opens an
      <emphasis>offstage</emphasis> table view watcher, because the
      watchers can take up a lot of stage space that may make it hard to
      see what your program is actually doing. Once the offstage dialog
      box is open, you can close the stage watcher. There’s an OK button
      on the offstage dialog to close it if you want. Or you can
      right-click it to make <emphasis>another</emphasis> offstage
      watcher, which is useful if you want to watch two parts of the
      list at once by having each watcher scrolled to a different place.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image538.png" width="5.88889in" depth="1.04861in" />
        </imageobject>
      </inlinemediaobject>Table view is the default if the list has more
      than 100 items, or if any of the first ten items of the list are
      lists, in which case it makes a very different-looking
      two-dimensional picture:
    </para>
    <para>
      In this format, the column of red items has been replaced by a
      spreadsheet-looking display. For short, wide lists, this display
      makes the content of the list very clear. A vertical display, with
      much of the space taken up by the “machinery” at the bottom of
      each sublist, would make it hard to show all the text at once.
      (The pedagogic cost is that the structure is no longer explicit;
      we can’t tell just by looking that this is a list of row-lists,
      rather than a list of column-lists or a primitive two-dimensional
      array type. But you can choose list view to see the structure.)
    </para>
    <para>
      Beyond such simple cases, in which every item of the main list is
      a list of the same length, it’s important to keep in mind that the
      design of table view has to satisfy two goals, not always in
      agreement: (1) a visually compelling display of two-dimensional
      arrays, and (2) highly efficient display generation, so that
      Snap<emphasis>!</emphasis> can handle very large lists, since “big
      data” is an important topic of study. To meet the first goal
      perfectly in the case of “ragged right” arrays in which sublists
      can have different lengths, Snap<emphasis>!</emphasis> would scan
      the entire list to find the maximum width before displaying
      anything, but that would violate the second goal.
    </para>
    <para>
      Snap<emphasis>!</emphasis> uses the simplest possible compromise
      between the two goals: It examines only the first ten items of the
      list to decide on the format. If none of those are lists, or
      they’re all lists of one item, and the overall length is no more
      than 100, list view is used. If the any of first ten items is a
      list, then table view is used, and the number of columns in the
      table is equal to the largest number of items among the first ten
      items (sublists) of the main list.
    </para>
    <para>
      Table views open with standard values for the width and height of
      a cell, regardless of the actual data. You can change these values
      by dragging the column letters or row numbers. Each column has its
      own width, but changing the height of a row changes the height for
      all rows. (This distinction is based not on the semantics of rows
      vs. columns, but on the fact that a constant row height makes
      scrolling through a large list more efficient.) Shift-dragging a
      column label will change the width of that column.
    </para>
    <para>
      If you tried out the adjustments in the previous paragraph, you
      may have noticed that a column letter turns into a number when you
      hover over it. Labeling rows and columns differently makes cell
      references such as “cell 4B” unambiguous; you don’t have to have a
      convention about whether to say the row first or the column first.
      (“Cell B4” is the same as “cell 4B.”) On the other hand, to
      extract a value from column B in your program, you have to say
      item 2 of, not item B of. So it’s useful to be able to find out a
      column number by hovering over its letter.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image596.png" width="3.81736in" depth="0.81111in" />
        </imageobject>
      </inlinemediaobject>Any value that can appear in a program can be
      displayed in a table cell:
    </para>
    <para>
      This display shows that the standard cell dimensions may not be
      enough for large value images. By expanding the entire speech
      balloon and then the second column and all the rows, we can make
      the result fit:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image601.png" width="3.34097in" depth="0.57708in" />
        </imageobject>
      </inlinemediaobject>But we make an exception for cases in which
      the value in a cell is a list (so that the entire table is
      three-dimensional). Because lists are visually very big, we don’t
      try to fit the entire value in a cell:
    </para>
    <para>
      Even if you expand the size of the cells,
      Snap<emphasis>!</emphasis> will not display sublists of sublists
      in table view. There are two ways to see these inner sublists: You
      can switch to list view, or you can double-click on a list icon in
      the table to open a dialog box showing just that sub-sub-list in
      table view.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image602.png" width="3.35417in" depth="0.69444in" />
        </imageobject>
      </inlinemediaobject>One last detail: If the first item of a list
      is a list (so table view is used), but a later item
      <emphasis>isn’t</emphasis> a list, that later item will be
      displayed on a red background, like an item of a single-column
      list:
    </para>
    <para>
      So, in particular, if only the first item is a list, the display
      will look almost like a one-column display.
    </para>
    <section xml:id="comma-separated-values">
      <title>Comma-Separated Values</title>
      <para>
        Spreadsheet and database programs generally offer the option to
        export their data as CSV (comma-separated values lists. You can
        import these files into Snap<emphasis>!</emphasis> and turn them
        into tables (lists of lists), and you can export tables in CSV
        format. Snap<emphasis>!</emphasis> recognizes a CSV file by the
        extension .csv in its filename.
      </para>
      <para>
        A CSV file has one line per table row, with the fields separated
        by commas within a row:
      </para>
      <para>
        John,Lennon,rhythm guitar
      </para>
      <para>
        table view
      </para>
      <para>
        list view
      </para>
      <para>
        Paul,McCartney,bass guitar
      </para>
      <para>
        George,Harrison,lead guitar
      </para>
      <para>
        Ringo,Starr,drums
      </para>
      <para>
        Here’s what the corresponding table looks like:
      </para>
      <para>
        Here’s how to read a spreadsheet into
        Snap<emphasis>!</emphasis>:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image607.png" width="1.20833in" depth="0.27083in" />
          </imageobject>
          <textobject>
            <phrase>Macintosh HD:Users:bh:Desktop:pix:watcher.png</phrase>
          </textobject>
        </inlinemediaobject>1. Make a variable with a watcher on stage:
      </para>
      <para>
        2. Right-click on the watcher and choose the “import” option.
        (If the variable’s value is already a list, be sure to click on
        the outside border of the watcher; there is a different menu if
        you click on the list itself.) Select the file with your csv
        data.
      </para>
      <para>
        3. There is no 3; that’s it! Snap<emphasis>!</emphasis> will
        notice that the name of the file you’re importing is
        something.csv and will turn the text into a list of lists
        automatically.
      </para>
      <para>
        Or, even easier, just drag and drop the file from your desktop
        onto the Snap<emphasis>!</emphasis> window, and
        Snap<emphasis>!</emphasis> will automatically create a variable
        named after the file and import the data into it.
      </para>
      <para>
        If you actually want to import the raw CSV data into a variable,
        either change the file extension to .txt before loading it, or
        choose “raw data” instead of “import” in the watcher menu.
      </para>
      <para>
        If you want to export a list, put a variable watcher containing
        the list on the stage, right-click its border, and choose
        “Export.” (Don’t right-click an item instead of the border; that
        gives a different menu.)
      </para>
    </section>
    <section xml:id="multi-dimensional-lists-and-json">
      <title>Multi-dimensional lists and JSON</title>
      <para>
        CSV format is easy to read, but works only for one- or
        two-dimensional lists. If you have a list of lists of lists,
        Snap<emphasis>!</emphasis> will instead export your list as a
        JSON (JavaScript Object Notation) file. I modified my list:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image608.png" width="6.33333in" depth="0.44792in" />
          </imageobject>
        </inlinemediaobject>and then exported again, getting this file:
      </para>
      <para>
        [[&quot;John&quot;,&quot;Lennon&quot;,&quot;rhythm
        guitar&quot;],[[&quot;James&quot;,&quot;Paul&quot;],&quot;McCartney&quot;,&quot;bass
        guitar&quot;],[&quot;George&quot;,&quot;Harrison&quot;,&quot;lead
        guitar&quot;],[&quot;Ringo&quot;,&quot;Starr&quot;,&quot;drums&quot;]]
      </para>
      <para>
        You can also import lists, including tables, from a .json file.
        (And you can import plain text from a .txt file.) Drag and drop
        works for these formats also.
      </para>
    </section>
  </section>
  <section xml:id="hyperblocks">
    <title>
    Hyperblocks</title>
    <para>
      A <emphasis>scalar</emphasis> is anything other than a list. The
      name comes from mathematics, where it means a magnitude without
      direction, as opposed to a vector, which points toward somewhere.
      A scalar function is one whose domain and range are scalars, so
      all the arithmetic operations are scalar functions, but so are the
      text ones such as letter and the Boolean ones such as not.
    </para>
    <para>
      The major new feature in Snap<emphasis>!</emphasis> 6.0 is that
      the domain and range of most scalar function blocks is extended to
      multi-dimensional lists, with the underlying scalar function
      applied termwise:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image609.png" width="2.5625in" depth="0.91667in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:vector-monadic.png</phrase>
        </textobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image610.png" width="3.34028in" depth="0.91667in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:vector-vector.png</phrase>
        </textobject>
      </inlinemediaobject>
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image611.png" width="4.94444in" depth="0.69444in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:matrix-matrix.png</phrase>
        </textobject>
      </inlinemediaobject>
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image612.png" width="5.74306in" depth="0.69444in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:matrix-ragged.png</phrase>
        </textobject>
      </inlinemediaobject>Mathematicians, note in the last example above
      that the result is just a termwise application of the underlying
      function (7×3, 8×5, etc.), <emphasis>not</emphasis> matrix
      multiplication. See Appendix B for that. For a dyadic (two-input)
      function, if the lengths don’t agree, the length of the result (in
      each dimension) is the length of the shorter input:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image613.png" width="6.79167in" depth="0.86806in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:missing-dimension.png</phrase>
        </textobject>
      </inlinemediaobject>However, if the <emphasis>number of
      dimensions</emphasis> differs in the two inputs, then the number
      of dimensions in the result agrees with the
      <emphasis>higher-</emphasis>dimensional input; the
      lower-dimensional one is used repeatedly in the missing
      dimension(s):
    </para>
    <para>
      (7×6. 8×10, 1×20, <emphasis>40</emphasis>×<emphasis>6,
      20</emphasis>×<emphasis>10,</emphasis> etc.). In particular, a
      <emphasis>scalar</emphasis> input is paired with every scalar in
      the other input:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image614.png" width="7.48333in" depth="0.63125in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:vector-alonzo.png</phrase>
        </textobject>
      </inlinemediaobject>One important motivation for this feature is
      how it simplifies and speeds up media computation, as in this
      shifting of the Alonzo costume to be bluer:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image619.png" width="1.6875in" depth="1.04861in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:Screen Shot 2020-06-13 at 9.25.32 PM.png</phrase>
        </textobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image620.png" width="5.19444in" depth="1.04861in" />
        </imageobject>
        <textobject>
          <phrase>Graphical user interface, application Description automatically generated</phrase>
        </textobject>
      </inlinemediaobject>Each pixel of the result has ¾ of its original
      red and green, and three times its original blue (with its
      transparency unchanged). By putting some sliders on the stage, you
      can play with colors dynamically:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image621.png" width="1.02986in" depth="0.18958in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:in-front-of.png</phrase>
        </textobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image193.png" width="0.88958in" depth="0.2in" />
        </imageobject>
      </inlinemediaobject>There are a few naturally scalar functions
      that have already had specific meanings when applied to lists and
      therefore are not hyperblocks: = and identical to (because they
      compare entire structures, not just scalars, always reporting a
      single Boolean result), and and or (because they don’t evaluate
      their second input at all if the first input determines the
      result), join (because it converts non-scalar (and other non-text)
      inputs to text string form), and is a (type) (because it applies
      to its input as a whole). Blocks whose inputs are “natively”
      lists, such as and , are never hyperblocks.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image622.png" width="5.23958in" depth="1.67986in" />
        </imageobject>
        <textobject>
          <phrase>Graphical user interface, text, application Description automatically generated</phrase>
        </textobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image205.png" width="2.09917in" depth="0.2475in" />
        </imageobject>
        <textobject>
          <phrase>Application Description automatically generated with low confidence</phrase>
        </textobject>
      </inlinemediaobject>The reshape block takes a list (of any depth)
      as its first input, and then takes zero or more sizes along the
      dimensions of an array. In the example it will report a table (a
      matrix) of four rows and three columns. If no sizes are given, the
      result is an empty list. Otherwise, the cells of the specified
      shape are filled with the atomic values from the input list. If
      more values are needed than provided, the block starts again at
      the head of the list, using values more than once. If more values
      are provided than needed, the extras are ignored; this isn’t an
      error.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image203.png" width="1.76in" depth="0.2in" />
        </imageobject>
      </inlinemediaobject> The combinations block takes any number of
      lists as input; it reports a list in which each item is a list
      whose length is the number of inputs; item <emphasis>i</emphasis>
      of a sublist is an item of input <emphasis>i.</emphasis> Every
      possible combination of items of the inputs is included, so the
      length of the reported list is the product of the lengths of the
      inputs.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image204.png" width="1.34in" depth="0.25in" />
        </imageobject>
        <textobject>
          <phrase>Icon Description automatically generated</phrase>
        </textobject>
      </inlinemediaobject> The item of block has a special set of rules,
      designed to preserve its pre-hyperblock meaning and also provide a
      useful behavior when given a list as its first (index) input:
    </para>
    <orderedlist numeration="arabic">
      <listitem>
        <para>
          If the index is a number, then item of reports the indicated
          top-level item of the list input; that item may be a sublist,
          in which case the entire sublist is reported (the original
          meaning of item of):<inlinemediaobject>
            <imageobject>
              <imagedata fileref="media/image623.png" width="5.50694in" depth="0.91667in" />
            </imageobject>
            <textobject>
              <phrase>Macintosh HD:Users:bh:Desktop:item-scalar.png</phrase>
            </textobject>
          </inlinemediaobject>
        </para>
      </listitem>
      <listitem>
        <para>
          If the index is a list of numbers (no sublists), then item of
          reports a list of the indicated top-level items (rows, in a
          matrix; a straightforward hyperization): <inlinemediaobject>
            <imageobject>
              <imagedata fileref="media/image624.png" width="6.00694in" depth="0.86806in" />
            </imageobject>
            <textobject>
              <phrase>Macintosh HD:Users:bh:Desktop:item-vector.png</phrase>
            </textobject>
          </inlinemediaobject>
        </para>
      </listitem>
      <listitem>
        <para>
          If the index is a list of lists of numbers, then item of
          reports an array of only those scalars whose position in the
          list input matches the index input in all dimensions (changed
          in Snap<emphasis>!</emphasis> 6.6!):<inlinemediaobject>
            <imageobject>
              <imagedata fileref="media/image625.png" width="6.00694in" depth="0.6875in" />
            </imageobject>
          </inlinemediaobject>
        </para>
      </listitem>
      <listitem>
        <para>
          If a list of list of numbers includes an empty sublist, then
          all items are chosen along that dimension:<inlinemediaobject>
            <imageobject>
              <imagedata fileref="media/image626.png" width="6.00694in" depth="0.6875in" />
            </imageobject>
          </inlinemediaobject>
        </para>
      </listitem>
    </orderedlist>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image627.png" width="6.60417in" depth="1.04861in" />
        </imageobject>
        <textobject>
          <phrase>Graphical user interface, application, website Description automatically generated</phrase>
        </textobject>
      </inlinemediaobject>To get a column or columns of a spreadsheet,
      use an empty list in the row selector (changed in
      Snap<emphasis>!</emphasis> 6.6!):
    </para>
    <para>
      The length of block is extended to provide various ways of looking
      at the shape and contents of a list. The options other than length
      are mainly useful for <emphasis>lists of lists,</emphasis> to any
      depth. These new options work well with hyperblocks and the APL
      library. (Examples are on the next page.)
    </para>
    <para>
      length: reports the number of (toplevel) items in the list, as
      always.
    </para>
    <para>
      rank: reports the number of <emphasis>dimensions</emphasis> of the
      list, i.e., the maximum depth of lists of lists of lists of lists.
      (That example would be rank 4.)
    </para>
    <para>
      dimensions: reports a list of numbers, each of which is the
      maximum length in one dimension, so a spreadsheet of 1000 records,
      each with 4 fields, would report the list [1000 4].
    </para>
    <para>
      flatten: reports a flat, one-dimensional list containing the
      <emphasis>atomic</emphasis> (non-list) items anywhere in the input
      list.
    </para>
    <para>
      columns: reports a list in which the rows and columns of the input
      list are interchanged, so the shape of the transpose of a shape
      [1000 4] list would be [4 1000]. This option works only for lists
      whose rank is at most 2. The name reflects the fact that the
      toplevel items of the reported table are the columns of the
      original table.
    </para>
    <para>
      reverse: reports a list in which the (toplevel) items of the input
      list are in reverse order.
    </para>
    <para>
      The remaining three options report a (generally multi-line) text
      string. The input list may not include any atomic (non-list) data
      other than text or numbers. The lines option is intended for use
      with rank-one lists of text strings; it reports a string in which
      each list item becomes a line of text. You can think of it as the
      opposite of the split by line block. The csv option
      (comma-separated values) is intended for rank-two lists that
      represent a spreadsheet or other tabular data. Each item of the
      input list should be a list of atoms; the block reports a text
      string in which each item of the big list becomes a line of text
      in which the items of that sublist are separated by commas. The
      json option is for lists of any rank; it reports a text string in
      which the list structure is explicitly represented using square
      brackets. These are the opposites of split by csv and split by
      json.
    </para>
    <para>
      input
    </para>
    <para>
      The idea of extending the domain and range of scalar functions to
      include arrays comes from the language APL. (All the great
      programming languages are based on mathematical ideas. Our primary
      ancestors are Smalltalk, based on models, and Lisp, based on
      lambda calculus. Prolog, a great language not (so far) influencing
      Snap<emphasis>!</emphasis>, is based on logic. And APL, now
      joining our family, is based on linear algebra, which studies
      vectors and matrices. Those <emphasis>other</emphasis> programming
      languages are based on the weaknesses of computer hardware.)
      Hyperblocks are not the whole story about APL, which also has
      mixed-domain functions and higher order functions. Some of what’s
      missing is provided in the APL library. (See Appendix B.)
    </para>
  </section>
</section>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="typed-inputs">
  <title>
  Typed Inputs</title>
  <section xml:id="scratchs-type-notation">
    <title> Scratch’s Type Notation</title>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image654.png" width="1.375in" depth="0.2125in" />
        </imageobject>
      </inlinemediaobject>Prior to version 3, Scratch block inputs came
      in two types: Text-or-number type and Number type. The former is
      indicated by a rectangular box, the latter by a rounded box: . A
      third Scratch type, Boolean (true/false), can be used in certain
      Control blocks with hexagonal slots.
    </para>
    <para>
      The Snap<emphasis>!</emphasis> types are an expanded collection
      including Procedure, List, and Object types. Note that, with the
      exception of Procedure types, all of the input type shapes are
      just reminders to the user of what the block expects; they are not
      enforced by the language.
    </para>
  </section>
  <section xml:id="the-snap-input-type-dialog">
    <title>The Snap<emphasis>!</emphasis> Input Type Dialog</title>
    <para>
      In the Block Editor input name dialog, there is a right-facing
      arrowhead after the “Input name” option:
    </para>
    <para>
      Clicking that arrowhead opens the “long” input name dialog:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image657.png" width="5.17083in" depth="4.13542in" />
        </imageobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image658.png" width="0.19792in" depth="0.19792in" />
        </imageobject>
      </inlinemediaobject>There are twelve input type shapes, plus three
      mutually exclusive modifiers, listed in addition to the basic
      choice between title text and an input name. The default type, the
      one you get if you don’t choose anything else, is “Any,” meaning
      that this input slot is meant to accept any value of any type. If
      the size input in your block should be an oval-shaped numeric slot
      rather than a generic rectangle, click “Number.”
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image659.png" width="6.82222in" depth="2.75694in" />
        </imageobject>
      </inlinemediaobject>The arrangement of the input types is
      systematic. As the pictures on this and the next page show, each
      row of types is a category, and parts of each column form a
      category. Understanding the arrangement will make it a little
      easier to find the type you want.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image658.png" width="0.13194in" depth="0.13194in" />
        </imageobject>
      </inlinemediaobject>The second row of input types contains the
      ones found in Scratch: Number, Any, and Boolean. (The reason these
      are in the second row rather than the ﬁrst will become clear when
      we look at the column arrangement.) The ﬁrst row contains the new
      Snap<emphasis>!</emphasis> types other than procedures: Object,
      Text, and List. The last two rows are the types related to
      procedures, discussed more fully below.
    </para>
    <para>
      The List type is used for ﬁrst class lists, discussed in Chapter
      IV above. The red rectangles inside the input slot are meant to
      resemble the appearance of lists as Snap<emphasis>!</emphasis>
      displays them on the stage: each element in a red rectangle.
    </para>
    <para>
      The Object type is for sprites, costumes, sounds, and similar data
      types.
    </para>
    <para>
      The Text type is really just a variant form of the Any type, using
      a shape that suggests a text input.<footnote>
        <para>
          In Scratch, every block that takes a Text-type input has a
          default value that makes the rectangles for text wider than
          tall. The blocks that aren’t specifically about text either
          are of Number type or have no default value, so those
          rectangles are taller than wide. At ﬁrst some of us (bh)
          thought that Text was a separate type that always had a wide
          input slot; it turns out that this isn’t true in Scratch
          (delete the default text and the rectangle narrows), but we
          thought it a good idea anyway, so we allow Text-shaped boxes
          even for empty input slots. (This is why Text comes just above
          Any in the input type selection box.)
        </para>
      </footnote>
    </para>
    <section xml:id="procedure-types">
      <title>Procedure Types</title>
      <para>
        Although the procedure types are discussed more fully later,
        they are the key to understanding the column arrangement in the
        input types. Like Scratch, Snap<emphasis>!</emphasis> has three
        block shapes: jigsaw-piece for command blocks, oval for
        reporters, and hexagonal for predicates. (A
        <emphasis>predicate</emphasis> is a reporter that always reports
        true or false.) In Snap<emphasis>!</emphasis> these blocks are
        ﬁrst class data; an input to a block can be of Command type,
        Reporter type, or Predicate type. Each of these types is
        directly below the type of value that that kind of block
        reports, except for Commands, which don’t report a value at all.
        Thus, oval Reporters are related to the Any type, while
        hexagonal Predicates are related to the Boolean (true or false)
        type.
      </para>
      <para>
        The unevaluated procedure types in the fourth row are explained
        in Section VI.E below. In one handwavy sentence, they combine
        the <emphasis>meaning</emphasis> of the procedure types with the
        <emphasis>appearance</emphasis> of the reported value types two
        rows higher. (Of course, this isn’t quite right for the C-shaped
        command input type, since commands don’t <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image660.png" width="3.64583in" depth="3.11389in" />
          </imageobject>
        </inlinemediaobject>report values. But you’ll see later that
        it’s true in spirit.)
      </para>
    </section>
    <section xml:id="macintosh-hdusersbhdesktopgear-part.pngpulldown-inputs">
      <title><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image658.png" width="0.13194in" depth="0.13194in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:gear-part.png</phrase>
        </textobject>
      </inlinemediaobject>Pulldown inputs</title>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image661.png" width="1.68056in" depth="0.94097in" />
          </imageobject>
        </inlinemediaobject>Certain primitive blocks have
        <emphasis>pulldown</emphasis> inputs, either
        <emphasis>read-only,</emphasis> like the input to the touching
        block:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image662.png" width="1.90208in" depth="1.32292in" />
          </imageobject>
        </inlinemediaobject>(indicated by the input slot being the same
        (cyan, in this case) color as the body of the block), or
        <emphasis>writeable,</emphasis> like the input to the point in
        direction block:
      </para>
      <para>
        (indicated by the white input slot), which means that the user
        can type in an arbitrary input instead of using the pulldown
        menu.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image663.png" width="0.83264in" depth="0.65278in" />
          </imageobject>
        </inlinemediaobject><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image658.png" width="0.13194in" depth="0.13194in" />
          </imageobject>
          <textobject>
            <phrase>Macintosh HD:Users:bh:Desktop:gear-part.png</phrase>
          </textobject>
        </inlinemediaobject>Custom blocks can also have such inputs. To
        make a pulldown input, open the long form input dialog, choose a
        text type (Any, Text, or Number) and click the icon in the
        bottom right corner, or control/right-click in the dialog. You
        will see this menu:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image664.png" width="3.07639in" depth="1.875in" />
          </imageobject>
        </inlinemediaobject>Click the read-only checkbox if you want a
        read-only pulldown input. Then from the same menu, choose
        options… to get this dialog box:
      </para>
      <para>
        Each line in the text box represents one menu item. If the line
        does not contain any of the characters =~{} then the text is
        both what’s shown in the menu and the value of the input if that
        entry is chosen.
      </para>
      <para>
        If the line contains an equal sign =, then the text to the left
        of the equal sign is shown in the menu, and the text to the
        right is what appears in the input slot if that entry is chosen,
        and is also the value of the input as seen by the procedure.
      </para>
      <para>
        If the line consists of a tilde ~, then it represents a
        separator (a horizontal line) in the menu, used to divide long
        menus into visible categories. There should be nothing else on
        the line. This separator is not choosable, so there is no input
        value corresponding to it.
      </para>
      <para>
        If the line ends with the two characters equal sign and open
        brace ={, then it represents a <emphasis>submenu.</emphasis> The
        text before the equal sign is a name for the submenu, and will
        be displayed in the menu with an arrowhead ► at the end of the
        line. This line is not clickable, but hovering the mouse over it
        displays the submenu next to the original menu. A line
        containing a close brace } ends the submenu; nothing else should
        be on that line. Submenus may be nested to arbitrary depth.
      </para>
    </section>
    <section xml:id="section-3">
      <title></title>
<literallayout>Alternatively, instead of giving a menu listing as described above, you can put a JavaScript function that returns the desired menu in the textbox. This is an experimental feature and requires that JavaScript be enabled in the Settings menu.
It is also possible to get the special menus used in some primitive blocks, by choosing from the menu submenu: broadcast messages, sprites and stage, costumes, sounds, variables that can be set in this scope, the play note piano keyboard, or the point in direction 360° dial. Finally, you can make the input box accept more than one line of text (that is, text including a newline character) from the special submenu, either “multi-line” for regular <inlinemediaobject>
<imageobject>
<imagedata fileref="media/image669.png" width="0.60417in" depth="0.31944in" />
</imageobject>
<textobject>
<phrase>Macintosh HD:Users:bh:Desktop:little-options.png</phrase>
</textobject>
</inlinemediaobject>text or “code” for monospace-font computer code.</literallayout>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image670.png" width="0.13056in" depth="0.1375in" />
          </imageobject>
          <textobject>
            <phrase>Macintosh HD:Users:bh:Desktop:quarter-gear.png</phrase>
          </textobject>
        </inlinemediaobject><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image671.png" width="1.68056in" depth="0.25694in" />
          </imageobject>
          <textobject>
            <phrase>Macintosh HD:Users:bh:Desktop:Untitled script pic (1).png</phrase>
          </textobject>
        </inlinemediaobject>If the input type is something other than
        text, then clicking the button will instead show this menu:
      </para>
      <para>
        As an example, we want to make this block: The second input must
        be a read-only object menu:
      </para>
      <para>
        the move (10) steps block. In the prototype block input at the
        top of the script in the Block Editor, an input with name “size”
        and default value 10 looks like this:
      </para>
      <para>
        The “single input” option: In Scratch, all inputs are in this
        category. There is one input slot in the block as it appears in
        its palette. If a single input is of type Any, Number, Text, or
        Boolean, then you can specify a default value that will be shown
        in that slot in the palette, like the “10” in the move (10)
        steps block. In the prototype block at the top of the script in
        the Block editor, an
      </para>
    </section>
    <section xml:id="input-variants" role="unnumbered">
      <title>Input variants</title>
      <para>
        We now turn to the three mutually exclusive options that come
        below the type array.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image678.png" width="1.63889in" depth="0.52083in" />
          </imageobject>
          <textobject>
            <phrase>Macintosh HD:Users:bh:Desktop:default-value.png</phrase>
          </textobject>
        </inlinemediaobject>
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image679.png" width="1.76389in" depth="0.93056in" />
          </imageobject>
        </inlinemediaobject><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image680.png" width="3.56944in" depth="1.29444in" />
          </imageobject>
        </inlinemediaobject>The “Multiple inputs” option: The list block
        introduced earlier accepts any number of inputs to specify the
        items of the new list. To allow this, Snap<emphasis>!</emphasis>
        introduces the arrowhead notation (⏴⏵) that expands and
        contracts the block, adding and removing input slots.
        (Shift-clicking on an arrowhead adds or removes three input
        slots at once.) Custom blocks made by the
        Snap<emphasis>!</emphasis> user have that capability, too. If
        you choose the “Multiple inputs” button, then arrowheads will
        appear after the input slot in the block. More or fewer slots
        (as few as zero) may be used. When the block runs, all of the
        values in all of the slots for this input name are collected
        into a list, and the value of the input as seen inside the
        script is that list of values:
      </para>
      <para>
        The ellipsis (…) in the orange input slot name box in the
        prototype indicates a multiple or <emphasis>variadic</emphasis>
        input.
      </para>
      <para>
        The third category, “Upvar - make internal variable visible to
        caller,” isn’t really an input at all, but rather a sort of
        output from the block to its user. It appears as an orange
        variable oval in the block, rather than as an input slot. Here’s
        an example; the uparrow (<emphasis role="strong">↑</emphasis>)
        in the prototype indicates this kind of internal variable name:
      </para>
      <para>
        ➜
      </para>
      <para>
        The variable i (in the block on the right above) can be dragged
        from the for block into the blocks used in its C-shaped command
        slot. Also, by clicking on the orange i, the user can change the
        name of the variable as seen in the calling script (although the
        name hasn’t changed inside the block’s definition). This kind of
        variable is called an <emphasis>upvar</emphasis> for short,
        because it is passed <emphasis>upward</emphasis> from the custom
        block to the script that uses it.
      </para>
      <para>
        Note about the example: for is a primitive block, but it doesn’t
        need to be. You’re about to see (next chapter) how it can be
        written in Snap<emphasis>!</emphasis>. Just give it a different
        name to avoid confusion, such as my for as above.
      </para>
    </section>
    <section xml:id="prototype-hints">
      <title>Prototype Hints</title>
      <para>
        We have mentioned three notations that can appear in an input
        slot in the prototype to remind you of what kind of input this
        is. Here is the complete list of such notations:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image685.png" width="0.73472in" depth="6.11806in" />
          </imageobject>
        </inlinemediaobject>= default value … multiple input ↑ upvar #
        number
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image686.png" width="0.16319in" depth="0.13542in" />
          </imageobject>
        </inlinemediaobject>λ procedure types ⫶ list ? Boolean object ¶
        multi-line text
      </para>
    </section>
    <section xml:id="title-text-and-symbols">
      <title>Title Text and Symbols</title>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image687.png" width="1.21875in" depth="0.23472in" />
          </imageobject>
        </inlinemediaobject>Some primitive blocks have symbols as part
        of the block name: . Custom blocks can use symbols too. In the
        Block Editor, click the plus sign in the prototype at the point
        where you want to insert the symbol. Then click the title text
        picture below the text box that’s expecting an input slot name.
        The dialog will then change to look like this:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image688.png" width="1.24444in" depth="0.26667in" />
          </imageobject>
        </inlinemediaobject><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image689.png" width="2.03472in" depth="1.26389in" />
          </imageobject>
        </inlinemediaobject>The important part to notice is the
        arrowhead that has appeared at the right end of the text box.
        Click it to see the menu shown here at the left.
      </para>
      <para>
        Choose one of the symbols. The result will have the symbol you
        want: The available symbols are, pretty much, the ones that are
        used in Snap<emphasis>!</emphasis> icons.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image690.png" width="2.03472in" depth="1.26389in" />
          </imageobject>
        </inlinemediaobject>But I’d like the arrow symbol bigger, and
        yellow, so I edit its name:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image691.png" width="1.19792in" depth="0.27083in" />
          </imageobject>
        </inlinemediaobject>This makes the symbol 1.5 times as big as
        the letters in the block text, using a color with red-green-blue
        values of 255-255-150 (each between 0 and 255). Here’s the
        result:
      </para>
      <para>
        The size and color controls can also be used with text:
        $foo-8-255-120-0 will make a huge orange “foo.”
      </para>
      <para>
        Note the last entry in the symbol menu: “new line.” This can be
        used in a block with many inputs to control where the text
        continues on another line, instead of letting
        Snap<emphasis>!</emphasis> choose the line break itself.
      </para>
    </section>
  </section>
</section>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="procedures-as-data">
  <title>Procedures as Data</title>
  <section xml:id="call-and-run">
    <title>Call and Run</title>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image692.png" width="3.67292in" depth="1.58333in" />
        </imageobject>
      </inlinemediaobject>In the for block example above, the input
      named action has been declared as type “Command (C-shaped)”;
      that’s why the finished block is C-shaped. But how does the block
      actually tell Snap<emphasis>!</emphasis> to carry out the commands
      inside the C-slot? Here is a simple version of the block script:
    </para>
    <para>
      This is simplified because it assumes, without checking, that the
      ending value is greater than the starting value; if not, the block
      should (depending on the designer’s purposes) either not run at
      all, or change the variable by −1 for each repetition instead of
      by 1.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image693.png" width="0.5in" depth="0.15625in" />
        </imageobject>
      </inlinemediaobject>The important part of this script is the run
      block near the end. This is a Snap<emphasis>!</emphasis> built-in
      command block that takes a Command-type value (a script) as its
      input, and carries out its instructions. (In this example, the
      value of the input is the script that the user puts in the C-slot
      of the my for block.) There is a similar call reporter block for
      invoking a Reporter or Predicate block. The call and run blocks
      are at the heart of Snap<emphasis>!</emphasis>’s ﬁrst class
      procedure feature; they allow scripts and blocks to be used as
      data—in this example, as an input to a block—and eventually
      carried out under control of the user’s program.
    </para>
    <para>
      Here’s another example, this time using a Reporter-type input in a
      map block (see page <link linkend="map">50</link>):
    </para>
    <para>
      Here we are calling the Reporter “multiply by 10” three times,
      once with each item of the given list as its input, and collecting
      the results as a list. (The reported list will always be the same
      length as the input list.) Note that the multiplication block has
      two inputs, but here we have specified a particular value for one
      of them (10), so the call block knows to use the input value given
      to it just to fill the other (empty) input slot in the
      multiplication block. In the my map definition, the input function
      is declared to be type Reporter, and data is of type List.
    </para>
    <section xml:id="callrun-with-inputs">
      <title>Call/Run with inputs</title>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image698.png" width="1.8125in" depth="0.20833in" />
          </imageobject>
        </inlinemediaobject>The call block (like the run block) has a
        right arrowhead at the end; clicking on it adds the phrase “with
        inputs” and then a slot into which an input can be inserted:
      </para>
      <para>
        If the left arrowhead is used to remove the last input slot, the
        “with inputs” disappears also. The right arrowhead can be
        clicked as many times as needed for the number of inputs
        required by the reporter block being called.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image699.png" width="2.72917in" depth="0.31806in" />
          </imageobject>
        </inlinemediaobject>If the number of inputs given to call (not
        counting the Reporter-type input that comes first) is the same
        as the number of empty input slots, then the empty slots are
        filled from left to right with the given input values. If call
        is given exactly one input, then <emphasis>every</emphasis>
        empty input slot of the called block is filled with the same
        value:
      </para>
      <para>
        If the number of inputs provided is neither one nor the number
        of empty slots, then there is no automatic filling of empty
        slots. (Instead you must use explicit parameters in the ring, as
        discussed in Section C below.)
      </para>
      <para>
        An even more important thing to notice about these examples is
        the <emphasis>ring</emphasis> around the Reporter-type input
        slots in call and map above. This notation indicates that
        <emphasis>the block itself,</emphasis> not the number or other
        value that the block would report when called, is the input. If
        you want to use a block itself in a non-Reporter-type (e.g.,
        Any-type) input slot, you can enclose it explicitly in a ring,
        found at the top of the Operators palette.
      </para>
      <para>
        As a shortcut, if you right-click or control-click on a block
        (such as the + block in this example), one of the choices in the
        menu that appears is “ringify” and/or “unringify.” The ring
        indicating a Reporter-type or Predicate-type input slot is
        essentially the same idea for reporters as the C-shaped input
        slot with which you’re already familiar; with a C-shaped slot,
        it’s <emphasis>the script</emphasis> you put in the slot that
        becomes the input to the C-shaped block.
      </para>
      <para>
        There are three ring shapes. All are oval on the outside,
        indicating that the ring reports a value, the block or script
        inside it, but the inside shapes are command, reporter, or
        predicate, indicating what kind of block or script is expected.
        Sometimes you want to put something more complicated than a
        single reporter inside a reporter ring; if so, you can use a
        script, but the script must report a value, as in a custom
        reporter definition.
      </para>
    </section>
    <section xml:id="variables-in-ring-slots">
      <title>Variables in Ring Slots</title>
      <para>
        Note that the run block in the definition of the my for block
        (page <link linkend="call-and-run">65</link>) doesn’t have a
        ring around its input variable action. When you drag a variable
        into a ringed input slot, you generally <emphasis>do</emphasis>
        want to use <emphasis>the value of</emphasis> the variable,
        which will be the block or script you’re trying to run or call,
        rather than the orange variable reporter itself. So
        Snap<emphasis>!</emphasis> automatically removes the ring in
        this case. If you ever do want to use the variable
        <emphasis>block itself,</emphasis> rather than the value of the
        variable, as a Procedure-type input, you can drag the variable
        into the input slot, then control-click or right-click it and
        choose “ringify” from the menu that appears. (Similarly, if you
        ever want to call a function that will report a block to use as
        the input, such as item 1 of applied to a list <emphasis>of
        blocks,</emphasis> you can choose “unringify” from the menu.
        Almost all the time, though, Snap<emphasis>!</emphasis> does
        what you mean without help.)
      </para>
    </section>
  </section>
  <section xml:id="writing-higher-order-procedures">
    <title>Writing Higher Order Procedures</title>
    <para>
      A <emphasis>higher order procedure</emphasis> is one that takes
      another procedure as an input, or that reports a procedure. In
      this document, the word “procedure” encompasses scripts,
      individual blocks, and nested reporters. (Unless specified
      otherwise, “reporter” includes predicates. When the word is
      capitalized inside a sentence, it means specifically oval-shaped
      blocks. So, “nested reporters” includes predicates, but “a
      Reporter-type input” doesn’t.)
    </para>
    <para>
      Although an Any-type input slot (what you get if you use the small
      input-name dialog box) will accept a procedure input, it doesn’t
      automatically ring the input as described above. So the
      declaration of Procedure-type inputs makes the use of your custom
      higher order block much more convenient.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image708.png" width="2.375in" depth="1.35417in" />
        </imageobject>
      </inlinemediaobject>Why would you want a block to take a procedure
      as input? This is actually not an obscure thing to do; the
      primitive conditional and looping blocks (the C-shaped ones in the
      Control palette) take a script as input. Users just don’t usually
      think about it in those terms! We could write the repeat block as
      a custom block this way, if Snap<emphasis>!</emphasis> didn’t
      already have one:
    </para>
    <para>
      The lambda (λ) next to action in the prototype indicates that this
      is a C-shaped block, and that the script enclosed by the C when
      the block is used is the input named action in the body of the
      script. The only way to make sense of the variable action is to
      understand that its value is a script.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image509.png" width="2.58333in" depth="1.60417in" />
        </imageobject>
      </inlinemediaobject>To declare an input to be Procedure-type, open
      the input name dialog as usual, and click on the arrowhead:
    </para>
    <para>
      Then, in the long dialog, choose the appropriate Procedure type.
      The third row of input types has a ring in the shape of each block
      type (jigsaw for Commands, oval for Reporters, and hexagonal for
      Predicates). In practice, though, in the case of Commands it’s
      more common to choose the C-shaped slot on the fourth row, because
      this “container” for command scripts is familiar to Scratch users.
      Technically the C-shaped slot is an
      <emphasis>unevaluated</emphasis> procedure type, something
      discussed in Section E below. The two Command-related input types
      (inline and C-shaped) are connected by the fact that if a
      variable, an item (#) of [list] block, or a custom Reporter block
      is dropped onto a C-shaped slot of a custom block, it turns into
      an inline slot, as in the repeater block’s recursive call above.
      (Other built-in Reporters can’t report scripts, so they aren’t
      accepted in a C-shaped slot.)
    </para>
<literallayout><inlinemediaobject>
<imageobject>
<imagedata fileref="media/image658.png" width="0.19792in" depth="0.19792in" />
</imageobject>
<textobject>
<phrase>Macintosh HD:Users:bh:Desktop:gear-part.png</phrase>
</textobject>
</inlinemediaobject><inlinemediaobject>
<imageobject>
<imagedata fileref="media/image709.png" width="3.65278in" depth="2.75455in" />
</imageobject>
</inlinemediaobject>
Why would you ever choose an inline Command slot rather than a C shape? Other than the run block <inlinemediaobject>
<imageobject>
<imagedata fileref="media/image710.png" width="2.11458in" depth="0.46875in" />
</imageobject>
</inlinemediaobject>discussed below, the only case I can think of is something like the C/C++/Java for loop, which actually has <emphasis>three</emphasis> command script inputs (and one predicate input), only one of which is the “featured” loop body:</literallayout>
    <para>
      Okay, now that we have procedures as inputs to our blocks, how do
      we use them? We use the blocks run (for commands) and call (for
      reporters). The run block’s script input is an inline ring, not
      C-shaped, because we anticipate that it will be rare to use a
      specific, literal script as the input. Instead, the input will
      generally be a variable whose <emphasis>value</emphasis> is a
      script.
    </para>
    <para>
      The run and call blocks have arrowheads at the end that can be
      used to open slots for inputs to the called procedures. How does
      Snap<emphasis>!</emphasis> know where to use those inputs? If the
      called procedure (block or script) has empty input slots,
      Snap<emphasis>!</emphasis> “does the right thing.” This has
      several possible meanings:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image711.png" width="3.44792in" depth="0.34406in" />
        </imageobject>
      </inlinemediaobject>1. If the number of empty slots is exactly
      equal to the number of inputs provided, then
      Snap<emphasis>!</emphasis> fills the empty slots from left to
      right:
    </para>
    <para>
      2. If exactly one input is provided, Snap<emphasis>!</emphasis>
      will fill any number of empty slots with it:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image712.png" width="2.80208in" depth="0.30694in" />
        </imageobject>
      </inlinemediaobject>
    </para>
    <para>
      3. Otherwise, Snap<emphasis>!</emphasis> won’t fill any slots,
      because the user’s intention is unclear.
    </para>
    <para>
      If the user wants to override these rules, the solution is to use
      a ring with explicit input names that can be put into the given
      block or script to indicate how inputs are to be used. This will
      be discussed more fully below.
    </para>
    <section xml:id="recursive-calls-to-multiple-input-blocks">
      <title>Recursive Calls to Multiple-Input Blocks</title>
      <para>
        A relatively rare situation not yet considered here is the case
        of a recursive block that has a variable number of inputs. Let’s
        say the user of your project calls your block with five inputs
        one time, and 87 inputs another time. How do you write the
        recursive call to your block when you don’t know how many inputs
        to give it? The answer is that you collect the inputs in a list
        (recall that, when you declare an input name to represent a
        variable number of inputs, your block sees those inputs as a
        list of values in the first place), and then, in the recursive
        call, you drop that input list <emphasis>onto the
        arrowheads</emphasis> that indicate a variable-input slot,
        rather than onto the input slot:
      </para>
<literallayout><inlinemediaobject>
<imageobject>
<imagedata fileref="media/image658.png" width="0.13194in" depth="0.13194in" />
</imageobject>
<textobject>
<phrase>Macintosh HD:Users:bh:Desktop:gear-part.png</phrase>
</textobject>
</inlinemediaobject><inlinemediaobject>
<imageobject>
<imagedata fileref="media/image713.png" width="2.50139in" depth="1.94444in" />
</imageobject>
</inlinemediaobject><inlinemediaobject>
<imageobject>
<imagedata fileref="media/image714.png" width="2.225in" depth="1.17083in" />
</imageobject>
</inlinemediaobject><inlinemediaobject>
<imageobject>
<imagedata fileref="media/image715.png" width="2.27569in" depth="1.59722in" />
</imageobject>
</inlinemediaobject>
Note that the halo you see while dragging onto the arrowheads is red instead of white, and covers the input slot as well as the arrowheads. And when you drop the expression onto the arrowheads, the words “input list:” are added to the block text and the arrowheads disappear (in this invocation only) to remind you that the list represents all of the multiple inputs, not just a single input. The items in the list are taken <emphasis>individually</emphasis> as inputs to the script. Since numbers is a list of numbers, each individual item is a number, just what sizes wants. This block will take any number of numbers as inputs, and will make the sprite grow and shrink accordingly:</literallayout>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image722.png" width="2.95833in" depth="0.6875in" />
          </imageobject>
        </inlinemediaobject>The user of this block calls it with any
        number of <emphasis>individual numbers</emphasis> as inputs. But
        inside the definition of the block, all of those numbers form
        <emphasis>a</emphasis> <emphasis>list</emphasis> that has a
        single input name, numbers. This recursive definition ﬁrst
        checks to make sure there are any inputs at all. If so, it
        processes the ﬁrst input (item 1 of the list), then it wants to
        make a recursive call with all but the ﬁrst number. But sizes
        doesn’t take a list as input; it takes numbers as inputs! So
        this would be wrong:
      </para>
    </section>
  </section>
  <section xml:id="formal-parameters">
    <title>Formal Parameters</title>
    <para>
      The rings around Procedure-type inputs have an arrowhead at the
      right. Clicking the arrowhead allows you to give the inputs to a
      block or script explicit names, instead of using empty input slots
      as we’ve done until now.
    </para>
    <para>
      The names #1, #2, etc. are provided by default, but you can change
      a name by clicking on its orange oval in the input names list. Be
      careful not to <emphasis>drag</emphasis> the oval when clicking;
      that’s how you use the input inside the ring. The names of the
      input variables are called the <emphasis>formal
      parameters</emphasis> of the encapsulated procedure.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image731.png" width="4.32292in" depth="0.45417in" />
        </imageobject>
      </inlinemediaobject>Here’s a simple but contrived example using
      explicit names to control which input goes where inside the ring:
    </para>
    <para>
      Here we just want to put one of the inputs into two different
      slots. If we left all three slots empty,
      Snap<emphasis>!</emphasis> would not fill any of them, because the
      number of inputs provided (2) would not match the number of empty
      slots (3).
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image732.png" width="4.67986in" depth="3.01806in" />
        </imageobject>
      </inlinemediaobject>Here is a more realistic, much more advanced
      example:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image733.png" width="4.34722in" depth="1.40278in" />
        </imageobject>
      </inlinemediaobject>
    </para>
    <para>
      This is the definition of a block that takes any number of lists,
      and reports the list of all possible combinations of one item from
      each list. The important part for this discussion is that near the
      bottom there are two <emphasis>nested</emphasis> calls to map, the
      higher order function that applies an input function to each item
      of an input list. In the inner block, the function being mapped is
      in front of, and that block takes two inputs. The second, the
      empty List-type slot, will get its value in each call from an item
      of the inner map’s list input. But there is no way for the outer
      map to communicate values to empty slots of the in front of block.
      We must give an explicit name, newitem, to the value that the
      outer map is giving to the inner one, then drag that variable into
      the in front of block.
    </para>
    <para>
      By the way, once the called block provides names for its inputs,
      Snap<emphasis>!</emphasis> will not automatically fill empty
      slots, on the theory that the user has taken control. In fact,
      that’s another reason you might want to name the inputs
      explicitly: to stop Snap<emphasis>!</emphasis> from filling a slot
      that should really remain empty.
    </para>
  </section>
  <section xml:id="procedures-as-data-1">
    <title>Procedures as Data</title>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image734.png" width="5.1875in" depth="1.65625in" />
        </imageobject>
      </inlinemediaobject>Here’s an example of a situation in which a
      procedure must be explicitly marked as data by pulling a ring from
      the Operators palette and putting the procedure (block or script)
      inside it:
    </para>
    <para>
      Here, we are making a list of procedures. But the list block
      accepts inputs of any type, so its input slots are not ringed. We
      must say explicitly that we want the block
      <emphasis>itself</emphasis> as the input, rather than whatever
      value would result from evaluating the block.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image735.png" width="3.83333in" depth="0.84375in" />
        </imageobject>
      </inlinemediaobject>Besides the list block in the example above,
      other blocks into which you may want to put procedures are set (to
      set the value of a variable to a procedure), say and think (to
      display a procedure to the user), and report (for a reporter that
      reports a procedure):
    </para>
  </section>
  <section xml:id="special-forms">
    <title>Special Forms</title>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image736.png" width="2.49931in" depth="0.27847in" />
        </imageobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image737.png" width="2.40208in" depth="1.42708in" />
        </imageobject>
      </inlinemediaobject>The primitive if else block has two C-shaped
      command slots and chooses one or the other depending on a Boolean
      test. Because Scratch doesn’t emphasize functional programming, it
      lacks a corresponding reporter block to choose between two
      expressions. Snap<emphasis>!</emphasis> has one, but we could
      write our own:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image738.png" width="4.29167in" depth="0.84861in" />
        </imageobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image739.png" width="3.81899in" depth="0.27433in" />
        </imageobject>
      </inlinemediaobject>Our block works for these simple examples, but
      if we try to use it in writing a recursive operator, it’ll fail:
    </para>
    <para>
      The problem is that when any block is called, all of its inputs
      are computed (evaluated) before the block itself runs. The block
      itself knows only the values of its inputs, not what expressions
      were used to compute them. In particular, all of the inputs to our
      if then else block are evaluated ﬁrst thing. That means that even
      in the base case, factorial will try to call itself recursively,
      causing an infinite loop. We need our if then else block to be
      able to select only one of the two alternatives to be evaluated.
    </para>
    <para>
      We have a mechanism to allow that: declare the then and else
      inputs to be of type Reporter rather than type Any. Then, when
      calling the block, those inputs will be enclosed in a ring so that
      the expressions themselves, rather than their values, become the
      inputs:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image740.png" width="1.11458in" depth="0.69792in" />
        </imageobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image741.png" width="4.52083in" depth="1.02292in" />
        </imageobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image742.png" width="2.61736in" depth="1.51042in" />
        </imageobject>
      </inlinemediaobject>
    </para>
    <para>
      In this version, the program works, with no infinite loop. But
      we’ve paid a heavy price: this reporter-if is no longer as
      intuitively obvious as the Scratch command-if. You have to know
      about procedures as data, about rings, and about a trick to get a
      constant value in a ringed slot. (The id block implements the
      identity function, which reports its input.<footnote>
        <para>
          There is a primitive id function in the menu of the sqrt of
          block, but we think seeing its (very simple) implementation
          will make this example easier to understand.
        </para>
      </footnote> We need it because rings take only reporters as input,
      not numbers.) What we’d like is a reporter-if that
      <emphasis>behaves</emphasis> like this one, delaying the
      evaluation of its inputs, but <emphasis>looks</emphasis> like our
      ﬁrst version, which was easy to use except that it didn’t work.
    </para>
    <para>
      Such blocks are indeed possible. A block that seems to take a
      simple expression as input, but delays the evaluation of that
      input by wrapping an “invisible ring” around it (and, if
      necessary, an id-like transformation of constant data into
      constant functions) is called a <emphasis>special form</emphasis>.
      To turn our if block into a special form, we edit the block’s
      prototype, declaring the inputs yes and no to be of type “Any
      (unevaluated)” instead of type Reporter. The script for the block
      is still that of the second version, including the use of call to
      evaluate either yes or no but not both. But the slots appear as
      white Any-type rectangles, not Reporter-type rings, and the
      factorial block will look like our ﬁrst attempt.
    </para>
    <para>
      In a special form’s prototype, the unevaluated input slot(s) are
      indicated by a lambda (λ) next to the input name, just as if they
      were declared as Procedure type. They <emphasis>are</emphasis>
      Procedure type, really; they’re just disguised to the user of the
      block.
    </para>
    <para>
      Special forms trade off implementor sophistication for user
      sophistication. That is, you have to understand all about
      procedures as data to make sense of the special form
      implementation of my if then else. But any experienced Scratch
      programmer can <emphasis>use</emphasis> my if then else without
      thinking at all about how it works internally.
    </para>
    <section xml:id="special-forms-in-scratch">
      <title>Special Forms in Scratch</title>
      <para>
        Special forms are actually not a new invention in
        Snap<emphasis>!</emphasis>. Many of Scratch’s conditional and
        looping blocks are really special forms. The hexagonal input
        slot in the if block is a straightforward Boolean value, because
        the value can be computed once, before the if block makes its
        decision about whether or not to run its action input. But the
        forever if, repeat until, and wait until blocks’ inputs can’t be
        Booleans; they have to be of type “Boolean (unevaluated),” so
        that Scratch can evaluate them over and over again. Since
        Scratch doesn’t have custom C‑shaped blocks, it can afford to
        handwave away the distinction between evaluated and unevaluated
        Booleans, but Snap<emphasis>!</emphasis> can’t. The pedagogic
        value of special forms is proven by the fact that no Scratcher
        ever notices that there’s anything strange about the way in
        which the hexagonal inputs in the Control blocks are evaluated.
      </para>
      <para>
        Also, the C-shaped slot familiar to Scratch users is an
        unevaluated procedure type; you don’t have to use a ring to keep
        the commands in the C-slot from being run before the C-shaped
        block is run. Those commands themselves, not the result of
        running them, are the input to the C-shaped Control block. (This
        is taken for granted by Scratch users, especially because
        Scratchers don’t think of the contents of a C-slot as an input
        at all.) This is why it makes sense that “C‑shaped” is on the
        fourth row of types in the long form input dialog, with other
        unevaluated types.
      </para>
    </section>
  </section>
</section>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="object-oriented-programming-with-sprites">
  <title>
  Object Oriented Programming with Sprites</title>
  <para>
    Object oriented programming is a style based around the abstraction
    <emphasis>object:</emphasis> a collection of
    <emphasis>data</emphasis> and <emphasis>methods</emphasis>
    (procedures, which from our point of view are just more data) that
    you interact with by sending it a <emphasis>message</emphasis> (just
    a name, maybe in the form of a text string, and perhaps additional
    inputs). The object responds to the message by carrying out a
    method, which may or may not report a value back to the asker. Some
    people emphasize the <emphasis>data hiding</emphasis> aspect of OOP
    (because each object has local variables that other objects can
    access only by sending request messages to the owning object) while
    others emphasize the <emphasis>simulation</emphasis> aspect (in
    which each object abstractly represents something in the world, and
    the interactions of objects in the program model real interactions
    of real people or things). Data hiding is important for large
    multi-programmer industrial projects, but for
    Snap<emphasis>!</emphasis> users it’s the simulation aspect that’s
    important. Our approach is therefore less restrictive than that of
    some other OOP languages; we give objects easy access to each
    others’ data and methods.
  </para>
  <para>
    Technically, object oriented programming rests on three legs: (1)
    <emphasis>Message passing:</emphasis> There is a notation by which
    any object can send a message to another object. (2) <emphasis>Local
    state:</emphasis> Each object can remember the important past
    history of the computation it has performed. (“Important” means that
    it need not remember every message it has handled, but only the
    lasting effects of those messages that will affect later
    computation.) (3) <emphasis>Inheritance:</emphasis> It would be
    impractical if each individual object had to contain methods, many
    of them identical to those of other objects, for all of the messages
    it can accept. Instead, we need a way to say that this new object is
    just like that old object except for a few differences, so that only
    those differences need be programmed explicitly.
  </para>
  <section xml:id="first-class-sprites">
    <title> First Class Sprites</title>
    <para>
      Like Scratch, Snap<emphasis>!</emphasis> comes with things that
      are natural objects: its sprites. Each sprite can own local
      variables; each sprite has its own scripts (methods). A Scratch
      animation is plainly a simulation of the interaction of characters
      in a play. There are two ways in which Scratch sprites are less
      versatile than the objects of an OOP language. First, Scratch
      message passing is weak in three respects: Messages can only be
      broadcast, not addressed to an individual sprite; messages can’t
      take inputs; and methods can’t return values to their caller.
      Second, and more basic, in the OOP paradigm objects are
      <emphasis>data;</emphasis> they can be the value of a variable, an
      element of a list, and so on, but that’s not the case for Scratch
      sprites.
    </para>
    <para>
      Snap<emphasis>!</emphasis> sprites are ﬁrst class data. They can
      be created and deleted by a script, stored in a variable or list,
      and sent messages individually. The children of a sprite can
      inherit sprite-local variables, methods (sprite-local procedures),
      and other attributes (e.g., x position).
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image743.png" width="0.96528in" depth="0.19444in" />
        </imageobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image744.png" width="1.08333in" depth="0.19444in" />
        </imageobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image745.png" width="0.66667in" depth="0.19444in" />
        </imageobject>
      </inlinemediaobject>The fundamental means by which programs get
      access to sprites is the my reporter block. It has a dropdown-menu
      input slot that, when clicked, gives access to all the sprites,
      plus the stage. reports a single sprite, the one asking the
      question. reports a list of all sprites other than the one asking
      the question. reports a list of all sprites that are
      <emphasis>near</emphasis> the one asking—the ones that are
      candidates for having collided with this one, for example. The my
      block has many other options, discussed below. If you know the
      name of a particular sprite, the object reporter will report the
      sprite itself.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image746.png" width="3.55208in" depth="0.51042in" />
        </imageobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image747.png" width="2.69143in" depth="1.25in" />
        </imageobject>
        <textobject>
          <phrase>C:\Documents and Settings\bh\Desktop\Scratch002.png</phrase>
        </textobject>
      </inlinemediaobject>An object or list of objects reported by my or
      object can be used as input to any block that accepts any input
      type, such as set’s second input. If you say an object, the
      resulting speech balloon will contain a smaller image of the
      object’s costume or (for the stage) background.
    </para>
  </section>
  <section xml:id="permanent-and-temporary-clones">
    <title> Permanent and Temporary Clones</title>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image748.png" width="1.51389in" depth="0.19444in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:pix:clone-block.png</phrase>
        </textobject>
      </inlinemediaobject>The block is used to create and report an
      instance (a clone) of any sprite. (There is also a command
      version, for historical reasons.) There are two different kinds of
      situations in which clones are used. One is that you’ve made an
      example sprite and, when you start the project, you want a fairly
      large number of essentially identical sprites that behave like the
      example. (Hereafter we’ll call the example sprite the “parent” and
      the others the “children.”) Once the game or animation is over,
      you don’t need the copies any more. (As we’ll see, “copies” is the
      wrong word because the parent and the children
      <emphasis>share</emphasis> a lot of properties. That’s why we use
      the word “clones” to describe the children rather than “copies.”)
      These are <emphasis>temporary</emphasis> clones. They are
      automatically deleted when the user presses either the green flag
      or the red stop sign. In Scratch 2.0 and later, all clones are
      temporary.
    </para>
    <para>
      The other kind of situation is what happens when you want
      specializations of sprites. For example, let’s say you have a
      sprite named Dog. It has certain behaviors, such as running up to
      a person who comes near it. Now you decide that the family in your
      story really likes dogs, so they adopt a lot of them. Some are
      cocker spaniels, who wag their tails when they see you. Others are
      rottweilers, who growl at you when they see you. So you make a
      clone of Dog, perhaps rename it Cocker Spaniel, and give it a new
      costume and a script for what to do when someone gets near. You
      make another clone of Dog, perhaps rename it Rottweiler, and give
      it a new costume, etc. Then you make three clones of Cocker
      Spaniel (so there are four altogether) and two clones of
      Rottweiler. Maybe you hide the Dog sprite after all this, since
      it’s no breed in particular. Each dog has its own position,
      special behaviors, and so on. You want to save all of these dogs
      in the project. These are <emphasis>permanent</emphasis> clones.
      In BYOB 3.1, the predecessor to Snap<emphasis>!,</emphasis> all
      clones are permanent.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image748.png" width="1.51389in" depth="0.19444in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:pix:clone-block.png</phrase>
        </textobject>
      </inlinemediaobject>One advantage of temporary clones is that they
      don’t slow down Snap<emphasis>!</emphasis> even when you have a
      lot of them. (If you’re curious, one reason is that permanent
      clones appear in the sprite corral, where their pictures have to
      be updated to reflect the clone’s current costume, direction, and
      so on.) We have tried to anticipate your needs, as follows: When
      you make a clone in a script, using the block, it is “born”
      temporary. But when you make a clone from the user interface, for
      example by right-clicking on a sprite and choosing “clone,” it is
      born permanent. The reason this makes sense is that you don’t
      create 100 <emphasis>kinds</emphasis> of dogs automatically. Each
      kind has many different characteristics, programmed by hand. But
      when your project is running, it might create 100 rottweilers, and
      those will be identical unless you change them in the program.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image749.png" width="1.51389in" depth="0.25694in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:set-my-temp.png</phrase>
        </textobject>
      </inlinemediaobject>You can change a temporary sprite to permanent
      by right-clicking it and choosing “edit.” (It’s called “edit”
      rather than, say, “permanent” because it also shifts the scripting
      area to reflect that sprite, as if you’d pressed its button in the
      sprite corral.) You can change a permanent sprite to temporary by
      right-clicking it and choosing “release.” You can also change the
      status of a clone in your program with with true or false as the
      second input.
    </para>
  </section>
  <section xml:id="sending-messages-to-sprites">
    <title> Sending Messages to Sprites</title>
    <para>
      The messages that a sprite accepts are the blocks in its palettes,
      including both all-sprites and this-sprite-only blocks. (For
      custom blocks, the corresponding methods are the scripts as seen
      in the Block Editor.
    </para>
    <para>
      The way to send a message to a sprite (or the stage) is with the
      tell block (for command messages) or the ask block (for reporter
      messages).
    </para>
    <para>
      A small point to note in the examples above: all dropdown menus
      include an empty entry at the top, which can be selected for use
      in higher order procedures like the for each and map examples.
      Each of the sprites in my neighbors or my other sprites is used to
      fill the blank space in turn.
    </para>
    <para>
      By the way, if you want a list of <emphasis>all</emphasis> the
      sprites, including this sprite, you can use either of these:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image762.png" width="3.54514in" depth="0.82639in" />
        </imageobject>
      </inlinemediaobject>Tell and ask wait until the other sprite has
      carried out its method before this sprite’s script continues.
      (That has to be the case for ask, since we want to do something
      with the value it reports.) So tell is analogous to broadcast and
      wait. Sometimes the other sprite’s method may take a long time, or
      may even be a forever loop, so you want the originating script to
      continue without waiting. For this purpose we have the launch
      block:
    </para>
    <para>
      Launch is analogous to broadcast without the “wait.”
    </para>
    <para>
      Snap<emphasis>!</emphasis> 4.1, following BYOB 3.1, used an
      extension of the of block to provide access to other sprites’
      methods. That interface was designed back when we were trying hard
      to avoid adding new primitive blocks; it allowed us to write ask
      and tell as tool procedures in Snap<emphasis>!</emphasis> itself.
      That technique still works, but is deprecated, because nobody
      understood it, and now we have the more straightforward
      primitives.
    </para>
    <section xml:id="polymorphism">
      <title>Polymorphism</title>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image763.png" width="1.67361in" depth="1.40208in" />
          </imageobject>
        </inlinemediaobject>Suppose you have a Dog sprite with two
        clones CockerSpaniel and PitBull. In the Dog sprite you define
        this method (“For this sprite only” block):
      </para>
      <para>
        Note the <emphasis>loca</emphasis>tion (map-pin) symbol before
        the block’s name. The symbol is not part of the block title;
        it’s a visual reminder that this is a
        sprite-<emphasis>loca</emphasis>l block. Sprite-local variables
        are similarly marked.
      </para>
      <para>
        But you don’t define greet as friend or greet as enemy in Dog.
        Each kind of dog has a different behavior. Here’s what a
        CockerSpaniel does:
      </para>
      <para>
        And here’s what a PitBull does:
      </para>
      <para>
        Greet is defined in the Dog sprite. If Fido is a particular
        cocker spaniel, and you ask Fido to greet someone, Fido inherits
        the greet method from Dog, but Dog itself couldn’t actually run
        that method, because Dog doesn’t have greet as friend or greet
        as enemy. And perhaps only individual dogs such as Fido have
        friend? methods. Even though the greet method is defined in the
        Dog sprite, when it’s running it remembers what specific dog
        sprite called it, so it knows which greet as friend to use.
        Dog’s greet block is called a <emphasis>polymorphic</emphasis>
        method, because it means different things to different dogs,
        even though they all share the same script.
      </para>
    </section>
  </section>
  <section xml:id="local-state-in-sprites-variables-and-attributes">
    <title> Local State in Sprites: Variables and Attributes</title>
    <para>
      A sprite’s memory of its own past history takes two main forms. It
      has <emphasis>variables,</emphasis> created explicitly by the user
      with the “Make a variable” button; it also has
      <emphasis>attributes,</emphasis> the qualities every sprite has
      automatically, such as position, direction, and pen color. Each
      variable can be examined using its own orange oval block; there is
      one set block to modify all variables. Attributes, however, have a
      less uniform programming interface in Scratch:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          A sprite’s <emphasis>direction</emphasis> can be examined with
          the direction block, and modified with the point in direction
          block. It can also be modified less directly using the blocks
          turn, point towards, and if on edge, bounce.
        </para>
      </listitem>
      <listitem>
        <para>
          There is no way for a script to examine a sprite’s
          <emphasis>pen color,</emphasis> but there are blocks set pen
          color to &lt;color&gt;, set pen color to &lt;number&gt;, and
          change pen color to modify it.
        </para>
      </listitem>
      <listitem>
        <para>
          A sprite’s <emphasis>name</emphasis> can be neither examined
          nor modified by scripts; it can be modified by typing a new
          name directly into the box that displays the name, above the
          scripting area.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      The block, if any, that examines a variable or attribute is called
      its <emphasis>getter;</emphasis> a block (there may be more than
      one, as in the direction example above) that modifies a variable
      or attribute is called a <emphasis>setter.</emphasis>
    </para>
    <para>
      In Snap<emphasis>!</emphasis> we allow virtually all attributes to
      be examined. But instead of adding dozens of reporters, we use a
      more uniform interface for attributes: The my block’s menu (in
      Sensing; see page
      <link linkend="attrib.pnglist-of-attributes">78</link>) includes
      many of the attributes of a sprite. It serves as a general getter
      for those attributes, e.g., my [anchor] to find the sprite, if
      any, to which this sprite is attached in a nesting arrangement
      (see page
      <link linkend="nesting-sprites-anchors-and-parts">10</link>).
      Similarly, the same set block used to set variable values allows
      setting some sprite attributes.
    </para>
  </section>
  <section xml:id="prototyping-parents-and-children">
    <title> Prototyping: Parents and Children</title>
    <para>
      Most current OOP languages use a
      <emphasis>class/instance</emphasis> approach to creating objects.
      A class is a particular <emphasis>kind of object,</emphasis> and
      an instance is an <emphasis>actual object</emphasis> of that type.
      For example, there might be a Dog class, and several instances
      Fido, Spot, and Runt. The class typically specifies the methods
      shared by all dogs (RollOver, SitUpAndBeg, Fetch, and so on), and
      the instances contain data such as species, color, and
      friendliness. Snap<emphasis>!</emphasis> uses a different approach
      called <emphasis>prototyping,</emphasis> in which there is no
      distinction between classes and instances. Prototyping is better
      suited to an experimental, tinkering style of work: You make a
      single dog sprite, with both methods (blocks) and data
      (variables); you can actually watch it and interact with it on the
      stage; and when you like it, you use it as the prototype from
      which to clone other dogs. If you later discover a bug in the
      behavior of dogs, you can edit a method in the parent, and all of
      the children will automatically share the new version of the
      method block. Experienced class/instance programmers may find
      prototyping strange at first, but it is actually a more expressive
      system, because you can easily simulate a class/instance hierarchy
      by hiding the prototype sprite! Prototyping is also a better fit
      with the Scratch design principle that everything in a project
      should be concrete and visible on the stage; in class/instance OOP
      the programming process begins with an abstract, invisible entity,
      the class, that must be designed before any concrete objects can
      be made.<footnote>
        <para>
          Some languages popular in the “real world” today, such as
          JavaScript, claim to use prototyping, but their object system
          is much more complicated than what we are describing (we’re
          guessing it’s because they were designed by people too
          familiar with class/instance programming); that has, in some
          circles, given prototyping a bad name. Our prototyping design
          comes from Object Logo, and before that, from Henry Lieberman.
          [Lieberman, H., Using Prototypical Objects to Implement Shared
          Behavior in Object-Oriented Systems, First Conference on
          Object-Oriented Programming Languages, Systems, and
          Applications [OOPSLA-86], ACM SigCHI, Portland, OR, September,
          1986. Also in <emphasis>Object-Oriented Computing,</emphasis>
          Gerald Peterson, Ed., IEEE Computer Society Press, 1987.]
        </para>
      </footnote>
    </para>
    <para>
      There are three ways to make a child sprite. If you control-click
      or right-click on a sprite in the “sprite corral” at the bottom
      right corner of the window, you get a menu that includes “clone”
      as one of the choices. There is an a new clone of block in the
      Control palette that creates and reports a child sprite. And
      sprites have a “parent” attribute that can be set, like any
      attribute, thereby <emphasis>changing</emphasis> the parent of an
      existing sprite.
    </para>
  </section>
  <section xml:id="inheritance-by-delegation">
    <title> Inheritance by Delegation</title>
    <para>
      A clone <emphasis>inherits</emphasis> properties of its parent.
      “Properties” include scripts, custom blocks, variables, named
      lists, system attributes, costumes, and sounds. Each individual
      property can be shared between parent and child, or not shared
      (with a separate one in the child). The getter block for a shared
      property, in the child’s palette, is displayed in a lighter color;
      separate properties of the child are displayed in the traditional
      colors.
    </para>
    <blockquote>
      <para>
        When a new clone is created, by default it shares only its
        methods, wardrobe, and jukebox with its parent. All other
        properties are copied to the clone, but not shared. (One
        exception is that a new <emphasis>permanent</emphasis> clone is
        given a random position. Another is that
        <emphasis>temporary</emphasis> clones share the scripts in their
        parent’s scripting area. A third is that sprite-local variables
        that the parent creates <emphasis>after</emphasis> cloning are
        shared with its children.) If the value of a shared property is
        changed in the parent, then the children see the new value. If
        the value of a shared property is changed in the
        <emphasis>child</emphasis>, then the sharing link is broken, and
        a new private version is created in that child. (This is the
        mechanism by which a child chooses not to share a property with
        its parent.) “Changed” in this context means using the set or
        change block for a variable, editing a block in the Block
        Editor, editing a costume or sound, or inserting, deleting, or
        reordering costumes or sounds. To change a property from
        unshared to shared, the child uses the inherit command block.
        The pulldown menu in the block lists all the things this sprite
        can inherit from its parent (which might be nothing, if this
        sprite has no parent) and is not already inheriting. But that
        would prevent telling a child to inherit, so if the inherit
        block is inside a ring, its pulldown menu includes all the
        things a child could inherit from this sprite. Right-clicking on
        the scripting area of a permanent clone gives a menu option to
        share the entire collection of scripts from its parent, as a
        temporary clone does.
      </para>
    </blockquote>
    <para>
      The rules are full of details, but the basic idea is simple:
      Parents can change their children, but children can’t directly
      change their parents. That’s what you’d expect from the word
      “inherit”: the influence just goes in one direction. When a child
      changes some property, it’s declaring independence from its parent
      (with respect to that one property). What if you really want the
      child to be able to make a change in the parent (and therefore in
      itself and all its siblings)? Remember that in this system any
      object can tell any other object to do something:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image779.png" width="5.07292in" depth="0.58333in" />
        </imageobject>
      </inlinemediaobject>When a sprite gets a message for which it
      doesn’t have a corresponding block, the message is
      <emphasis>delegated</emphasis> to that sprite’s parent. When a
      sprite does have the corresponding block, then the message is not
      delegated. If the script that implements a delegated message
      refers to my (self), it means the child to which the message was
      originally sent, not the parent to which the message was
      delegated.
    </para>
  </section>
  <section xml:id="attrib.pnglist-of-attributes">
    <title><inlinemediaobject>
      <imageobject>
        <imagedata fileref="media/image780.png" width="0.78958in" depth="3.46806in" />
      </imageobject>
      <textobject>
        <phrase>attrib.png</phrase>
      </textobject>
    </inlinemediaobject>List of attributes</title>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image781.png" width="1.19in" depth="0.25in" />
        </imageobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image782.png" width="1.17569in" depth="6.11667in" />
        </imageobject>
      </inlinemediaobject>At the right is a picture of the dropdown menu
      of attributes in the my block.
    </para>
    <para>
      Several of these are not real attributes, but things related to
      attributes:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          self: this sprite
        </para>
      </listitem>
      <listitem>
        <para>
          neighbors: a list of <emphasis>nearby</emphasis>
          sprites<footnote>
            <para>
              <emphasis>Neighbors</emphasis> are all other sprites whose
              bounding boxes intersect the doubled dimensions of the
              requesting sprite's bounds.
            </para>
          </footnote>
        </para>
      </listitem>
      <listitem>
        <para>
          other sprites: a list of all sprites except myself
        </para>
      </listitem>
      <listitem>
        <para>
          stage: the stage, which is first-class, like a sprite
        </para>
      </listitem>
      <listitem>
        <para>
          clones: a list of my <emphasis>temporary</emphasis> clones
        </para>
      </listitem>
      <listitem>
        <para>
          other clones: a list of my <emphasis>temporary</emphasis>
          siblings
        </para>
      </listitem>
      <listitem>
        <para>
          parts: a list of sprites whose anchor attribute is this sprite
        </para>
      </listitem>
      <listitem>
        <para>
          children: a list of all my clones, temporary and permanent
        </para>
      </listitem>
    </itemizedlist>
    <para>
      The others are individual attributes:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          anchor: the sprite of which I am a (nested) part
        </para>
      </listitem>
      <listitem>
        <para>
          parent: the sprite of which I am a clone
        </para>
      </listitem>
      <listitem>
        <para>
          temporary?: am I a temporary clone?
        </para>
      </listitem>
      <listitem>
        <para>
          name: my name (same as parent’s name if I’m temporary)
        </para>
      </listitem>
      <listitem>
        <para>
          costumes: a list of the sprite’s costumes
        </para>
      </listitem>
      <listitem>
        <para>
          sounds: a list of the sprite’s sounds
        </para>
      </listitem>
      <listitem>
        <para>
          blocks: a list of the blocks visible in this sprite
        </para>
      </listitem>
      <listitem>
        <para>
          categories: a list of all the block category names
        </para>
      </listitem>
      <listitem>
        <para>
          dangling?: True if I am a part and not in synchronous orbit
        </para>
      </listitem>
      <listitem>
        <para>
          draggable?: True if the user can move me with the mouse
        </para>
      </listitem>
      <listitem>
        <para>
          width, height, left, right, top, bottom: The width or height
          of my costume <emphasis>as seen right now,</emphasis> or the
          left, etc., edge of my bounding box, taking rotation into
          account.
        </para>
      </listitem>
      <listitem>
        <para>
          rotation x, rotation y: when reading with my, the same as x
          position, y position. When set, changes the sprite’s rotation
          center <emphasis>without moving the sprite,</emphasis> like
          dragging the rotation center in the paint editor.
        </para>
      </listitem>
      <listitem>
        <para>
          center x, center y: the x and y position of the center of my
        </para>
      </listitem>
    </itemizedlist>
    <blockquote>
      <para>
        bounding box, rounded oﬀ–the geometric center of the costume.
      </para>
    </blockquote>
  </section>
  <section xml:id="first-class-costumes-and-sounds">
    <title>First Class Costumes and Sounds</title>
    <para>
      Costumes and sounds don’t have methods, as sprites do; you can’t
      ask them to do things. But they <emphasis>are</emphasis> first
      class: you can make a list of them, put them in variables, use
      them as input to a procedure, and so on. My [costumes] and my
      [sounds] report lists of them.
    </para>
    <section xml:id="media-computation-with-costumes">
      <title>Media Computation with Costumes</title>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image783.png" width="1.63194in" depth="0.1875in" />
          </imageobject>
          <textobject>
            <phrase>Macintosh HD:Users:bh:Desktop:ofcostume.png</phrase>
          </textobject>
        </inlinemediaobject>The components of a costume are its name,
        width, height, and pixels. The block gives access to these
        components using its left menu. From its right menu you can
        choose the current costume, the Turtle costume, or any costume
        in the sprite’s wardrobe. Since costumes are first class, you
        can also drop an expression whose value is a costume, or a list
        of costumes, on that second input slot. (Due to a misfeature,
        even though you can select Turtle in the right menu, the block
        reports 0 for its width and height, and an empty string for the
        other components.) The costume’s width and height are in its
        standard orientation, regardless of the sprite’s current
        direction. (This is different from the
        <emphasis>sprite’s</emphasis> width and height, reported by the
        my block.)
      </para>
      <para>
        But the really interesting part of a costume is its bitmap, a
        list of <emphasis>pixels</emphasis>. (A pixel, short for
        “picture element,” represents one dot on your display.) Each
        pixel is itself a list of four items, the red, green, and blue
        components of its color (in the range 0-255) and what is
        standardly called its “transparency” but should be called its
        opacity, also in the range 0-255, in which 0 means that the
        pixel is invisible and 255 means that it’s fully opaque: you
        can’t see anything from a rearward layer at that point on the
        stage. (Costume pixels typically have an opacity of 0 only for
        points inside the bounding box of the costume but not actually
        part of the costume; points in the interior of a costume
        typically have an opacity of 255. Intermediate values appear
        mainly at the edge of a costume, or at sharp boundaries between
        colors inside the costume, where they are used to reduce
        “jaggies”: the stairstep-like shape of a diagonal line displayed
        on an array of discrete rectangular screen coordinates. Note
        that the opacity of a <emphasis>sprite</emphasis> pixel is
        determined by combining the costume’s opacity with the sprite’s
        ghost effect. (The latter really is a measure of transparency: 0
        means opaque and 100 means invisible.)
      </para>
      <para>
        The bitmap is a one-dimensional list of pixels, not an array of
        <emphasis>height</emphasis> rows of <emphasis>width</emphasis>
        pixels each. That’s why the pixel list has to be combined with
        the dimensions to produce a costume. This choice partly reflects
        the way bitmaps are stored in the computer’s hardware and
        operating system, but also makes it easy to produce
        transformations of a costume with map:
      </para>
      <para>
        In this simplest possible transformation, the red value of all
        the pixels have been changed to a constant 150. Colors that were
        red in the original (such as the logo printed on the t-shirt)
        become closer to black (the other color components being near
        zero); the blue jeans become purple (blue plus red); perhaps
        counterintuitively, the white t-shirt, which has the maximum
        value for all three color components, loses some of its red and
        becomes cyan, the color opposite red on the color wheel. In
        reading the code, note that the function that is the first input
        to map is applied to a single pixel, whose first item is its red
        component. Also note that this process works only on bitmap
        costumes; if you call pixels of on a vector costume (one with
        “svg” in the corner of its picture), it will be converted to
        pixels first.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image790.png" width="2.25694in" depth="0.28472in" />
          </imageobject>
          <textobject>
            <phrase>Macintosh HD:Users:bh:Desktop:add-to-wardrobe.png</phrase>
          </textobject>
        </inlinemediaobject>One important point to see here is that a
        bitmap (list of pixels) is not, by itself, a costume. The new
        costume block creates a costume by combining a bitmap, a width,
        and a height. But, as in the example above, switch to costume
        will accept a bitmap as input and will automatically use the
        width and height of the current costume. Note that there’s no
        name input; costumes computed in this way are all named costume.
        Note also that the use of switch to costume does
        <emphasis>not</emphasis> add the computed costume to the
        sprite’s wardrobe; to do that, say
      </para>
      <para>
        Here’s a more interesting example of color manipulation:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image797.png" width="4.5625in" depth="0.40694in" />
          </imageobject>
        </inlinemediaobject>Each color value is constrained to be 0, 80,
        160, or 240. This gives the picture a more cartoonish look.
        Alternatively, you can do the computation taking advantage of
        hyperblocks:
      </para>
      <para>
        Here’s one way to exchange red and green values:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image804.png" width="0.95833in" depth="0.18056in" />
          </imageobject>
          <textobject>
            <phrase>Macintosh HD:Users:bh:Desktop:2-1-3-4.png</phrase>
          </textobject>
        </inlinemediaobject>It’s the list that determines the
        rearrangement of colors: green➔red, red➔green, and the other two
        unchanged. That list is inside another list because otherwise it
        would be selecting <emphasis>rows</emphasis> of the pixel array,
        and we want to select columns. We use pixels of costume current
        rather than costume apple because the latter is always a red
        apple, so this little program would get stuck turning it green,
        instead of alternating colors.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image809.png" width="1.72222in" depth="0.22917in" />
          </imageobject>
          <textobject>
            <phrase>Macintosh HD:Users:bh:Desktop:a-costume.png</phrase>
          </textobject>
        </inlinemediaobject>The stretch block takes a costume as its
        first input, either by selecting a costume from the menu or by
        dropping a costume-valued expression such as onto it. The other
        two inputs are percents of the original width and height, as
        advertised, so you can make fun house mirror versions of
        costumes:
      </para>
      <para>
        The resulting costumes can be used with switch to costume and so
        on.
      </para>
      <para>
        Finally, you can use pictures from your computer’s camera in
        your projects using these blocks:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image813.png" width="1.47222in" depth="0.24306in" />
          </imageobject>
          <textobject>
            <phrase>Macintosh HD:Users:bh:Desktop:Jump! script pic.png</phrase>
          </textobject>
        </inlinemediaobject>Using the video on block turns on the camera
        and displays what it sees on the stage, regardless of the inputs
        given. The camera remains on until you click the red stop
        button, your program runs the stop all block, or you turn it off
        explicitly with the block. The video image on the stage is
        partly ghosted, to an extent determined by the set video
        transparency block, whose input really is transparency and not
        opacity. (Small numbers make the video more visible.) By
        default, the video image is mirrored, like the selfie camera on
        your cell phone: When you raise your left hand, your image
        raises its right hand. You can control this <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image814.png" width="1.40278in" depth="0.24306in" />
          </imageobject>
          <textobject>
            <phrase>Macintosh HD:Users:bh:Desktop:mirror-video.png</phrase>
          </textobject>
        </inlinemediaobject>mirroring with the block.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image815.png" width="1.20417in" depth="1.6125in" />
          </imageobject>
        </inlinemediaobject>The video snap on block then takes a still
        picture from the camera, and trims it to fit on the selected
        sprite. (Video snap on stage means to use the entire stage-sized
        rectangle.) For example, here’s a camera snapshot trimmed to fit
        Alonzo:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image816.png" width="2.67014in" depth="1.29861in" />
          </imageobject>
          <textobject>
            <phrase>Macintosh HD:Users:bh:Desktop:Video Capture script 1.png</phrase>
          </textobject>
        </inlinemediaobject>The “Video Capture” project in the Examples
        collection repeatedly takes such trimmed snapshots and has the
        Alonzo sprite use the current snapshot as its costume, so it
        looks like this:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image817.png" width="2.66667in" depth="2in" />
          </imageobject>
          <textobject>
            <phrase>Macintosh HD:Users:bh:Desktop:offset-video.png</phrase>
          </textobject>
        </inlinemediaobject><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image818.png" width="3.33333in" depth="2.5in" />
          </imageobject>
          <textobject>
            <phrase>Macintosh HD:Users:bh:Desktop:video.png</phrase>
          </textobject>
        </inlinemediaobject>(The picture above was actually taken with
        transparency set to 50, to make the background more visible for
        printing.) Because the sprite is always still in the place where
        the snapshot was taken, its costume exactly fits in with the
        rest of the full-stage video. If you were to add a move 100
        steps block after the switch to costume, you’d see something
        like this:
      </para>
      <para>
        This time, the sprite’s costume was captured at one position,
        and then the sprite is shown at a different position. (You
        probably wouldn’t want to do this, but perhaps it’s helpful for
        explanatory purposes.)
      </para>
      <para>
        What you <emphasis>would</emphasis> want to do is push the
        sprite around the stage:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image825.png" width="3.09028in" depth="1.92361in" />
          </imageobject>
          <textobject>
            <phrase>Macintosh HD:Users:bh:Desktop:microphone.png</phrase>
          </textobject>
        </inlinemediaobject>(Really these should be Jens’s picture; it’s
        his project. But he’s vacationing. ☺) Video motion compares two
        snapshots a moment apart, looking only at the part within the
        given trim (here myself, meaning the current sprite, not the
        person looking into the camera), to detect a difference between
        them. It reports a number, measuring the number of pixels
        through which some part of the picture has moved. Video
        direction also compares two snapshots to detect motion, but what
        it reports is the direction (in the point in direction sense) of
        the motion. So the script above moves the sprite in the
        direction in which it’s being pushed, but only if a significant
        amount of motion is found; otherwise the sprite would jiggle
        around too much. And yes, you can run the second script without
        the first to push a balloon around the stage.
      </para>
    </section>
    <section xml:id="media-computation-with-sounds" role="unnumbered">
      <title>Media Computation with Sounds</title>
      <para>
        The starting point for computation with sound is the microphone
        block. It starts by recording a brief burst of sound from your
        microphone. (How brief? On my computer, 0.010667 seconds, but
        you’ll see shortly how to ﬁnd out or control the sample size on
        your computer.)
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image826.png" width="1.96528in" depth="0.25694in" />
          </imageobject>
          <textobject>
            <phrase>Macintosh HD:Users:bh:Desktop:sample-rate.png</phrase>
          </textobject>
        </inlinemediaobject><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image827.png" width="5.99931in" depth="2.62014in" />
          </imageobject>
          <textobject>
            <phrase>Macintosh HD:Users:bh:Desktop:samples.png</phrase>
          </textobject>
        </inlinemediaobject>Just as the <emphasis>pixel</emphasis> is
        the smallest piece of a picture, the <emphasis>sample</emphasis>
        is the smallest piece of a sound. It says here: that on my
        computer, 48,000 samples are recorded per second, so each sample
        is 1/48,000 of a second. The value of a sample is between -1 and
        1, and represents the sound pressure on the microphone—how hard
        the air is pushing—at that instant. (You can skip the next page
        or so if you know about Fourier analysis.) Here’s a picture of
        400 samples:
      </para>
      <para>
        In this graph, the <emphasis>x</emphasis> axis represents the
        time at which each sample was measured; the
        <emphasis>y</emphasis> axis measures the value of the sample at
        that time. The first obvious thing about this graph is that it
        has a lot of ups and downs. The most basic up-and-down function
        is the <emphasis>sine wave:</emphasis>
      </para>
      <para>
        Every periodic function (more or less, any sample that sounds
        like music rather than sounding like static) is composed of a
        sum of sine waves of different frequencies.
      </para>
      <para>
        Look back at the graph of our sampled sound. There is a green
        dot every seven samples. There’s nothing magic about the number
        seven; I tried different values until I found one that looked
        right. What “right” means is that, for the first few dots at
        least, they coincide almost perfectly with the high points and
        low points of the graph. Near the middle (horizontally) of the
        graph, the green dots don’t seem anywhere near the high and low
        points, but if you find the very lowest point of the graph,
        about 2/3 of the way along, the dots start lining up almost
        perfectly again.
      </para>
      <para>
        The red graph above shows two <emphasis>cycles</emphasis> of a
        sine wave. One cycle goes up, then down, then up again. The
        amount of time taken for one cycle is the
        <emphasis>period</emphasis> of the sine function. If the green
        dots match both ups and downs in the captured sound, then two
        dots—14 samples, or 14/48000 of a second—represent the period.
        The first cycle and a half of the graph looks like it could be a
        pure sine wave, but after that, the tops and bottoms don’t line
        up, and there are peculiar little jiggles, such as the one
        before the fifth green dot. This happens because sine waves of
        different periods are added together.
      </para>
      <para>
        It turns out to be more useful to measure the reciprocal of the
        period, in our case, 48000/14 or about 3429 <emphasis>cycles per
        second.</emphasis> Another name for “cycles per second” is
        “Hertz,” abbreviated Hz, so our sound has a component at 3249
        Hz. As a musical note, that’s about an A (a little flat), four
        octaves above middle C. (Don’t worry too much about the note
        being a little off; remember that the 14-sample period was just
        eyeballed and is unlikely to be exactly right.)
      </para>
      <para>
        Four octaves above middle C is really high! That would be a
        shrill-sounding note. But remember that a complex waveform is
        the sum of multiple sine waves at different frequency. Here’s a
        different up-and-down regularity:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image828.png" width="2.79514in" depth="1.22222in" />
          </imageobject>
          <textobject>
            <phrase>Macintosh HD:Users:bh:Desktop:red-sine.png</phrase>
          </textobject>
        </inlinemediaobject><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image829.png" width="2.78472in" depth="1.04861in" />
          </imageobject>
          <textobject>
            <phrase>Macintosh HD:Users:bh:Desktop:sine.png</phrase>
          </textobject>
        </inlinemediaobject>It’s not obvious, but in the left part of
        the graph, the signal is more above the <emphasis>x</emphasis>
        axis than below it. Toward the right, it seems to be more below
        than above the axis. At the very right it looks like it might be
        climbing again.
      </para>
      <para>
        The period of the red sine wave is 340 samples, or 340/48000
        second. That’s a frequency of about 141 Hz, about D below middle
        C. Again, this is measuring by eyeball, but likely to be close
        to the right frequency.
      </para>
      <para>
        All this eyeballing doesn’t seem very scientific. Can’t we just
        get the computer to find all the relevant frequencies? Yes, we
        can, using a mathematical technique called <emphasis>Fourier
        analysis.</emphasis> (Jean-Baptiste Joseph Fourier, 1768–1830,
        made many contributions to mathematics and physics, but is best
        known for working out the nature of periodic functions as a sum
        of sine waves.) Luckily we don’t have to do the math; the
        microphone block will do it for us, if we ask for microphone
        spectrum:
      </para>
      <para>
        These are frequency spectra from (samples of) three different
        songs. The most obvious thing about these graphs is that their
        overall slope is downward; the loudest frequency is the lowest
        frequency. That’s typical of music.
      </para>
      <para>
        The next thing to notice is that there’s a regularity in the
        spacing of spikes in the graph. This is partly just an artifact;
        the frequency (horizontal) axis isn’t continuous. There are a
        finite number of “buckets” (default: 512), and all the
        frequencies within a bucket contribute to the amplitude
        (vertical axis) of that bucket. The spectrum is a list of that
        many amplitudes. But the patterns of alternating rising and
        falling values are real; the frequencies that are multiples of
        the main note being sampled will have higher amplitude than
        other frequencies.
      </para>
      <para>
        Samples and spectrum are the two most detailed representations
        of a sound. But the microphone block has other, simpler options
        also:
      </para>
      <para>
        volume the instantaneous volume when the block is called
      </para>
      <para>
        note the MIDI note number (as in play note) of the main note
        heard
      </para>
      <para>
        frequency the frequency in Hz of the main note heard
      </para>
      <para>
        sample rate the number of samples being collected per second
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image258.png" width="2.91667in" depth="0.28125in" />
          </imageobject>
          <textobject>
            <phrase>Macintosh HD:Users:bh:Desktop:new-sound.png</phrase>
          </textobject>
        </inlinemediaobject>resolution the size of the array in which
        data are collected (typically 512, must be a power of 2)
      </para>
      <para>
        The block for sounds that corresponds to new picture for
        pictures is
      </para>
      <para>
        Its first input is a list of samples, and its second input
        specifies how many samples occupy one second.
      </para>
    </section>
  </section>
</section>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="oop-with-procedures">
  <title>
  OOP with Procedures</title>
  <para>
    The idea of object oriented programming is often taught in a way
    that makes it seem as if a special object oriented programming
    language is necessary. In fact, any language with ﬁrst class
    procedures and lexical scope allows objects to be implemented
    explicitly; this is a useful exercise to help demystify objects.
  </para>
  <para>
    The central idea of this implementation is that an object is
    represented as a <emphasis>dispatch procedure</emphasis> that takes
    a message as input and reports the corresponding method. In this
    section we start with a stripped-down example to show how local
    state works, and build up to full implementations of class/instance
    and prototyping OOP.
  </para>
  <section xml:id="local-state-with-script-variables">
    <title>Local State with Script Variables</title>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image852.png" width="2.23958in" depth="1.51042in" />
        </imageobject>
      </inlinemediaobject>This script implements an object
      <emphasis>class</emphasis>, a type of object, namely the counter
      class. In this ﬁrst simplified version there is only one method,
      so no explicit message passing is necessary. When the make a
      counter block is called, it reports a procedure, the ringed script
      inside its body. That procedure implements a specific counter
      object, an <emphasis>instance</emphasis> of the counter class.
      When invoked, a counter instance increases and reports its count
      variable. Each counter has its own local count:
    </para>
    <para>
      This example will repay careful study, because it isn’t obvious
      why each instance has a separate count. From the point of view of
      the make a counter procedure, each invocation causes a new count
      variable to be created. Usually such <emphasis>script
      variables</emphasis> are temporary, going out of existence when
      the script ends. But this one is special, because make a counter
      returns <emphasis>another script</emphasis> that makes reference
      to the count variable, so it remains active. (The script variables
      block makes variables local to a script. It can be used in a
      sprite’s script area or in the Block Editor. Script variables can
      be “exported” by being used in a reported procedure, as here.)
    </para>
    <para>
      In this approach to OOP, we are representing both classes and
      instances as procedures. The make a counter block represents the
      class, while each instance is represented by a nameless script
      created each time make a counter is called. The script variables
      created inside the make a counter block but outside the ring are
      <emphasis>instance variables,</emphasis> belonging to a particular
      counter.
    </para>
  </section>
  <section xml:id="messages-and-dispatch-procedures">
    <title>Messages and Dispatch Procedures</title>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image853.png" width="4.41667in" depth="3.16667in" />
        </imageobject>
      </inlinemediaobject>In the simplified class above, there is only
      one method, and so there are no messages; you just call the
      instance to carry out its one method. Here is a more refined
      version that uses message passing:
    </para>
    <para>
      Again, the make a counter block represents the counter class, and
      again the script creates a local variable count each time it is
      invoked. The large outer ring represents an instance. It is a
      <emphasis>dispatch procedure:</emphasis> it takes a message (just
      a text word) as input, and it reports a method. The two smaller
      rings are the methods. The top one is the next method; the bottom
      one is the reset method. The latter requires an input, named
      value.
    </para>
    <para>
      In the earlier version, calling the instance did the entire job.
      In this version, calling the instance gives access to a method,
      which must then be called to finish the job. We can provide a
      block to do both procedure calls in one:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image854.png" width="4.01042in" depth="0.70772in" />
        </imageobject>
      </inlinemediaobject>
    </para>
    <para>
      The ask block has two required inputs: an object and a message. It
      also accepts optional additional inputs, which
      Snap<emphasis>!</emphasis> puts in a list; that list is named args
      inside the block. Ask has two nested call blocks. The inner one
      calls the object, i.e., the dispatch procedure. The dispatch
      procedure always takes exactly one input, namely the message. It
      reports a method, which may take any number of inputs; note that
      this is the situation in which we drop a list of values onto the
      arrowheads of a multiple input (in the outer call block). Note
      also that this is one of the rare cases in which we must unringify
      the inner call block, whose <emphasis>value when called</emphasis>
      gives the method.
    </para>
  </section>
  <section xml:id="inheritance-via-delegation">
    <title>Inheritance via Delegation</title>
    <para>
      So, our objects now have local state variables and message
      passing. What about inheritance? We can provide that capability
      using the technique of <emphasis>delegation</emphasis>. Each
      instance of the child class contains an instance of the parent
      class, and simply passes on the messages it doesn’t want to
      specialize:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image857.png" width="3.8125in" depth="3.58333in" />
        </imageobject>
      </inlinemediaobject>
    </para>
    <para>
      This script implements the buzzer class, which is a child of
      counter. Instead of having a count (a number) as a local state
      variable, each buzzer has a counter (an object) as a local state
      variable. The class specializes the next method, reporting what
      the counter reports unless that result is divisible by 7, in which
      case it reports “buzz.” (Yeah, it should also check for a digit 7
      in the number, but this code is complicated enough already.) If
      the message is anything other than next, though, such as reset,
      then the buzzer simply invokes its counter’s dispatch procedure.
      So the counter handles any message that the buzzer doesn’t handle
      explicitly. (Note that in the non-next case we call the counter,
      not ask it something, because we want to report a method, not the
      value that the message reports.) So, if we ask a buzzer to reset
      to a value divisible by 7, it will end up reporting that number,
      not “buzz.”
    </para>
  </section>
  <section xml:id="an-implementation-of-prototyping-oop">
    <title>An Implementation of Prototyping OOP</title>
    <para>
      In the class/instance system above, it is necessary to design the
      complete behavior of a class before you can make any instances of
      the class. This is okay for top-down design, but not great for
      experimentation. Here we sketch the implementation of a
      <emphasis>prototyping</emphasis> OOP system: You make an object,
      tinker with it, make clones of it, and keep tinkering. Any changes
      you make in the parent are inherited by its children. In effect,
      that first object is both the class and an instance of the class.
      In the implementation below, children share properties (methods
      and local variables) of their parent unless and until a child
      changes a property, at which point that child gets a private copy.
      (If a child wants to change something for its entire family, it
      must ask the parent to do it.)
    </para>
    <para>
      Because we want to be able to create and delete properties
      dynamically, we won’t use Snap<emphasis>!</emphasis> variables to
      hold an object’s variables or methods. Instead, each object has
      two <emphasis>tables,</emphasis> called methods and data, each of
      which is an <emphasis>association list:</emphasis> a list of
      two-item lists, in which each of the latter contains a
      <emphasis>key</emphasis> and a corresponding
      <emphasis>value.</emphasis> We provide a lookup procedure to
      locate the key-value pair corresponding to a given key in a given
      table.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image858.png" width="3.21528in" depth="2.36111in" />
        </imageobject>
      </inlinemediaobject>
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image859.png" width="2.625in" depth="0.78125in" />
        </imageobject>
      </inlinemediaobject>
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image860.png" width="5.60417in" depth="1.15625in" />
        </imageobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image861.png" width="5.60417in" depth="1.15625in" />
        </imageobject>
      </inlinemediaobject>
    </para>
    <para>
      There are also commands to insert and delete entries:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image862.png" width="3.71875in" depth="1.82639in" />
        </imageobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image863.png" width="3.22917in" depth="2.12831in" />
        </imageobject>
      </inlinemediaobject>
    </para>
    <para>
      As in the class/instance version, an object is represented as a
      dispatch procedure that takes a message as its input and reports
      the corresponding method. When an object gets a message, it will
      ﬁrst look for that keyword in its methods table. If it’s found,
      the corresponding value is the method we want. If not, the object
      looks in its data table. If a value is found there, what the
      object returns is <emphasis>not</emphasis> that value, but rather
      a reporter method that, when called, will report the value. This
      means that what an object returns is <emphasis>always</emphasis> a
      method.
    </para>
    <para>
      If the object has neither a method nor a datum with the desired
      name, but it does have a parent, then the parent (that is, the
      parent’s dispatch procedure) is invoked with the message as its
      input. Eventually, either a match is found, or an object with no
      parent is found; the latter case is an error, meaning that the
      user has sent the object a message not in its repertoire.
    </para>
    <para>
      Messages can take any number of inputs, as in the class/instance
      system, but in the prototyping version, every method automatically
      gets the object to which the message was originally sent as an
      extra ﬁrst input. We must do this so that if a method is found in
      the parent (or grandparent, etc.) of the original recipient, and
      that method refers to a variable or method, it will use the
      child’s variable or method if the child has its own version.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image864.png" width="4.375in" depth="7.46944in" />
        </imageobject>
      </inlinemediaobject>The clone of block below takes an object as
      its input and makes a child object. It should be considered as an
      internal part of the implementation; the preferred way to make a
      child of an object is to send that object a clone message.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image865.png" width="1.57292in" depth="0.6875in" />
        </imageobject>
      </inlinemediaobject>Every object is created with predefined
      methods for set, method, delete-var, delete-method, and clone. It
      has one predefined variable, parent. Objects without a parent are
      created by calling new object:
    </para>
    <para>
      As before, we provide procedures to call an object’s dispatch
      procedure and then call the method. But in this version, we
      provide the desired object as the ﬁrst method input. We provide
      one procedure for Command methods and one for Reporter methods:
    </para>
    <para>
      (Remember that the “Input list:” variant of the run and call
      blocks is made by dragging the input expression over the
      arrowheads rather than over the input slot.)
    </para>
    <para>
      The script below demonstrates how this prototyping system can be
      used to make counters. We start with one prototype counter, called
      counter1. We count this counter up a few times, then create a
      child counter2 and give it its own count variable, but
      <emphasis>not</emphasis> its own total variable. The next method
      always sets counter1’s total variable, which therefore keeps count
      of the total number of times that <emphasis>any</emphasis> counter
      is incremented. Running this script should [say] and (think) the
      following lists:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image870.png" width="4.20833in" depth="4.39583in" />
        </imageobject>
      </inlinemediaobject>[1 1] [2 2] [3 3] [4 4] (1 5) (2 6) (3 7) [5
      8] [6 9] [7 10] [8 11]
    </para>
  </section>
</section>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="the-outside-world">
  <title>
  The Outside World</title>
  <para>
    <inlinemediaobject>
      <imageobject>
        <imagedata fileref="media/image148.png" width="1.62014in" depth="0.25in" />
      </imageobject>
    </inlinemediaobject>The facilities discussed so far are fine for
    projects that take place entirely on your computer’s screen. But you
    may want to write programs that interact with physical devices
    (sensors or robots) or with the World Wide Web. For these purposes
    Snap<emphasis>!</emphasis> provides a <anchor xml:id="url" />single
    primitive block:
  </para>
  <para>
    This might not seem like enough, but in fact it can be used to build
    the desired capabilities.
  </para>
  <section xml:id="the-world-wide-web">
    <title>The World Wide Web</title>
    <para>
      The input to the url block is the URL (Uniform Resource Locator)
      of a web page. The block reports the body of the Web server’s
      response (minus HTTP header), <emphasis>without
      interpretation.</emphasis> This means that in most cases the
      response is a description of the page in HTML (HyperText Markup
      Language) notation. Often, especially for commercial web sites,
      the actual information you’re trying to find on the page is
      actually at another URL included in the reported HTML. The Web
      page is typically a very long text string, and so the primitive
      split block is useful to get the text in a manageable form,
      namely, as a list of lines:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image871.png" width="6.52083in" depth="4.27778in" />
        </imageobject>
      </inlinemediaobject>
    </para>
    <para>
      The second input to split is the character to be used to separate
      the text string into a list of lines, or one of a set of common
      cases (such as line, which separates on carriage return and/or
      newline characters.
    </para>
    <para>
      This might be a good place for a reminder that list-view watchers
      scroll through only 100 items at a time. The downarrow near the
      bottom right corner of the speech balloon in the picture presents
      a menu of hundred-item ranges. (This may seem unnecessary, since
      the scroll bar should allow for any number of items, but doing it
      this way makes Snap<emphasis>!</emphasis> much faster.) In table
      view, the entire list is included.
    </para>
    <para>
      If you include a protocol name in the input to the url block (such
      as http:// or https://), that protocol will be used. If not, the
      block first tries HTTPS and then, if that fails, HTTP.
    </para>
    <para>
      A security restriction in JavaScript limits the ability of one web
      site to initiate communication with another site. There is an
      official workaround for this limitation called the CORS protocol
      (Cross-Origin Resource Sharing), but the target site has to allow
      snap.berkeley.edu explicitly, and of course most don’t. To get
      around this problem, you can use third-party sites (“cors
      proxies”) that are not limited by JavaScript and that forward your
      requests.
    </para>
  </section>
  <section xml:id="hardware-devices">
    <title>Hardware Devices</title>
    <para>
      Another JavaScript security restriction prevents
      Snap<emphasis>!</emphasis> from having direct access to devices
      connected to your computer, such as sensors and robots. (Mobile
      devices such as smartphones may also have useful devices built in,
      such as accelerometers and GPS receivers.) The url block is also
      used to interface Snap<emphasis>!</emphasis> with these external
      capabilities.
    </para>
    <para>
      The idea is that you run a separate program that both interfaces
      with the device and provides a local HTTP server that
      Snap<emphasis>!</emphasis> can use to make requests to the device.
      <emphasis>Unlike</emphasis> Snap<emphasis>!</emphasis>
      <emphasis>itself, these programs have access to anything on your
      computer, so you have to trust the author of the
      software!</emphasis> Our web site, snap.berkeley.edu, provides
      links to drivers for several devices, including, at this writing,
      the Lego NXT, Finch, Hummingbird, and Parallax S2 robots; the
      Nintendo Wiimote and Leap Motion sensors, the Arduino
      microcomputer, and Super-Awesome Sylvia’s Water Color Bot. The
      same server technique can be used for access to third party
      software libraries, such as the speech synthesis package linked on
      our web site.
    </para>
    <para>
      Most of these packages require some expertise to install; the
      links are to source code repositories. This situation will improve
      with time.
    </para>
  </section>
  <section xml:id="date-and-time">
    <title>Date and Time</title>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image872.png" width="5.30556in" depth="0.31944in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:date.png</phrase>
        </textobject>
      </inlinemediaobject>The current block in the Sensing palette can
      be used to find out the current date or time. Each call to this
      block reports one component of the date or time, so you will
      probably combine several calls, like this:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image873.png" width="5.30556in" depth="0.31944in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:European-date.png</phrase>
        </textobject>
      </inlinemediaobject>for Americans, or like this:
    </para>
    <para>
      for Europeans.
    </para>
  </section>
</section>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="continuations">
  <title>
  Continuations</title>
  <para>
    Blocks are usually used within a script. The
    <emphasis>continuation</emphasis> of a block within a particular
    script is the part of the computation that remains to be completed
    after the block does its job. A continuation can be represented as a
    ringed script. Continuations are always part of the interpretation
    of any program in any language, but usually these continuations are
    implicit in the data structures of the language interpreter or
    compiler. Making continuations explicit is an advanced but versatile
    programming technique that allows users to create control structures
    such as nonlocal exit and multithreading.
  </para>
  <para>
    <inlinemediaobject>
      <imageobject>
        <imagedata fileref="media/image874.png" width="1.40625in" depth="1.54167in" />
      </imageobject>
    </inlinemediaobject>In the simplest case, the continuation of a
    command block may just be the part of the script after the block.
    For example, in the script
  </para>
  <para>
    <inlinemediaobject>
      <imageobject>
        <imagedata fileref="media/image875.png" width="1.59375in" depth="0.70833in" />
      </imageobject>
    </inlinemediaobject>the continuation of the move 100 steps block is
  </para>
  <para>
    <inlinemediaobject>
      <imageobject>
        <imagedata fileref="media/image876.png" width="1.47847in" depth="0.80208in" />
      </imageobject>
    </inlinemediaobject>But some situations are more complicated. For
    example, what is the continuation of move 100 steps in the following
    script?
  </para>
  <para>
    <inlinemediaobject>
      <imageobject>
        <imagedata fileref="media/image877.png" width="1.66667in" depth="1.07292in" />
      </imageobject>
    </inlinemediaobject>That’s a trick question; the move block is run
    four times, and it has a different continuation each time. The first
    time, its continuation is
  </para>
  <para>
    Note that there is no repeat 3 block in the actual script, but the
    continuation has to represent the fact that there are three more
    times through the loop to go. The fourth time, the continuation is
    just
  </para>
  <para>
    <inlinemediaobject>
      <imageobject>
        <imagedata fileref="media/image878.png" width="1.59375in" depth="0.29792in" />
      </imageobject>
    </inlinemediaobject>What counts is not what’s physically below the
    block in the script, but what computational work remains to be done.
  </para>
<literallayout>(This is a situation in which visible code may be a little misleading. We have to put a repeat 3 block in the <emphasis>picture</emphasis> of the continuation, but the actual continuation is made from the evaluator’s internal bookkeeping of where it’s up to in a script. So it’s really the original script plus some extra information. But the pictures here do correctly represent what work the process still has left to do.)
<inlinemediaobject>
<imageobject>
<imagedata fileref="media/image879.png" width="1.47917in" depth="1.25in" />
</imageobject>
</inlinemediaobject>When a block is used inside a custom block, its continuation may include parts of more than one script. For example, if we make a custom square block</literallayout>
  <para>
    and then use that block in a script:
  </para>
  <para>
    <inlinemediaobject>
      <imageobject>
        <imagedata fileref="media/image880.png" width="0.72917in" depth="0.59375in" />
      </imageobject>
    </inlinemediaobject>then the continuation of the first use of move
    100 steps is
  </para>
  <para>
    <inlinemediaobject>
      <imageobject>
        <imagedata fileref="media/image881.png" width="1.66667in" depth="1.26042in" />
      </imageobject>
    </inlinemediaobject>in which part comes from inside the square block
    and part comes from the call to square. Nevertheless, ordinarily
    when we <emphasis>display</emphasis> a continuation we show only the
    part within the current script.
  </para>
  <para>
    <inlinemediaobject>
      <imageobject>
        <imagedata fileref="media/image882.png" width="2.1875in" depth="0.57292in" />
      </imageobject>
    </inlinemediaobject>The continuation of a command block, as we’ve
    seen, is a simple script with no input slots. But the continuation
    of a <emphasis>reporter</emphasis> block has to do something with
    the value reported by the block, so it takes that value as input.
    For example, in the script
  </para>
  <para>
    the continuation of the 3+4 block is
  </para>
  <para>
    <inlinemediaobject>
      <imageobject>
        <imagedata fileref="media/image883.png" width="3.57292in" depth="0.57292in" />
      </imageobject>
    </inlinemediaobject>Of course the name result in that picture is
    arbitrary; any name could be used, or no name at all by using the
    empty-slot notation for input substitution.
  </para>
  <section xml:id="continuation-passing-style">
    <title>Continuation Passing Style</title>
    <para>
      Like all programming languages, Snap<emphasis>!</emphasis>
      evaluates compositions of nested reporters from the inside out.
      For example, in the expression <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image884.png" width="1.3125in" depth="0.22917in" />
        </imageobject>
      </inlinemediaobject>Snap<emphasis>!</emphasis> first adds 4 and 5,
      then multiplies 3 by that sum. This often means that the order in
      which the operations are done is backwards from the order in which
      they appear in the expression: When reading the above expression
      you say “times” before you say “plus.” In English, instead of
      saying “three times four plus five,” which actually makes the
      order of operations ambiguous, you could say, “take the sum of
      four and five, and then take the product of three and that sum.”
      This sounds more awkward, but it has the virtue of putting the
      operations in the order in which they’re actually performed.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image885.png" width="3.1875in" depth="0.35417in" />
        </imageobject>
      </inlinemediaobject>That may seem like overkill in a simple
      expression, but suppose you’re trying to convey the expression
    </para>
    <para>
      to a friend over the phone. If you say “factorial of three times
      factorial of two plus two plus five” you might mean any of these:
    </para>
    <para>
      Wouldn’t it be better to say, “Add two and two, take the factorial
      of that, add five to that, multiply three by that, and take the
      factorial of the result”? We can do a similar reordering of an
      expression if we first define versions of all the reporters that
      take their continuation as an explicit input. In the following
      picture, notice that the new blocks are
      <emphasis>commands</emphasis>, not reporters.
    </para>
    <para>
      We can check that these blocks give the results we want:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image908.png" width="5.53333in" depth="2.31806in" />
        </imageobject>
      </inlinemediaobject>The original expression can now be represented
      as
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image909.png" width="2.19306in" depth="1.05278in" />
        </imageobject>
      </inlinemediaobject>If you read this top to bottom, don’t you get
      “Add two and two, take the factorial of that, add five to that,
      multiply three by that, and take the factorial of the result”?
      Just what we wanted! This way of working, in which every block is
      a command that takes a continuation as one of its inputs, is
      called <emphasis>continuation-passing style (CPS).</emphasis>
      Okay, it looks horrible, but it has subtle virtues. One of them is
      that each script is just one block long (with the rest of the work
      buried in the continuation given to that one block), so each block
      doesn’t have to remember what else to do—in the vocabulary of this
      section, the (implicit) continuation of each block is empty.
      Instead of the usual picture of recursion, with a bunch of little
      people all waiting for each other, with CPS what happens is that
      each little person hands off the problem to the next one and goes
      to the beach, so there’s only one active little person at a time.
      In this example, we start with Alfred, an add specialist, who
      computes the value 4 and then hands off the rest of the problem to
      Francine, a factorial specialist. She computes the value 24, then
      hands the problem off to Anne, another add specialist, who
      computes 29. And so on, until finally Sam, a say specialist, says
      the value 2.107757298379527×10<superscript>132</superscript>,
      which is a very large number!
    </para>
    <para>
      Go back to the definitions of these blocks. The ones, such as add,
      that correspond to primitive reporters are simple; they just call
      the reporter and then call their continuation with its result. But
      the definition of factorial is more interesting. It doesn’t just
      call our original factorial reporter and send the result to its
      continuation. CPS is used inside factorial too! It says, “See if
      my input is zero. Send the (true or false) result to if. If the
      result is true, then call my continuation with the value 1.
      Otherwise, subtract 1 from my input. Send the result of that to
      factorial, with a continuation that multiplies the smaller
      number’s factorial by my original input. Finally, call my
      continuation with the product.” You can use CPS to unwind even the
      most complicated branched recursions.
    </para>
    <para>
      By the way, I cheated a bit above. The if/else block should also
      use CPS; it should take one true/false input and <emphasis>two
      continuations.</emphasis> It will go to one or the other
      continuation depending on the value of its input. But in fact the
      C-shaped blocks (or E-shaped, like if/else) are really using CPS
      in the first place, because they implicitly wrap rings around the
      sub-scripts within their branches. See if you can make an
      explicitly CPS if/else block.
    </para>
  </section>
  <section xml:id="callrun-wcontinuation">
    <title>Call/Run w/Continuation</title>
    <para>
      To use explicit continuation passing style, we had to define
      special versions of all the reporters, add and so on.
      Snap<emphasis>!</emphasis> provides a primitive mechanism for
      capturing continuations when we need to, without using
      continuation passing throughout a project.
    </para>
    <para>
      Here’s the classic example. We want to write a recursive block
      that takes a list of numbers as input, and reports the product of
      all the numbers:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image910.png" width="3.89583in" depth="1.9375in" />
        </imageobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image911.png" width="3.89583in" depth="1.34167in" />
        </imageobject>
      </inlinemediaobject>But we can improve the efficiency of this
      block, in the case of a list that includes a zero; as soon as we
      see the zero, we know that the entire product is zero.
    </para>
    <para>
      But this is not as efficient as it might seem. Consider, as an
      example, the list 1,2,3,0,4,5. We find the zero on the third
      recursive call (the fourth call altogether), as the first item of
      the sublist 0,4,5. What is the continuation of the report 0 block?
      It’s
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image912.png" width="4.33333in" depth="0.41667in" />
        </imageobject>
      </inlinemediaobject>Even though we already know that result is
      zero, we’re going to do three unnecessary multiplications while
      unwinding the recursive calls.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image913.png" width="4.03819in" depth="1.92569in" />
        </imageobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image914.png" width="3.94514in" depth="1.09792in" />
        </imageobject>
      </inlinemediaobject>We can improve upon this by capturing the
      continuation of the top-level call to product:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image915.png" width="2.70833in" depth="0.29167in" />
        </imageobject>
      </inlinemediaobject>The <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image916.png" width="1.59125in" depth="0.18611in" />
        </imageobject>
      </inlinemediaobject> block takes as its input a one-input script,
      as shown in the product example. It calls that script with
      <emphasis>the continuation of the</emphasis>
      call-with-continuation <emphasis>block itself</emphasis> as its
      input. In this case, that continuation is
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image917.png" width="4.40625in" depth="1.15625in" />
        </imageobject>
      </inlinemediaobject>reporting to whichever script called product.
      If the input list doesn’t include a zero, then nothing is ever
      done with that continuation, and this version works just like the
      original product. But if the input list is 1,2,3,0,4,5, then three
      recursive calls are made, the zero is seen, and product-helper
      <emphasis>runs the continuation,</emphasis> with an input of 0.
      The continuation immediately reports that 0 to the caller of
      product, <emphasis>without</emphasis> unwinding all the recursive
      calls and without the unnecessary multiplications.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image918.png" width="4.38542in" depth="0.51042in" />
        </imageobject>
      </inlinemediaobject>I could have written product a little more
      simply using a Reporter ring instead of a Command ring:
    </para>
    <para>
      but it’s customary to use a script to represent the input to
      call<emphasis role="strong"> </emphasis>w/continuation because
      very often that input takes the form
    </para>
    <para>
      so that the continuation is saved permanently and can be called
      from anywhere in the project. That’s why the input slot in call
      w/continuation has a Command ring rather than a Reporter ring.
    </para>
    <para>
      First class continuations are an experimental feature in
      Snap<emphasis>!</emphasis> and there are many known limitations in
      it. One is that the display of reporter continuations shows only
      the single block in which the call w/continuation is an input.
    </para>
    <section xml:id="nonlocal-exit">
      <title>
      Nonlocal exit</title>
      <para>
        Many programming languages have a break command that can be used
        inside a looping construct such as repeat to end the repetition
        early. Using first class continuations, we can generalize this
        mechanism to allow nonlocal exit even within a block called from
        inside a loop, or through several levels of nested loops:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image923.png" width="1.85417in" depth="2.65347in" />
          </imageobject>
        </inlinemediaobject>The upvar break has as its value a
        continuation that can be called from anywhere in the program to
        jump immediately to whatever comes after the catch block in its
        script. Here’s an example with two nested invocations of catch,
        with the upvar renamed in the outer one:
      </para>
      <para>
        As shown, this will say 1, then 2, then 3, then exit both nested
        catches and think “Hmm.” If in the run block the variable break
        is used instead of outer, then the script will say 1, 2, 3, and
        “Hello!” before thinking “Hmm.”
      </para>
      <para>
        There are corresponding catch and throw blocks for reporters.
        The catch block is a reporter that takes an expression as input
        instead of a C-shaped slot. But the throw block is a command; it
        doesn’t report a value to its own continuation, but instead
        reports a value (which it takes as an additional input, in
        addition to the catch tag) to <emphasis>the corresponding catch
        block</emphasis>’s continuation:
      </para>
<literallayout>Without the throw, the inner call reports 5, the + block reports 8, so the catch block reports 8, and the × block reports 80. With the throw, the inner call doesn’t report at all, and neither does the + block. The throw block’s input of 20 becomes the value reported by the catch block, and the × block multiplies 10 and 20.
<emphasis role="strong">Creating a Thread System</emphasis></literallayout>
      <para>
        Snap<emphasis>!</emphasis> can be running several scripts at
        once, within a single sprite and across many sprites. If you
        only have one computer, how can it do many things at once? The
        answer is that only one is actually running at any moment, but
        Snap<emphasis>!</emphasis> switches its attention from one
        script to another frequently. At the bottom of every looping
        block (repeat, repeat until, forever), there is an implicit
        “yield” command, which remembers where the current script is up
        to, and switches to some other script, each in turn. At the end
        of every script is an implicit “end thread” command (a
        <emphasis>thread</emphasis> is the technical term for the
        process of running a script), which switches to another script
        without remembering the old one.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image928.png" width="2.94792in" depth="4.25417in" />
          </imageobject>
        </inlinemediaobject>Since this all happens automatically, there
        is generally no need for the user to think about threads. But,
        just to show that this, too, is not magic, here is an
        implementation of a simple thread system. It uses a global
        variable named tasks that initially contains an empty list. Each
        use of the C-shaped thread block adds a continuation (the ringed
        script) to the list. The yield block uses run w/continuation to
        create a continuation for a partly done thread, adds it to the
        task list, and then runs the first waiting task. The
        end<emphasis role="strong"> </emphasis>thread block (which is
        automatically added at the end of every thread’s script by the
        thread block) just runs the next waiting task.
      </para>
      <para>
        Here is a sample script using the thread system. One thread says
        numbers; the other says letters. The number thread yields after
        every prime number, while the letter thread yields after every
        vowel. So the sequence of speech balloons is
        1,2,a,3,b,c,d,e,4,5,f,g,h,i,6,7,j,k,l,m,n,o,8,9,10,11,
        p,q,r,s,t,u,12,13,v,w,x,y,z,14,15,16,17,18,…30.
      </para>
      <para>
        If we wanted this to behave exactly like
        Snap<emphasis>!</emphasis>’s own threads, we’d define new
        versions of repeat and so on that run yield after each
        repetition.
      </para>
    </section>
  </section>
</section>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="metaprogramming">
  <title>
  Metaprogramming</title>
  <para>
    The scripts and custom blocks that make up a program can be examined
    or created by the program itself.
  </para>
  <section xml:id="reading-a-block">
    <title>Reading a block</title>
    <para>
      The definition of block takes a custom block (in a ring, since
      it’s the block itself that’s the input, not the result of calling
      the block) as input and reports the block’s definition, i.e., its
      inputs and body, in the form of a ring with named inputs
      corresponding to the block’s input names, so that those input
      names are bound in the body.
    </para>
    <para>
      The split by blocks block takes any expression or script as input
      (ringed) and reports a list representing a <emphasis>syntax
      tree</emphasis> for the script or expression, in which the first
      item is a block with no inputs and the remaining items are the
      input values, which may themselves be syntax trees.
    </para>
    <para>
      Using split by blocks to select custom blocks whose definitions
      contain another block gives us this debugging aid:
    </para>
    <para>
      Note in passing the my blocks block, which reports a list of all
      visible blocks, primitive and custom. (There’s also a my
      categories block, which reports a list of the names of the palette
      categories.) Also note custom? of block, which reports True if its
      input is a custom block.
    </para>
  </section>
  <section xml:id="writing-a-block">
    <title>Writing a block</title>
    <para>
      The inverse function to split by blocks is provided by the join
      block, which when given a syntax tree as input reports the
      corresponding expression or script.
    </para>
    <para>
      Here we are taking the definition of square, modifying the
      repetition count (to 6), modifying the turning angle (to 60),
      using join to turn the result back into a ringed definition, and
      using the define block to create a new hexagon block.
    </para>
    <para>
      The define block has three “input” slots. The quotation marks are
      there because the first slot is an upvar, i.e., a way for define
      to provide information to its caller, rather than the other way
      around. In this case, the value of block is the new block itself
      (the hexagon block, in this example). The second slot is where you
      give the <emphasis>label</emphasis> for the new block. In this
      example, the label is “hexagon _” in which the underscore
      represents an input slot. So, here are a few examples of block
      labels:
    </para>
    <para>
      set pen _ to _
    </para>
    <para>
      for _ = _ to _ _
    </para>
    <para>
      ask _ and wait
    </para>
    <para>
      _ of _
    </para>
    <para>
      Note that the underscores are separated from the block text by
      spaces. Note in the case of the for block’s label that the upvar
      (the i) and the C-slot both count as inputs. Note also that the
      label is not meant to be a unique symbol that represents only this
      block. For example, <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image628.png" width="0.86111in" depth="0.19444in" />
        </imageobject>
      </inlinemediaobject> and <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image376.png" width="1.15in" depth="0.19in" />
        </imageobject>
        <textobject>
          <phrase>A picture containing text, hitting Description automatically generated</phrase>
        </textobject>
      </inlinemediaobject> both have the label
    </para>
    <para>
      _ of _. The label does not give the input slots names (that’s done
      in the body, coming next) or types (that’s done in the set _ of
      block _ to _ block, coming in two paragraphs).
    </para>
    <para>
      The third slot is for the <emphasis>definition</emphasis> of the
      new block. This is a (ringed) script whose input names (formal
      parameters) will become the formal parameters of the new block.
      And the script is its script.
    </para>
    <para>
      So far we know the block’s label, parameters, and script. There
      are other things to specify about the block, and one purpose of
      the block upvar is to allow that. In the example on the previous
      page, there are four
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image951.png" width="2.83in" depth="0.97in" />
        </imageobject>
        <textobject>
          <phrase>Graphical user interface, website Description automatically generated</phrase>
        </textobject>
      </inlinemediaobject>set _ of block _ to _ blocks, reproduced below
      for your convenience:
    </para>
    <para>
      The category of the block can be set to any primitive or custom
      category. The default is other. The type is command, reporter, or
      predicate. Command is the default, so this setting is redundant,
      but we want to show all the choices in the set block. The scope is
      either global or sprite, with global as the default. The last
      input to set slots is a list of length less than or equal to the
      number of underscores in the label. Each item of the list is a
      type name, like the ones in the is (5) a (number)? block. If there
      is only one input, you can use just the name instead of putting it
      in a list. An empty or missing list item means type Any.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image952.png" width="4.31in" depth="0.83in" />
        </imageobject>
        <textobject>
          <phrase>Graphical user interface, text, application, chat or text message Description automatically generated</phrase>
        </textobject>
      </inlinemediaobject>It's very important that these set blocks
      appear in the same script as the define that creates the block,
      because the block upvar is local to that script. You can’t later
      say, for example,
    </para>
    <para>
      because the copy of the hexagon block in this instruction counts
      as “using” it.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image953.png" width="2.6in" depth="0.32in" />
        </imageobject>
      </inlinemediaobject>The of block reporter is useful to copy
      attributes from one block to another, as we copied the definition
      of square, modified it, and used it to define hexagon. Some of the
      values this block reports are a little unfriendly:
    </para>
    <para>
      “1”? Yes, this block reports <emphasis>numbers</emphasis> instead
      of names for category, type, and scope. The reason is that maybe
      someday we’ll have translations to other languages for custom
      category names, as we already do for the built-in categories,
      types, and scopes; if you translate a program using this block to
      another language, the numeric outputs won’t change, simplifying
      comparisons in your code. The set block accepts these numbers as
      an alternative to the names.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image954.png" width="3.37986in" depth="0.37986in" />
        </imageobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image955.png" width="1.02in" depth="0.25in" />
        </imageobject>
        <textobject>
          <phrase>A picture containing text, clipart Description automatically generated</phrase>
        </textobject>
      </inlinemediaobject>There are a few more attributes of a block,
      less commonly used.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image956.png" width="3.51944in" depth="0.61944in" />
        </imageobject>
        <textobject>
          <phrase>Graphical user interface, text, website Description automatically generated</phrase>
        </textobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image961.png" width="3.29097in" depth="0.60972in" />
        </imageobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image962.png" width="2.35in" depth="2.56in" />
        </imageobject>
        <textobject>
          <phrase>Graphical user interface, application Description automatically generated</phrase>
        </textobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image963.png" width="1.66944in" depth="0.25in" />
        </imageobject>
        <textobject>
          <phrase>Graphical user interface, text, application Description automatically generated</phrase>
        </textobject>
      </inlinemediaobject>The list input is just like the one for set
      slots except for default values instead of types. Now for a block
      with a menu input:
    </para>
    <para>
      Prefer a read-only menu?
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image964.png" width="4.16944in" depth="1.26944in" />
        </imageobject>
        <textobject>
          <phrase>Graphical user interface, website Description automatically generated</phrase>
        </textobject>
      </inlinemediaobject>We passed too quickly over how the script
      turned the square block into a hexagon block:
    </para>
    <para>
      Those replace item blocks aren’t very elegant. I had to look at
      foo by hand to figure out where the numbers I wanted to change
      are. This situation can be improved with a little programming:
    </para>
    <para>
      Exercise for the reader: Implement this:<inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image971.png" width="3.11in" depth="0.57in" />
        </imageobject>
        <textobject>
          <phrase>Graphical user interface Description automatically generated</phrase>
        </textobject>
      </inlinemediaobject>
    </para>
    <para>
      Returning to the define block, there’s another reason for the
      block upvar: It’s helpful in defining a recursive procedure using
      define. For a procedure to call itself, it needs a name for
      itself. But in the definition input to the define block, define
      itself hasn’t been called yet, so the new block isn’t in the
      palette yet. So you do this:
    </para>
    <para>
      Yes, you put block in the define, but it gets changed into this
      script in the resulting definition. You could use this script
      directly in a simple case like this, but in a complicated case
      with a recursive call inside a ring inside the one giving the
      block definition, this script always means the innermost ring. But
      the upvar means the outer ring; note how the definition of
      blockify automatically creates a script variable to hold the outer
      environment.
    </para>
    <para>
      It’s analogous to using explicit formal parameters when you nest
      calls to higher order functions.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image992.png" width="3.03958in" depth="0.23958in" />
        </imageobject>
      </inlinemediaobject>Note: Ordinarily, when you call a function
      that reports a (ringed) procedure, that procedure was created in
      some specific environment, and has access to that environment’s
      variables. This is how instance variables (fields) work in object
      oriented programming (Chapter VIII). But the procedures made by
      join of a syntax tree have no associated environment, not even the
      one containing global variables. That doesn’t matter if the
      procedure will use only its own input variables, but for access to
      other variables, use
    </para>
  </section>
  <section xml:id="macros">
    <title>Macros</title>
    <para>
      Users of languages in the C family have learned to think of macros
      as entirely about text strings, with no relation to the syntax of
      the language. So you can do things like
    </para>
    <para>
      #define foo baz)
    </para>
    <para>
      with the result that you can only use the foo macro after an open
      parenthesis.
    </para>
    <para>
      In the Lisp family of languages we have a different tradition, in
      which macros are syntactically just like procedure calls, except
      that the “procedure” is a macro, with different evaluation rules
      from ordinary procedures. Two things make a macro different: its
      input expressions are not evaluated, so a macro can establish its
      own syntax (but still delimited by parentheses, in Lisp, or still
      one block, in Snap<emphasis>!</emphasis> ); and the result of a
      macro call is a new expression that is evaluated <emphasis>as if
      it appeared in the caller</emphasis> of the macro, with access to
      the caller’s variables and, implicitly, its continuation.
    </para>
    <para>
      Snap<emphasis>!</emphasis> has long had the first part of this,
      the ability to make inputs unevaluated. In version 8.0 we add the
      ability to run code in the context of another procedure, just as
      we can run code in the context of another sprite, using the same
      mechanism: the of block. In the example on the previous page, the
      if _ report _ caller _ block runs a report block, but not in its
      own context; it causes <emphasis>the fizzbuzz block</emphasis> to
      report “fizz” or “buzz” as appropriate. (Yes, we know that the
      rules implemented here are simplified compared to the real game.)
      It doesn’t just report out of the entire toplevel script; you can
      see that map is able to prepend “The answer is” to each reported
      value.
    </para>
    <para>
      This macro capability isn’t fully implemented. First, we shouldn’t
      have to use the calling script as an explicit input to the macro.
      In a later release, this will be fixed; when defining a block
      you’ll be able to say that it’s a macro, and it will automatically
      get its caller’s context as an invisible input. Second, there is a
      possibility of confusion between the variables of the macro and
      the variables of its caller. (What if the macro wanted to refer to
      a variable value in its caller?) The one substantial feature of
      Scheme that we don’t yet implement is <emphasis>hygienic
      macros,</emphasis> which make it possible to keep the two
      namespaces separate.
    </para>
  </section>
</section>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="user-interface-elements">
  <title>User Interface Elements</title>
  <para>
    In this chapter we describe in detail the various buttons, menus,
    and other clickable elements of the Snap<emphasis>!</emphasis> user
    interface. Here again is the map of the Snap<emphasis>!</emphasis>
    window:
  </para>
  <para>
    <inlinemediaobject>
      <imageobject>
        <imagedata fileref="media/image993.png" width="7.49442in" depth="4.66319in" />
      </imageobject>
    </inlinemediaobject>
  </para>
  <section xml:id="tool-bar-features">
    <title>Tool Bar Features</title>
    <para>
      Holding down the Shift key while clicking on any of the menu
      buttons gives access to an extended menu with options, shown in
      red, that are experimental or for use by the developers. We’re not
      listing those extra options here because they change frequently
      and you shouldn’t rely on them. But they’re not secrets.
    </para>
    <section xml:id="the-snap-logo-menu">
      <title>The Snap<emphasis>!</emphasis> Logo Menu</title>
      <para>
        The Snap<emphasis>!</emphasis> logo at the left end of the tool
        bar is clickable. It shows a menu of options about
        Snap<emphasis>!</emphasis> itself:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image994.png" width="2.32922in" depth="1.02in" />
          </imageobject>
        </inlinemediaobject>
      </para>
      <para>
        The About option displays information about
        Snap<emphasis>!</emphasis> itself, including version numbers for
        the source modules, the implementors, and the license (AGPL: you
        can do anything with it except create proprietary versions,
        basically).
      </para>
      <para>
        The Reference manual option downloads a copy of the latest
        revision of this manual in PDF format.
      </para>
      <para>
        The Snap! website option opens a browser window pointing to
        snap.berkeley.edu, the web site for Snap<emphasis>!</emphasis>.
      </para>
      <para>
        The Download source option opens a browser window displaying the
        Github repository of the source files for
        Snap<emphasis>!</emphasis>. At the bottom of the page are links
        to download the latest official release. Or you can navigate
        around the site to find the current development version. You can
        read the code to learn how Snap<emphasis>!</emphasis> is
        implemented, host a copy on your own computer (this is one way
        to keep working while on an airplane), or make a modified
        version with customized features. (However, access to cloud
        accounts is limited to the official version hosted at Berkeley.)
      </para>
    </section>
    <section xml:id="the-file-menu">
      <title>The File Menu</title>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image384.png" width="0.31944in" depth="0.18056in" />
          </imageobject>
        </inlinemediaobject>The file icon shows a menu mostly about
        saving and loading projects. You may not see all these options,
        if you don’t have multiple sprites, scenes, custom blocks, and
        custom categories.
      </para>
      <para>
        The Notes option opens a window in which you can type notes
        about the project: How to use it, what it does, whose project
        you modified to create it, if any, what other sources of ideas
        you used, or any other information about the project. This text
        is saved with the project, and is useful if you share it with
        other users.
      </para>
      <para>
        The New option starts a new, empty project. Any project you were
        working on before disappears, so you are asked to confirm that
        this is really what you want. (It disappears only from the
        current working Snap<emphasis>!</emphasis> window; you should
        save the current project, if you want to keep it, before using
        New.)
      </para>
      <para>
        Note the ^N at the end of the line. This indicates that you can
        type control-N as a shortcut for this menu item. Alas, this is
        not the case in every browser. Some Mac browsers require
        command-N (⌘N) instead, while others open a new browser window
        instead of a new project. You’ll have to experiment. In general,
        the keyboard shortcuts in Snap<emphasis>!</emphasis> are the
        standard ones you expect in other software.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image995.png" width="2.88958in" depth="2.09792in" />
          </imageobject>
        </inlinemediaobject>The Open… option shows a project open dialog
        box in which you can choose a project to open:
      </para>
      <para>
        In this dialog, the three large buttons at the left select a
        source of projects: Cloud means your Snap<emphasis>!</emphasis>
        account’s cloud storage. Examples means a collection of sample
        projects we provide. Computer is for projects saved on your own
        computer; when you click it, this dialog is replaced with your
        computer’s system dialog for opening files. The text box to the
        right of those buttons is an alphabetical listing of projects
        from that source; selecting a project by clicking shows its
        thumbnail (a picture of the stage when it was saved) and its
        project notes at the right.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image996.png" width="2.72431in" depth="1.97778in" />
          </imageobject>
        </inlinemediaobject>The search bar at the top can be used to
        find a project by name or text in the project notes. So in this
        example:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image997.png" width="2.72361in" depth="1.97778in" />
          </imageobject>
        </inlinemediaobject>I was looking for my ice cream projects and
        typed “crea” in the search bar, then wondered why “ferris”
        matched. But then when I clicked on ferris I saw this:
      </para>
      <para>
        My search matched the word “re<emphasis>crea</emphasis>te” in
        the project notes.
      </para>
      <para>
        The six buttons at the bottom select an action to perform on the
        selected project. In the top row, Recover looks in your cloud
        account for older versions of the chosen project.
        <emphasis><emphasis role="strong">If your project is damaged,
        don’t keep saving broken versions! Use Recover first
        thing.</emphasis></emphasis> You will see a list of saved
        versions; choose one to open it. Typically, you’ll see the most
        recent version before the last save, and the newest version
        saved before today. Then come buttons Share/Unshare and
        Publish/Unpublish. The labelling of the buttons depends on your
        project’s publication status. If a project is neither shared nor
        published (the ones in lightface type in the project list), it
        is private and nobody can see it except you, its owner. If it is
        shared (boldface in the project list), then when you open it
        you’ll see a URL like this one:
      </para>
      <para>
        https://snap.berkeley.edu/snapsource/snap.html#present:Username=bh&amp;ProjectName=count%20change
      </para>
      <para>
        but with your username and project name. (“%20” in the project
        name represents a space, which can’t be part of a URL.) Anyone
        who knows this URL can see your project. Finally, if your
        project is published (<emphasis><emphasis role="strong">bold
        italic</emphasis></emphasis> in the list), then your project is
        shown on the Snap<emphasis>!</emphasis> web site for all the
        world to see. (In all of these cases, you are the only one who
        can <emphasis>write</emphasis> to (save) your project. If
        another user saves it, a separate copy will be saved in that
        user’s account. Projects remember the history of who created the
        original version and any other “remix” versions along the way.
      </para>
      <para>
        In the second row, the first button, Open, loads the project
        into Snap<emphasis>!</emphasis> and closes the dialog box. The
        next button (if Cloud is the source) is Delete, and if clicked
        it deletes the selected project. Finally, the Cancel button
        closes the dialog box without opening a project. (It does not
        undo any sharing, unsharing, or deletion you’ve done.)
      </para>
      <para>
        Back to the File menu, the Save menu option saves the project to
        the same source and same name that was used when opening the
        project. (If you opened another user’s shared project or an
        example project, the project will be saved to your own cloud
        account. You must be logged in to save to the cloud.)
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image998.png" width="3.23611in" depth="2.34931in" />
          </imageobject>
        </inlinemediaobject>The Save as… menu option opens a dialog box
        in which you can specify where to save the project:
      </para>
      <para>
        This is much like the Open dialog, except for the horizontal
        text box at the top, into which you type a name for the project.
        You can also publish, unpublish, share, unshare, and delete
        projects from here. There is no Recover button.
      </para>
      <para>
        The Import… menu option is for bringing some external resource
        into the current project, or it can load an entirely separate
        project, from your local disk. You can import costumes (any
        picture format that your browser supports), sounds (again, any
        format supported by your browser), and block libraries or
        sprites (XML format, previously exported from
        Snap<emphasis>!</emphasis> itself). Imported costumes and sounds
        will belong to the currently selected sprite; imported blocks
        are global (for all sprites). Using the Import option is
        equivalent to dragging the file from your desktop onto the
        Snap<emphasis>!</emphasis> window.
      </para>
      <para>
        Depending on your browser, the Export project… option either
        directly saves to your disk or opens a new browser tab
        containing your complete project in XML notation (a plain text
        format). You can then use the browser’s Save feature to save the
        project as an XML file, which should be named
        <emphasis>something</emphasis>.xml so that
        Snap<emphasis>!</emphasis> will recognize it as a project when
        you later drag it onto a Snap<emphasis>!</emphasis> window. This
        is an alternative to saving the project to your cloud account:
        keeping it on your own computer. It is equivalent to choosing
        Computer from the Save dialog described earlier.
      </para>
      <para>
        The Export summary… option creates a web page, in HTML, with all
        of the information about your project: its name, its project
        notes, a picture of what’s on its stage, definitions of global
        blocks, and then per-sprite information: name, wardrobe (list of
        costumes), and local variables and block definitions. The page
        can be converted to PDF by the browser; it’s intended to meet
        the documentation requirements of the Advanced Placement
        Computer Science Principles create task.
      </para>
      <para>
        The Export blocks… option is used to create a block library. It
        presents a list of all the global (for all sprites) blocks in
        your project, and lets you select which to export. It then opens
        a browser tab with those blocks in XML format, or stores
        directly to your local disk, as with the Export project option.
        Block libraries can be imported with the Import option or by
        dragging the file onto the Snap<emphasis>!</emphasis> window.
        This option is shown only if you have defined custom blocks.
      </para>
      <para>
        The Unused blocks… option presents a listing of all the global
        custom blocks in your project that aren’t used anywhere, and
        offers to delete them. As with Export blocks, you can choose a
        subset to delete with checkboxes. This option is shown only if
        you have defined custom blocks.
      </para>
      <para>
        The Hide blocks… option shows <emphasis>all</emphasis> blocks,
        including primitives, with checkboxes. This option does not
        remove any blocks from your project, but it does hide selected
        block in your palette. The purpose of the option is to allow
        teachers to present students with a simplified
        Snap<emphasis>!</emphasis> with some features effectively
        removed. The hiddenness of primitives is saved with each
        project, so students can load a shared project and see just the
        desired blocks. But users can always unhide blocks by choosing
        this option and unclicking all the checkboxes. (Right-click in
        the background of the dialog box to get a menu from which you
        can check all boxes or uncheck all boxes.)
      </para>
      <para>
        The New category… option allows you to add your own categories
        to the palette. It opens a dialog box in which you specify a
        name <emphasis>and a color</emphasis> for the category. (A
        lighter version of the same color will be used for the zebra
        coloring feature.)
      </para>
      <para>
        The Remove a category… option appears only if you’ve created
        custom categories. It opens a very small, easy-to-miss menu of
        category names just under the file icon in the menu bar. If you
        remove a category that has blocks in it, all those blocks are
        also removed.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image999.png" width="1.16667in" depth="0.19792in" />
          </imageobject>
        </inlinemediaobject>The next group of options concern the
        <emphasis>scenes</emphasis> feature, new in
        Snap<emphasis>!</emphasis> 7.0. A scene is a complete project,
        with its own stage, sprites, and code, but several can be merged
        into one project, using the block to bring another scene
        onscreen. The Scenes… option presents a menu of all the scenes
        in your project, where the File menu was before you clicked it.
        The New scene option creates a new, empty scene, which you can
        rename as you like from its context menu. Add scene… is like
        Import… but for scenes. (A complete project can be imported as a
        scene into another project, so you have to specify that you’re
        importing the project <emphasis>as a scene</emphasis> rather
        than replacing the current project.)
      </para>
      <para>
        The Libraries… option presents a menu of useful, optional block
        libraries:
      </para>
      <para>
        The library menu is divided into five broad categories. The
        first is, broadly, utilities: blocks that might well be
        primitives. They might be useful in all kinds of projects.
      </para>
      <para>
        The second category is blocks related to media computation: ones
        that help in dealing with costumes and sounds (a/k/a Jens
        libraries). There is some overlap with “big data” libraries, for
        dealing with large lists of lists.
      </para>
      <para>
        The third category is, roughly, specific to non-media
        applications (a/k/a Brian libraries). Three of them are imports
        from other programming languages: words and sentences from Logo,
        array functions from APL, and streams from Scheme. Most of the
        others are to meet the needs of the BJC curriculum.
      </para>
      <para>
        The fourth category is major packages provided by users.
      </para>
      <para>
        The fifth category provides support for hardware devices such as
        robots, through general interfaces, replacing specific hardware
        libraries in versions before 7.0.
      </para>
      <para>
        When you click on the one-line description of a library, you are
        shown the actual blocks in the library and a longer explanation
        of its purpose. You can browse the libraries to find one that
        will satisfy your needs. The libraries are described in detail
        in Section I.H, page <link linkend="libraries">25</link>.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1000.png" width="4.28125in" depth="3.23958in" />
          </imageobject>
        </inlinemediaobject>The Costumes… option opens a browser into
        the costume library:
      </para>
      <para>
        You can import a single costume by clicking it and then clicking
        the Import button. Alternatively, you can import more than one
        costume by double-clicking each one, and then clicking Cancel
        when done. Notice that some costumes are tagged with “svg” in
        this picture; those are vector-format costumes that are not
        (yet) editable within Snap<emphasis>!</emphasis>.
      </para>
      <para>
        If you have the stage selected in the sprite corral, rather than
        a sprite, the Costumes… option changes to a Backgrounds… option,
        with different choices in the browser:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1001.png" width="4.28125in" depth="3.23958in" />
          </imageobject>
        </inlinemediaobject>The costume and background libraries include
        both bitmap (go jagged if enlarged) and vector (enlarge
        smoothly) images. Thanks to Scratch 2.0/3.0 for most of these
        images! Some older browsers refuse to import a vector image, but
        instead convert it to bitmap.
      </para>
      <para>
        The Sounds… option opens the third kind of media browser:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1002.png" width="4.28125in" depth="3.23958in" />
          </imageobject>
        </inlinemediaobject>The Play buttons can be used to preview the
        sounds.
      </para>
      <para>
        Finally, the Undelete sprites… option appears only if you have
        deleted a sprite; it allows you to recover a sprite that was
        deleted by accident (perhaps intending to delete only a
        costume).
      </para>
    </section>
    <section xml:id="the-cloud-menu">
      <title>The Cloud Menu</title>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1003.png" width="1.43681in" depth="0.75972in" />
          </imageobject>
        </inlinemediaobject><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1004.png" width="0.29167in" depth="0.16667in" />
          </imageobject>
        </inlinemediaobject>The cloud icon shows a menu of options
        relating to your Snap<emphasis>!</emphasis> cloud account. If
        you are not logged in, you see the outline icon and get this
        menu:
      </para>
      <para>
        Choose Login… if you have a Snap<emphasis>!</emphasis> account
        and remember your password. Choose Signup… if you don’t have an
        account. Choose Reset Password… if you’ve forgotten your
        password or just want to change it. You will then get an email,
        at the address you gave when you created your account, with a
        new temporary password. Use that password to log in, then you
        can choose your own password, as shown below. Choose Resend
        Verification Email… if you have just created a
        Snap<emphasis>!</emphasis> account but can’t find the email we
        sent you with the link to verify that it’s really your email.
        (If you still can’t find it, check your spam folder. If you are
        using a school email address, your school may block incoming
        email from outside the school.) The Open in Community Site
        option appears only if you have a project open; it takes you to
        the community site page about that project.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1007.png" width="1.61111in" depth="0.65278in" />
          </imageobject>
        </inlinemediaobject>If you are already logged in, you’ll see the
        solid icon <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1008.png" width="0.29167in" depth="0.16667in" />
          </imageobject>
        </inlinemediaobject> and get this menu:
      </para>
      <para>
        Logout is obvious, but has the additional benefit of showing you
        who’s logged in. Change password… will ask for your old password
        (the temporary one if you’re resetting your password) and the
        new password you want, entered twice because it doesn’t echo.
        Open in Community Site is the same as above.
      </para>
    </section>
    <section xml:id="the-settings-menu">
      <title>
      The Settings Menu</title>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1009.png" width="1.24792in" depth="2.58333in" />
          </imageobject>
        </inlinemediaobject><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1010.png" width="0.29167in" depth="0.16667in" />
          </imageobject>
        </inlinemediaobject>The settings icon shows a menu of
        Snap<emphasis>!</emphasis> options, either for the current
        project or for you permanently, depending on the option:
      </para>
      <para>
        The Language… option lets you see the Snap<emphasis>!</emphasis>
        user interface (blocks and messages) in a language other than
        English. (Note: Translations have been provided by
        Snap<emphasis>!</emphasis> users. If your native language is
        missing, send us an email!)
      </para>
      <para>
        The Zoom blocks... option lets you change the size of blocks,
        both in the palettes and in scripts. The standard size is 1.0
        units. The main purpose of this option is to let you take very
        high-resolution pictures of scripts for use on posters. It can
        also be used to improve readability when projecting onto a
        screen while lecturing, but bear in mind that it doesn’t make
        the palette or script areas any wider, so your computer’s
        command-option-+ feature may be more practical. Note that a zoom
        of 2 is gigantic! Don’t even try 10.
      </para>
      <para>
        The Fade blocks… option opens a dialog in which you can change
        the appearance of blocks:
      </para>
      <para>
        Mostly this is a propaganda aid to use on people who think that
        text languages are somehow better or more grown up than block
        languages, but some people do prefer less saturated block
        colors. You can use the pulldown menu for preselected fadings,
        use the slider to see the result as you change the fading
        amount, or type a number into the text box once you’ve
        determined your favorite value.
      </para>
      <para>
        The Stage size… option lets you set the size of the
        <emphasis>full-size</emphasis> stage in pixels. If the stage is
        in half-size or double-size (presentation mode), the stage size
        values don’t change; they always reflect the full-size stage.
      </para>
      <para>
        The Microphone resolution… option sets the buffer size used by
        the microphone block in Settings. “Resolution” is an accurate
        name if you are getting frequency domain samples; the more
        samples, the narrower the range of frequencies in each sample.
        In the time domain, the buffer size determines the length of
        time over which samples are collected.
      </para>
      <para>
        The remaining options let you turn various features on and off.
        There are three groups of checkboxes. The first is for temporary
        settings not saved in your project nor in your user preferences.
      </para>
      <para>
        The JavaScript extensions option enables the use of the
        JavaScript function block. Because malicious projects could use
        JavaScript to collect private information about you, or to
        delete or modify your saved projects, you must enable JavaScript
        <emphasis>each time</emphasis> you load a project that uses it.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1021.png" width="1.18958in" depth="0.18958in" />
          </imageobject>
          <textobject>
            <phrase>Graphical user interface, application Description automatically generated</phrase>
          </textobject>
        </inlinemediaobject><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1022.png" width="1.22986in" depth="0.25972in" />
          </imageobject>
          <textobject>
            <phrase>Graphical user interface, text, application Description automatically generated</phrase>
          </textobject>
        </inlinemediaobject>The Extension blocks option adds two blocks
        to the palette:
      </para>
      <para>
        These blocks provide assorted capabilities to official libraries
        that were formerly implemented with the JavaScript function
        block. This allows these libraries to run without requiring the
        JavaScript extensions option. Details are subject to change.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1023.png" width="1.10486in" depth="2.08333in" />
          </imageobject>
        </inlinemediaobject><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1024.png" width="1.63889in" depth="0.41319in" />
          </imageobject>
        </inlinemediaobject>Input sliders provides an alternate way to
        put values in numeric input slots; if you click in such a slot,
        a slider appears that you can control with the mouse:
      </para>
      <para>
        The range of the slider will be from 25 less than the input’s
        current value to 25 more than the current value. If you want to
        make a bigger change than that, you can slide the slider all the
        way to either end, then click on the input slot again, getting a
        new slider with a new center point. But you won’t want to use
        this technique to change the input value from 10 to 1000, and it
        doesn’t work at all for non-integer input ranges. This feature
        was implemented because software keyboard input on phones and
        tablets didn’t work at all in the beginning, and still doesn’t
        work perfectly on Android devices, so sliders provide a
        workaround. It has since found another use in providing “lively”
        response to input changes; if Input sliders is checked,
        reopening the settings menu will show an additional option
        called Execute on slider change. If this option is also checked,
        then changing a slider in the scripting area automatically runs
        the script in which that input appears. The project live-tree in
        the Examples collection shows how this can be used; it features
        a fractal tree custom block with several inputs, and you can see
        how each input affects the picture by moving a slider.
      </para>
      <para>
        Turbo mode makes many projects run much faster, at the cost of
        not keeping the stage display up to date.
        (Snap<emphasis>!</emphasis> ordinarily spends most of its time
        drawing sprites and updating variable watchers, rather than
        actually carrying out the instructions in your scripts.) So
        turbo mode isn’t a good idea for a project with glide blocks or
        one in which the user interacts with animated characters, but
        it’s great for drawing a complicated fractal, or computing the
        first million digits of 𝜋, so that you don’t need to see
        anything until the final result. While in turbo mode, the button
        that normally shows a green flag instead shows a green lightning
        bolt. (But when ⚑ clicked hat blocks still activate when the
        button is clicked.)
      </para>
      <para>
        Visible stepping enables the slowed-down script evaluation
        described in Chapter I. Checking this option is equivalent to
        clicking the footprint button above the scripting area. You
        don’t want this on except when you’re actively debugging,
        because even the fastest setting of the slider is still slowed a
        lot.
      </para>
      <para>
        Log pen vectors<anchor xml:id="logpenvectors" /> tells
        Snap<emphasis>!</emphasis> to remember lines drawn by sprites as
        exact vectors, rather than remember only the pixels that the
        drawing leaves on the stage. This remembered vector picture can
        be used in two ways: First, right-clicking on a pen trails block
        gives an option to relabel it into a pen vectors block which,
        when run, reports the logged lines as a vector (svg) costume.
        Second, right-clicking on the stage when there are logged
        vectors shows an extra option, svg…, that exports a picture of
        the stage in vector format. Only lines are logged, not color
        regions made with the fill block.
      </para>
      <para>
        The next group of four are user preference options, preserved
        when you load a new project. Long form input dialog, if checked,
        means that whenever a custom block input name is created or
        edited, you immediately see the version of the input name dialog
        that includes the type options, default value setting, etc.,
        instead of the short form with just the name and the choice
        between input name and title text. The default (unchecked)
        setting is definitely best for beginners, but more experienced
        Snap<emphasis>!</emphasis> programmers may find it more
        convenient always to see the long form.
      </para>
      <para>
        Plain prototype labels eliminates the plus signs between words
        in the Block Editor prototype block. This makes it harder to add
        an input to a custom block; you have to hover the mouse where
        the plus sign would have been, until a single plus sign appears
        temporarily for you to click on. It’s intended for people making
        pictures of scripts in the block editor for use in
        documentation, such as this manual. You probably won’t need it
        otherwise.
      </para>
      <para>
        Clicking sound causes a really annoying sound effect whenever
        one block snaps next to another in a script. Certain very young
        children, and our colleague Dan Garcia, like this, but if you
        are such a child you should bear in mind that driving your
        parents or teachers crazy will result in you not being allowed
        to use Snap<emphasis>!</emphasis>. It might, however, be useful
        for visually impaired users.
      </para>
      <para>
        Flat design changes the “skin” of the Snap<emphasis>!</emphasis>
        window to a really hideous design with white and pale-grey
        background, rectangular rather than rounded buttons, and
        monochrome blocks (rather than the shaded, somewhat 3D-looking
        normal blocks). The monochrome blocks are the reason for the
        “flat” in the name of this option. The only thing to be said for
        this option is that, because of the white background, it may
        blend in better with the rest of a web page when a
        Snap<emphasis>!</emphasis> project is run in a frame in a larger
        page. (I confess I used it to make the picture of blocks faded
        all the way to just text two pages ago, though.)
      </para>
      <para>
        The final group of settings change the way
        Snap<emphasis>!</emphasis> interprets your program; they are
        saved with the project, so anyone who runs your project will
        experience the same behavior. Thread safe scripts changes the
        way Snap<emphasis>!</emphasis> responds when an event (clicking
        the green flag, say) starts a script, and then, while the script
        is still running, the same event happens again. Ordinarily, the
        running process stops where it is, ignoring the remaining
        commands in the script, and the entire script starts again from
        the top. This behavior is inherited from Scratch, and some
        converted Scratch projects depend on it; that’s why it’s the
        default. It’s also sometimes the right thing, especially in
        projects that play music in response to mouse clicks or
        keystrokes. If a note is still playing but you ask for another
        one, you want the new one to start right then, not later after
        the old process finishes. But if your script makes several
        changes to a database and is interrupted in the middle, the
        result may be that the database is inconsistent. When you select
        Thread safe scripts, the same event happening again in the
        middle of running a script is simply ignored. (This is arguably
        still not the right thing; the event should be remembered and
        the script run again as soon as it finishes. We’ll probably get
        around to adding that choice eventually.) Keyboard events (when
        __ key pressed) are always thread-safe.
      </para>
      <para>
        Flat line ends affects the drawing of thick lines (large pen
        width). Usually the ends are rounded, which looks best when
        turning corners. With this option selected, the ends are flat.
        It’s useful for drawing a brick wall or a filled rectangle.
      </para>
      <para>
        Codification support enables a feature that can translate a
        Snap<emphasis>!</emphasis> project to a text-based (rather than
        block-based) programming language. The feature doesn’t know
        about any particular other language; instead, you can provide a
        translation for each primitive block using these special blocks:
      </para>
      <para>
        Using these primitive blocks, you can build a block library to
        translate into any programming language. Watch for such
        libraries to be added to our library collection (or contribute
        one). To see some examples, open the project “Codification” in
        the Examples project list. Edit the blocks map to Smalltalk, map
        to JavaScript, etc., to see examples of how to provide
        translations for blocks.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1027.png" width="2.20972in" depth="4.96944in" />
          </imageobject>
          <textobject>
            <phrase>Graphical user interface, text, application, chat or text message Description automatically generated</phrase>
          </textobject>
        </inlinemediaobject><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1028.png" width="1.38in" depth="4.79in" />
          </imageobject>
          <textobject>
            <phrase>Graphical user interface, application, Teams Description automatically generated</phrase>
          </textobject>
        </inlinemediaobject>The Single palette option puts all blocks,
        regardless of category, into a single palette. It’s intended
        mainly for use by curriculum developers building
        <emphasis>Parsons problems:</emphasis> projects in which only a
        small set of blocks are provided, and the task is to arrange
        those blocks to achieve a set goal. In that application, this
        option is combined with the hiding of almost all primitive
        blocks. (See page
        <link linkend="context-menus-for-palette-blocks">119</link>.)
        When Single palette is turned on, two additional options
        (initially on) appear in the settings menu; the Show categories
        option controls the appearance of the palette category names
        such as <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1029.png" width="0.36in" depth="0.16in" />
          </imageobject>
        </inlinemediaobject> and <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1030.png" width="0.33in" depth="0.18in" />
          </imageobject>
          <textobject>
            <phrase>A picture containing logo Description automatically generated</phrase>
          </textobject>
        </inlinemediaobject>, while the Show buttons option controls the
        appearance of the <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1031.png" width="0.61in" depth="0.16in" />
          </imageobject>
        </inlinemediaobject> and <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1032.png" width="0.53in" depth="0.16in" />
          </imageobject>
        </inlinemediaobject> buttons in the palette.
      </para>
      <para>
        The HSL pen color model option changes the set pen, change pen,
        and pen blocks to provide menu options hue, saturation, and
        lightness instead of hue, saturation, and brightness (a/k/a
        value). Note: the name “saturation” means something different in
        HSL from in HSV! See Appendix A for all the information you need
        about colors.
      </para>
      <para>
        The Disable click-to-run option tells Snap<emphasis>!</emphasis>
        to ignore user mouse clicks on blocks and scripts if it would
        ordinarily run the block or script. (Right-clicking and dragging
        still work, and so does clicking in an input slot to edit it.)
        This is another Parsons problem feature; the idea is that there
        will be buttons displayed that run code only in teacher-approved
        ways. But kids can uncheck the checkbox. ☺︎
      </para>
    </section>
    <section xml:id="visible-stepping-controls">
      <title>Visible Stepping Controls</title>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image121.png" width="0.37917in" depth="0.21667in" />
          </imageobject>
          <textobject>
            <phrase>Macintosh HD:Users:bh:Desktop:pix:footprints.png</phrase>
          </textobject>
        </inlinemediaobject>After the menu buttons you’ll see the
        project name. After that comes the footprint button used to turn
        on visible stepping and, when it’s on, the slider to control the
        speed of stepping.
      </para>
    </section>
    <section xml:id="stage-resizing-buttons">
      <title>Stage Resizing Buttons</title>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1033.png" width="0.37917in" depth="0.21667in" />
          </imageobject>
        </inlinemediaobject><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1034.png" width="0.37917in" depth="0.21667in" />
          </imageobject>
        </inlinemediaobject><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1035.png" width="0.37917in" depth="0.21667in" />
          </imageobject>
        </inlinemediaobject><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1036.png" width="0.37917in" depth="0.21667in" />
          </imageobject>
        </inlinemediaobject>Still in the tool bar, but above the left
        edge of the stage, are two buttons that change the size of the
        stage. The first is the shrink/grow button. Normally it looks
        like this: Clicking the button displays the stage at half-normal
        size horizontally and vertically (so it takes up ¼ of its usual
        area). When the stage is half size the button looks like this:
        and clicking it returns the stage to normal size. The main
        reason you’d want a half size stage is during the development
        process, when you’re assembling scripts with wide input
        expressions and the normal scripting area isn’t wide enough to
        show the complete script. You’d typically then switch back to
        normal size to try out the project. The next presentation mode
        button normally looks like this: Clicking the button makes the
        stage double size in both dimensions and eliminates most of the
        other user interface elements (the palette, the scripting area,
        the sprite corral, and most of the tool bar). When you open a
        shared project using a link someone has sent you, the project
        starts in presentation mode. While in presentation mode, the
        button looks like this: Clicking it returns to normal (project
        development) mode.
      </para>
    </section>
    <section xml:id="project-control-buttons" role="unnumbered">
      <title>Project Control Buttons</title>
      <para>
        Above the right edge of the stage are three buttons that control
        the running of the project.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1037.png" width="0.38in" depth="0.22in" />
          </imageobject>
        </inlinemediaobject>Technically, the green flag is no more a
        project control than anything else that can trigger a hat block:
        typing on the keyboard or clicking on a sprite. But it’s a
        convention that clicking the flag should start the action of the
        project from the beginning. It’s only a convention; some
        projects have no flag-controlled scripts at all, but respond to
        keyboard controls instead. Clicking the green flag also deletes
        temporary clones.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1038.png" width="0.35in" depth="0.2in" />
          </imageobject>
        </inlinemediaobject>Whenever any script is running (not
        necessarily in the current sprite), the green flag is lit: .
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1039.png" width="0.35in" depth="0.2in" />
          </imageobject>
        </inlinemediaobject>Shift-clicking the button enters Turbo mode,
        and the button then looks like a lightning bolt: .
        Shift-clicking again turns Turbo mode off.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1044.png" width="0.37917in" depth="0.21667in" />
          </imageobject>
        </inlinemediaobject>Scripts can simulate clicking the green flag
        by broadcasting the special message <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1045.png" width="0.30556in" depth="0.30556in" />
          </imageobject>
        </inlinemediaobject>.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1046.png" width="0.37917in" depth="0.21667in" />
          </imageobject>
        </inlinemediaobject><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1047.png" width="0.37917in" depth="0.21667in" />
          </imageobject>
        </inlinemediaobject>The pause button suspends running all
        scripts. If clicked while scripts are running, the button
        changes shape to become a play button: Clicking it while in this
        form resumes the suspended scripts. There is also a pause all
        block in the Control palette that can be inserted in a script to
        suspend all scripts; this provides the essence of a breakpoint
        debugging capability. The use of the pause button is slightly
        different in visible stepping mode, described in Chapter I.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1048.png" width="0.54861in" depth="0.17708in" />
          </imageobject>
        </inlinemediaobject>The stop button stops all scripts, like the
        stop all block. It does <emphasis>not</emphasis> prevent a
        script from starting again in response to a click or keystroke;
        the user interface is always active. There is one exception:
        generic when blocks will not fire after a stop until some
        non-generic event starts a script. The stop button also deletes
        all temporary clones.
      </para>
    </section>
  </section>
  <section xml:id="the-palette-area">
    <title>
    The Palette Area</title>
    <para>
      At the top of the palette area are the eight buttons that select
      which palette (which block category) is shown: Motion, Looks,
      Sound, Pen, Control, Sensing, Operators, and Variables (which also
      includes the List and Other blocks). There are no menus behind
      these buttons.
    </para>
    <section xml:id="buttons-in-the-palette">
      <title>Buttons in the Palette</title>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1049.png" width="0.26042in" depth="0.26042in" />
          </imageobject>
          <textobject>
            <phrase>Macintosh HD:Users:bh:Desktop:pix:search-button.png</phrase>
          </textobject>
        </inlinemediaobject>Under the eight palette selector buttons, at
        the top of the actual palette, are two semi-transparent buttons.
        The first is the <emphasis>search</emphasis> button, which is
        equivalent to typing control-F: It replaces the palette with a
        search bar into which you can type part of the title text of the
        block you’re trying to find. To leave this search mode, click
        one of the eight palette selectors, or type the Escape key.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1050.png" width="0.26042in" depth="0.26042in" />
          </imageobject>
          <textobject>
            <phrase>Macintosh HD:Users:bh:Desktop:pix:make-button.png</phrase>
          </textobject>
        </inlinemediaobject>The other button is equivalent to the “Make
        a block” button, except that the dialog window that it opens has
        the current palette (color) preselected.
      </para>
    </section>
    <section xml:id="context-menus-for-palette-blocks">
      <title>Context Menus for Palette Blocks</title>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1051.png" width="0.86111in" depth="0.45903in" />
          </imageobject>
        </inlinemediaobject>Most elements of the
        Snap<emphasis>!</emphasis> display can be
        control-clicked/right-clicked to show a <emphasis>context
        menu,</emphasis> with items relevant to that element. If you
        control-click/right-click a <emphasis>primitive</emphasis> block
        in the palette, you see this menu:
      </para>
      <para>
        The help… option displays a box with documentation about the
        block. Here’s an example:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1052.png" width="1.62292in" depth="0.88889in" />
          </imageobject>
        </inlinemediaobject><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1053.png" width="3.32222in" depth="2.42778in" />
          </imageobject>
        </inlinemediaobject>If you control-click/right-click a
        <emphasis>custom</emphasis> (user-defined) block in the palette,
        you see this menu:
      </para>
      <para>
        The help… option for a custom block displays the comment, if
        any, attached to the custom block’s hat block in the Block
        Editor. Here is an example of a block with a comment and its
        help display:
      </para>
      <para>
        If the help text includes a URL, it is clickable and will open
        the page in a new tab.
      </para>
      <para>
        The delete block definition… option asks for confirmation, then
        deletes the custom block and removes it from any scripts in
        which it appears. (The result of this removal may not leave a
        sensible script; it’s best to find and correct such scripts
        <emphasis>before</emphasis> deleting a block.) Note that there
        is no option to <emphasis>hide</emphasis> a custom block; this
        can be done in the Block Editor by right-clicking on the hat
        block.
      </para>
      <para>
        The duplicate block definition… option makes a
        <emphasis>copy</emphasis> of the block and opens that copy in
        the Block Editor. Since you can’t have two custom blocks with
        the same title text and input types, the copy is created with
        “(2)” (or a higher number if necessary) at the end of the block
        prototype.
      </para>
      <para>
        The export block definition… option writes a file in your
        browser’s downloads directory containing the definition of this
        block and any other custom blocks that this block invokes,
        directly or indirectly. So the resulting file can be loaded
        later without the risk of red Undefined! blocks because of
        missing dependencies.
      </para>
      <para>
        The edit… option opens a Block Editor with the definition of the
        custom block.
      </para>
    </section>
    <section xml:id="context-menu-for-the-palette-background">
      <title>Context Menu for the Palette Background</title>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1058.png" width="0.98958in" depth="0.58958in" />
          </imageobject>
        </inlinemediaobject>Right-click/control-click on the grey
        <emphasis>background</emphasis> of the palette area shows this
        menu:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1059.png" width="1.6in" depth="2.15972in" />
          </imageobject>
          <textobject>
            <phrase>Graphical user interface, text, application, chat or text message Description automatically generated</phrase>
          </textobject>
        </inlinemediaobject>The find blocks… option does the same thing
        as the magnifying-glass button. The hide blocks… option opens a
        dialog box in which you can choose which blocks (custom as well
        as primitive) should be hidden. (Within that dialog box, the
        context menu of the background allows you to check or uncheck
        all the boxes at once.)
      </para>
      <para>
        The make a category… option, which is intended mainly for
        authors of snap extensions, lets you add custom
        <emphasis>categories</emphasis> to the palette. It opens a small
        dialog window in which you specify a name <emphasis>and a
        color</emphasis> for the new category:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1060.png" width="1.42986in" depth="2.90972in" />
          </imageobject>
          <textobject>
            <phrase>Graphical user interface, application Description automatically generated</phrase>
          </textobject>
        </inlinemediaobject><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1061.png" width="1.53in" depth="1.13in" />
          </imageobject>
          <textobject>
            <phrase>Graphical user interface, text Description automatically generated</phrase>
          </textobject>
        </inlinemediaobject>Pick a dark color, because it will be
        lightened for zebra coloring when users nest blocks of the same
        category. Custom categories are shown below the built-in
        categories in the category selector:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1062.png" width="1.35in" depth="1.83958in" />
          </imageobject>
          <textobject>
            <phrase>Graphical user interface, text, application, chat or text message Description automatically generated</phrase>
          </textobject>
        </inlinemediaobject>This example comes from Eckart Modrow’s
        SciSnap<emphasis>!</emphasis> library. Note that the custom
        category list has its own scroll bar, which appears if you have
        more than six custom categories. Note also that the buttons to
        select a custom category occupy the full width of the palette
        area, unlike the built-in categories, which occupy only half of
        the width. Custom categories are listed in alphabetical order;
        this is why Prof. Modrow chose to start each category name with
        a number, so that he could control their order.
      </para>
      <para>
        If there are no blocks visible in a category, the category name
        is dimmed in the category selector:
      </para>
      <para>
        Here we see that category foo has blocks in it, but categories
        bar and garply are empty. The built-in categories are also
        subject to dimming, if all of the blocks of a category are
        hidden.
      </para>
<literallayout><emphasis role="strong">
Palette Resizing</emphasis></literallayout>
      <para>
        At the right end of the palette area, just to the left of the
        scripting area, is a resizing handle<inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1063.png" width="1.41667in" depth="1.51389in" />
          </imageobject>
        </inlinemediaobject> that can be dragged rightward to increase
        the width of the palette area. This is useful if you write
        custom blocks with very long names. You can’t reduce the width
        of the palette below its standard value.
      </para>
    </section>
  </section>
  <section xml:id="the-scripting-area">
    <title>The Scripting Area</title>
    <para>
      The scripting area is the middle vertical region of the
      Snap<emphasis>!</emphasis> window, containing scripts and also
      some controls for the appearance and behavior of a sprite. There
      is always a <emphasis>current sprite,</emphasis> whose scripts are
      shown in the scripting area. A dark grey rounded rectangle in the
      sprite corral shows which sprite (or the stage) is current. Note
      that it’s only the visible <emphasis>display</emphasis> of the
      scripting area that is “current” for a sprite; all scripts of all
      sprites may be running at the same time. Clicking on a sprite
      thumbnail in the sprite corral makes it current. The stage itself
      can be selected as current, in which case the appearance is
      different, with some primitives not shown.
    </para>
    <section xml:id="sprite-appearance-and-behavior-controls">
      <title>Sprite Appearance and Behavior Controls</title>
      <para>
        At the top of the scripting area are a picture of the sprite and
        some controls for it:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1064.png" width="3.48611in" depth="1.04167in" />
          </imageobject>
        </inlinemediaobject>
      </para>
      <para>
        Note that the sprite picture reflects its rotation, if any.
        There are three things that can be controlled here:
      </para>
      <para>
        1. The three circular buttons in a column at the left control
        the sprite’s <emphasis>rotation</emphasis> behavior. Sprite
        costumes are designed to be right-side-up when the sprite is
        facing toward the right (direction = 90). If the topmost button
        is lit, the default as shown in the picture above, then the
        sprite’s costume rotates as the sprite changes direction. If the
        middle button is selected, then the costume is reversed
        left-right when the sprite’s direction is roughly leftward
        (direction between 180 and 359, or equivalently, between -180
        and -1). If the bottom button is selected, the costume’s
        orientation does not change regardless of the sprite’s
        direction.
      </para>
      <para>
        2. The sprite’s <emphasis>name</emphasis> can be changed in the
        text box that, in this picture, says “Sprite.”
      </para>
      <para>
        3. Finally, if the draggable checkbox is checked, then the user
        can move the sprite on the stage by clicking and dragging it.
        The common use of this feature is in game projects, in which
        some sprites are meant to be under the player’s control but
        others are not.
      </para>
    </section>
    <section xml:id="scripting-area-tabs">
      <title>Scripting Area Tabs</title>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1065.png" width="3.09722in" depth="0.25in" />
          </imageobject>
        </inlinemediaobject>Just below the sprite controls are three
        <emphasis>tabs</emphasis> that determine what is shown in the
        scripting area:
      </para>
    </section>
    <section xml:id="scripts-and-blocks-within-scripts">
      <title>Scripts and Blocks Within Scripts</title>
      <para>
        Most of what’s described in this section also applies to blocks
        and scripts in a Block Editor.
      </para>
      <para>
        Clicking on a script (which includes a single unattached block)
        runs it. If the script starts with a hat block, clicking on the
        script runs it even if the event in the hat block doesn’t
        happen. (This is a useful debugging technique when you have a
        dozen sprites and they each have five scripts with green-flag
        hat blocks, and you want to know what a single one of those
        scripts does.) The script will have a green “halo” around it
        while it’s running. If the script is shared with clones, then
        while it has the green halo it will also have a count of how
        many instances of the script are running. Clicking a script with
        such a halo <emphasis>stops</emphasis> the script. (If the
        script includes a warp block, which might be inside a custom
        block used in the script, then Snap<emphasis>!</emphasis> may
        not respond immediately to clicks.)
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1066.png" width="0.33333in" depth="0.26042in" />
          </imageobject>
        </inlinemediaobject>If a script is shown with a
        <emphasis>red</emphasis> halo, that means that an error was
        caught in that script, such as using a list where a number was
        needed, or vice versa. Clicking the script will turn off the
        halo.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1067.png" width="0.3125in" depth="0.23958in" />
          </imageobject>
          <textobject>
            <phrase>Macintosh HD:Users:bh:Desktop:pix:keyboard-button.png</phrase>
          </textobject>
        </inlinemediaobject><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1068.png" width="0.33333in" depth="0.26042in" />
          </imageobject>
        </inlinemediaobject>If any blocks have been dragged into the
        scripting area, then in its top right corner you’ll see an
        <emphasis>undo</emphasis> and/or <emphasis>redo</emphasis>
        button that can be used to undo or redo block and script drops.
        When you undo a drop into an input slot, whatever used to be in
        the slot is restored. The redo button appears once you’ve used
        undo.
      </para>
      <para>
        The third button starts keyboard editing mode (Section D, page
        <link linkend="keyboard-editing">130</link>).
      </para>
      <para>
        Control-click/right-clicking a primitive block within a script
        shows a menu like this one:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1069.png" width="0.62083in" depth="1.0625in" />
          </imageobject>
        </inlinemediaobject><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1070.png" width="0.62639in" depth="1.09028in" />
          </imageobject>
        </inlinemediaobject>
      </para>
      <para>
        command block: reporter block:
      </para>
      <para>
        The help… option shows the help screen for the block, just as in
        the palette. The other options appear only when a block is
        right-clicked/control-clicked in the scripting area.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1071.png" width="1.53in" depth="2.13in" />
          </imageobject>
        </inlinemediaobject>Not every primitive block has a relabel…
        option. When present, it allows the block to be replaced by
        another, similar block, keeping the input expressions in place.
        For example, here’s what happens when you choose relabel… for an
        arithmetic operator:
      </para>
      <para>
        Note that the inputs to the existing – block are displayed in
        the menu of alternatives also. Click a block in the menu to
        choose it, or click outside the menu to keep the original block.
        Note that the last three choices are not available in the
        palette; you must use the relabel feature to access them.
      </para>
      <para>
        Not every reporter has a compile option; it exists only for the
        higher order functions. When selected, a lightning bolt appears
        before the block name: <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1072.png" width="1.40278in" depth="0.20139in" />
          </imageobject>
          <textobject>
            <phrase>Macintosh HD:Users:bh:Desktop:lightning.png</phrase>
          </textobject>
        </inlinemediaobject> and Snap<emphasis>!</emphasis> tries to
        compile the function inside the ring to JavaScript, so it runs
        at primitive speed. This works only for simple functions (but
        the higher order function still works even if the compilation
        doesn’t). The function to be compiled must be quick, because it
        will be uninterruptable; in particular, if it’s an infinite
        loop, you may have to quit your browser to recover. Therefore,
        <emphasis role="strong">save your project before</emphasis> you
        experiment with the compilation feature. The right-click menu
        for a compiled higher order function will have an uncompile
        option. This is an experimental feature.
      </para>
      <para>
        The duplicate option for a command block makes a copy of the
        <emphasis>entire script</emphasis> starting from the selected
        block. For a reporter, it copies only that reporter and its
        inputs. The copy is attached to the mouse, and you can drag it
        to another script (or even to another Block Editor window), even
        though you are no longer holding down the mouse button. Click
        the mouse to drop the script copy.
      </para>
      <para>
        The block picture underneath the word duplicate for a command
        block is another duplication option, but it duplicates only the
        selected block, not everything under it in the script. Note that
        if the selected block is a C-shaped control block, the script
        inside its C-shaped slot is included. If the block is at the end
        of its script, this option does not appear. (Use duplicate
        instead.)
      </para>
      <para>
        The extract option removes the selected block from the script
        and leaves you holding it with the mouse. In other words, it’s
        like the block picture option, but it doesn’t leave a copy of
        the block in the original script. If the block is at the end of
        its script, this option does not appear. (Just grab the block
        with the mouse.) A shorthand for this operation is to
        <emphasis>shift-click</emphasis> and drag out the block.
      </para>
      <para>
        The delete option deletes the selected block from the script.
      </para>
      <para>
        The add comment option creates a comment, like the same option
        in the background of the scripting area, but attaches it to the
        block you clicked.
      </para>
      <para>
        The script pic… option saves a picture of the entire script, not
        just from the selected block to the end, into your download
        folder; or, in some browsers, opens a new browser tab containing
        the picture. In the latter case, you can use the browser’s Save
        feature to put the picture in a file. This is a super useful
        feature if you happen to be writing a Snap<emphasis>!</emphasis>
        manual! (If you have a Retina display, consider turning off
        Retina support before making script pictures; if not, they end
        up huge.) For reporters not inside a script, there is an
        additional result pic… option that calls the reporter and
        includes a speech balloon with the result in the picture. Note:
        The downloaded file is a “smart picture”: It also contains the
        code of the script, as if you’d exported the project. If you
        later drag the file into the costumes tab, it will be loaded as
        a costume. But if you drag it into the
        <emphasis>scripts</emphasis> tab, it will be loaded as a script,
        which you can drop wherever you want it in the scripting area.
      </para>
      <para>
        If the script does <emphasis>not</emphasis> start with a hat
        block, or you clicked on a reporter, then there’s one more
        option: ringify (and, if there is already a grey ring around the
        block or script, unringify). Ringify surrounds the block
        (reporter) or the entire script (command) with a grey ring,
        meaning that the block(s) inside the ring are themselves data,
        as an input to a higher order procedure, rather than something
        to be evaluated within the script. See Chapter VI, Procedures as
        Data.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1073.png" width="0.97361in" depth="1.29861in" />
          </imageobject>
        </inlinemediaobject>Clicking a <emphasis>custom</emphasis> block
        in a script gives a similar but different menu:
      </para>
      <para>
        The relabel… option for custom blocks shows a menu of other
        same-shape custom blocks with the same inputs. At present you
        can’t relabel a custom block to a primitive block or vice versa.
        The two options at the bottom, for custom blocks only, are the
        same as in the palette. The other options are the same as for
        primitive commands.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1074.png" width="0.88125in" depth="1.08333in" />
          </imageobject>
        </inlinemediaobject>If a reporter block is in the scripting
        area, possibly with inputs included, but not itself serving as
        input to another block, then the menu is a little different
        again:
      </para>
      <para>
        What’s new here is the result pic… option. It’s like script pic…
        but it includes in the picture a speech balloon with the result
        of calling the block.
      </para>
      <para>
        Broadcast and broadcast and wait blocks in the scripting area
        have an additional option: receivers…. When clicked, it causes a
        momentary (be looking for it when you click!) halo around the
        picture in the sprite corral of those sprites that have a when I
        receive hat block for the same message. Similarly, when I
        receive blocks have a senders… option that light up the sprite
        corral icons of sprites that broadcast the same message.
      </para>
      <para>
        <emphasis role="strong">Scripting Area Background Context
        Menu</emphasis>
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1075.png" width="1.28958in" depth="1.27778in" />
          </imageobject>
        </inlinemediaobject>Control-click/right-click on the grey
        striped background of the scripting area gives this menu:
      </para>
      <para>
        The undrop option is a sort of “undo” feature for the common
        case of dropping a block somewhere other than where you meant it
        to go. It remembers all the dragging and dropping you’ve done in
        this sprite’s scripting area (that is, other sprites have their
        own separate drop memory), and undoes the most recent, returning
        the block to its former position, and restoring the previous
        value in the relevant input slot, if any. Once you’ve undropped
        something, the redrop option appears, and allows you to repeat
        the operation you just undid. These menu options are equivalent
        to the and buttons described earlier.
      </para>
      <para>
        The clean up option rearranges the position of scripts so that
        they are in a single column, with the same left margin, and with
        uniform spacing between scripts. This is a good idea if you
        can’t read your own project!
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1078.png" width="1.38889in" depth="0.70833in" />
          </imageobject>
        </inlinemediaobject>The add comment option puts a comment box,
        like the picture to the right, in the scripting area. It’s
        attached to the mouse, as with duplicating scripts, so you
        position the mouse where you want the comment and click to
        release it. You can then edit the text in the comment as
        desired.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1079.png" width="1.38889in" depth="0.23611in" />
          </imageobject>
        </inlinemediaobject>You can drag the bottom right corner of the
        comment box to resize it. Clicking the arrowhead at the top left
        changes the box to a single-line compact form, , so that you can
        have a number of collapsed comments in the scripting area and
        just expand one of them when you want to read it in full.
      </para>
      <para>
        If you drag a comment over a block in a script, the comment will
        be attached to the block with a yellow line:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1080.png" width="1.48611in" depth="0.84722in" />
          </imageobject>
        </inlinemediaobject><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1081.png" width="3.33333in" depth="0.93333in" />
          </imageobject>
        </inlinemediaobject>Comments have their own context menu, with
        obvious meanings:
      </para>
      <para>
        Back to the options in the menu for the background of the
        scripting area (picture on the previous page):
      </para>
      <para>
        The scripts pic… option saves, or opens a new browser tab with,
        a picture of <emphasis>all</emphasis> scripts in the scripting
        area, just as they appear, but without the grey striped
        background. Note that “all scripts in the scripting area” means
        just the top-level scripts of the current sprite, not other
        sprites’ scripts or custom block definitions. This is also a
        “smart picture”; if you drag it into the scripting area, it will
        <emphasis>create a new sprite</emphasis> with those scripts in
        its scripting area.
      </para>
      <para>
        Finally, the make a block… option does the same thing as the
        “Make a block” button in the palettes. It’s a shortcut so that
        you don’t have to keep scrolling down the palette if you make a
        lot of blocks.
      </para>
    </section>
    <section xml:id="controls-in-the-costumes-tab">
      <title>Controls in the Costumes Tab</title>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1082.png" width="1.96319in" depth="2.13194in" />
          </imageobject>
        </inlinemediaobject>If you click on the word “Costumes” under
        the sprite controls, you’ll see something like this:
      </para>
<literallayout><inlinemediaobject>
<imageobject>
<imagedata fileref="media/image1083.png" width="0.37917in" depth="0.21667in" />
</imageobject>
<textobject>
<phrase>Macintosh HD:Users:bh:Desktop:pix:camera.png</phrase>
</textobject>
</inlinemediaobject><inlinemediaobject>
<imageobject>
<imagedata fileref="media/image1084.png" width="0.29167in" depth="0.16667in" />
</imageobject>
</inlinemediaobject>The Turtle costume is always present in every sprite; it is costume number 0. Other costumes can be painted within Snap<emphasis>!</emphasis> or imported from files or other browser tabs if your browser supports that. Clicking on a costume selects it; that is, the sprite will look like the selected costume. Clicking on the paint brush icon
opens the <emphasis>Paint Editor,</emphasis> in which you can create a new costume. Clicking on the camera icon opens a window in which you see what your computer’s camera is seeing, and you can take a picture (which will be the full size of the stage unless you shrink it in the Paint Editor). This works only if you give Snap<emphasis>!</emphasis> permission to use the camera, and maybe only if you opened Snap<emphasis>!</emphasis> in secure (HTTPS) mode, and then only if your browser loves you.</literallayout>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1085.png" width="3.56944in" depth="3.18056in" />
          </imageobject>
          <textobject>
            <phrase>Macintosh HD:Users:bh:Desktop:pix:camera-dialog.png</phrase>
          </textobject>
        </inlinemediaobject> <emphasis>Brian’s bedroom when he’s staying
        at Paul’s house.</emphasis>
      </para>
      <para>
        Control-clicking/right-clicking on the turtle picture gives this
        menu:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1086.png" width="1.05556in" depth="0.90278in" />
          </imageobject>
        </inlinemediaobject>In this menu, you choose the turtle’s
        <emphasis>rotation point,</emphasis> which is also the point
        from which the turtle draws lines. The two pictures below show
        what the stage looks like after drawing a square in each mode;
        tip (otherwise known as “Jens mode”) is on the left in the
        pictures below, middle (“Brian mode”) on the right:
      </para>
      <para>
        As you see, “tip” means the front tip of the arrowhead; “middle”
        is not the middle of the shaded region, but actually the middle
        of the four vertices, the concave one. (If the shape were a
        simple isosceles triangle instead of a fancier arrowhead, it
        would mean the midpoint of the back edge.) The advantage of tip
        mode is that the sprite is less likely to obscure the drawing.
        The advantage of middle mode is that the rotation point of a
        sprite is rarely at a tip, and students are perhaps less likely
        to be confused about just what will happen if you ask the turtle
        to turn 90 degrees from the position shown. (It’s also the
        traditional rotation point of the Logo turtle, which originated
        this style of drawing.)
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1091.png" width="0.98333in" depth="1.31944in" />
          </imageobject>
        </inlinemediaobject>Costumes other than the turtle have a
        different context menu:
      </para>
      <para>
        The edit option opens the Paint Editor on this costume. The
        rename option opens a dialog box in which you can rename the
        costume. (A costume’s initial name comes from the file from
        which it was imported, if any, or is something like costume5.)
        Duplicate makes a copy of the costume, in the same sprite.
        (Presumably you’d do that because you intend to edit one of the
        copies.) Delete is obvious. The get blocks option appears only
        for a smart costume, and brings its script to the scripting
        area. The export option saves the costume as a file on your
        computer, in your usual downloads folder.
      </para>
      <para>
        You can drag costumes up and down in the Costumes tab in order
        to renumber them, so that next costume will behave as you
        prefer.
      </para>
      <para>
        If you drag a <emphasis>smart picture</emphasis> of a script
        into the Costumes tab, its icon will display the text
        “&lt;/&gt;” in the corner to remind you that it includes code:
      </para>
      <para>
        Its right-click menu will have an extra get blocks option that
        switches to the Scripts tab with the script ready to be dropped
        there.
      </para>
    </section>
    <section xml:id="the-paint-editor">
      <title>The Paint Editor</title>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1094.png" width="3.93889in" depth="2.57778in" />
          </imageobject>
        </inlinemediaobject>Here is a picture of a Paint Editor window:
      </para>
      <para>
        If you’ve used any painting program, most of this will be
        familiar to you. Currently, costumes you import can be edited
        only if they are in a bitmap format (png, jpeg, gif, etc.).
        There is a vector editor, but it works only for creating a
        costume, not editing an imported vector (svg) picture. Unlike
        the case of the Block Editor, only one Paint Editor window can
        be open at a time.
      </para>
      <para>
        The ten square buttons in two rows of five near the top left of
        the window are the <emphasis>tools.</emphasis> The top row, from
        left to right, are the paintbrush tool, the outlined rectangle
        tool, the outlined ellipse tool, the eraser tool, and the
        rotation point tool. The bottom row tools are the line drawing
        tool, the solid rectangle tool, the solid ellipse tool, the
        floodfill tool, and the eyedropper tool. Below the tools is a
        row of four buttons that immediately change the picture. The
        first two change its overall size; the next two flip the picture
        around horizontally or vertically. Below these are a color
        palette, a greyscale tape, and larger buttons for black, white,
        and transparent paint. Below these is a solid bar displaying the
        currently selected color. Below that is a picture of a line
        showing the brush width for painting and drawing, and below
        that, you can set the width either with a slider or by typing a
        number (in pixels) into the text box. Finally, the checkbox
        constrains the line tool to draw horizontally or vertically, the
        rectangle tools to draw squares, and the ellipse tools to draw
        circles. You can get the same effect temporarily by holding down
        the shift key, which makes a check appear in the box as long as
        you hold it down. (But the Caps Lock key doesn’t affect it.)
      </para>
      <para>
        You can correct errors with the undo button, which removes the
        last thing you drew, or the clear button, which erases the
        entire picture. (Note, it does <emphasis>not</emphasis> revert
        to what the costume looked like before you started editing it!
        If that’s what you want, click the Cancel button at the bottom
        of the editor.) When you’re finished editing, to keep your
        changes, click OK.
      </para>
      <para>
        Note that the ellipse tools work more intuitively than ones in
        other software you may have used. Instead of dragging between
        opposite corners of the rectangle circumscribing the ellipse you
        want, so that the endpoints of your dragging have no obvious
        connection to the actual shape, in Snap<emphasis>!</emphasis>
        you start at the center of the ellipse you want and drag out to
        the edge. When you let go of the button, the mouse cursor will
        be on the curve. If you drag out from the center at 45 degrees
        to the axes, the resulting curve will be a circle; if you drag
        more horizontally or vertically, the ellipse will be more
        eccentric. (Of course if you want an exact circle you can hold
        down the shift key or check the checkbox.) The rectangle tools,
        though, work the way you expect: You start at one corner of the
        desired rectangle and drag to the opposite corner.
      </para>
      <para>
        Using the eyedropper tool, you can click anywhere in the
        Snap<emphasis>!</emphasis> window, even outside the Paint
        Editor, and the tool will select the color at the mouse cursor
        for use in the Paint Editor. You can only do this once, because
        the Paint Editor automatically selects the paintbrush when you
        choose a color. (Of course you can click on the eyedropper tool
        button again.)
      </para>
      <para>
        The only other non-obvious tool is the rotation point tool. It
        shows in the Paint Editor where the sprite’s current rotation
        center is (the point around which it turns when you use a turn
        block); if you click or drag in the picture, the rotation point
        will move where you click. (You’d want to do this, for example,
        if you want a character to be able to wave its arm, so you use
        two sprites connected together. You want the rotation point of
        the arm sprite to be at the end where it joins the body, so it
        remains attached to the shoulder while waving.)
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1095.png" width="3.83611in" depth="2.54861in" />
          </imageobject>
        </inlinemediaobject><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1096.png" width="0.21528in" depth="0.21528in" />
          </imageobject>
        </inlinemediaobject><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1097.png" width="0.21528in" depth="0.21528in" />
          </imageobject>
        </inlinemediaobject><inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1098.png" width="0.21528in" depth="0.21528in" />
          </imageobject>
        </inlinemediaobject>The vector editor’s controls are much like
        those in the bitmap editor. One point of difference is that the
        bitmap editor has two buttons for solid and outline rectangles,
        and similarly for ellipses, but in the vector editor there is
        always an edge color and a fill color, even if the latter is
        “transparent paint,” and so only one button per shape is needed.
        Since each shape that you draw is a separate layer (like sprites
        on the stage), there are controls to move the selected shape up
        (frontward) or down (rearward) relative to other shapes. There
        is a selection tool to drag out a rectangular area and select
        all the shapes within that area.
      </para>
    </section>
    <section xml:id="section-4">
      <title></title>
      <para>
      </para>
    </section>
    <section xml:id="controls-in-the-sounds-tab">
      <title>Controls in the Sounds Tab</title>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1099.png" width="0.35in" depth="0.2in" />
          </imageobject>
          <textobject>
            <phrase>Macintosh HD:Users:bh:Desktop:record-button.png</phrase>
          </textobject>
        </inlinemediaobject>There is no Sound Editor in
        Snap<emphasis>!</emphasis>, and also no current sound the way
        there’s a current costume for each sprite. (The sprite always
        has an appearance unless hidden, but it doesn’t sing unless
        explicitly asked.) So the context menu for sounds has only
        rename, delete, and export options, and it has a clickable
        button labeled Play or Stop as appropriate. There is a sound
        <emphasis>recorder,</emphasis> which appears if you click the
        red record button ( ):
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1100.png" width="2.325in" depth="1.03333in" />
          </imageobject>
          <textobject>
            <phrase>Macintosh HD:Users:bh:Desktop:sound-recorder.png</phrase>
          </textobject>
        </inlinemediaobject>The first, round button starts recording.
        The second, square button stops recording. The third, triangular
        button plays back a recorded sound. If you don’t like the
        result, click the round button again to re-record. When you’re
        satisfied, push the Save button. If you need a sound editor,
        consider the free (both senses)
        <link xlink:href="http://audacity.sourceforge.net">https://audacity.sourceforge.net</link>.
      </para>
    </section>
  </section>
  <section xml:id="keyboard-editing">
    <title>Keyboard Editing</title>
    <para>
      An ongoing area of research is how to make visual programming
      languages usable by people with visual or motoric disabilities. As
      a first step in this direction, we provide a keyboard editor, so
      that you can create and edit scripts without tracking the mouse.
      So far, not every user interface element is controllable by
      keyboard, and we haven’t even begun providing
      <emphasis>output</emphasis> support, such as interfacing with a
      speech synthesizer. This is an area in which we know we have a
      long way to go! But it’s a start. The keyboard editor may also be
      useful to anyone who can type faster than they can drag blocks.
    </para>
    <section xml:id="starting-and-stopping-the-keyboard-editor">
      <title>Starting and stopping the keyboard editor</title>
      <para>
        There are three ways to start the keyboard editor.
        Shift-clicking anywhere in the scripting area will start the
        editor at that point: either editing an existing script or, if
        you shift-click on the background of the scripting area, editing
        a new script at the mouse position. Alternatively, typing
        shift-enter will start the editor on an existing script, and you
        can use the tab key to switch to another script. Or you can
        click the keyboard button at the top of the scripting area.
      </para>
      <para>
        When the script editor is running, its position is represented
        by a blinking white bar:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1101.png" width="2.20833in" depth="1.59375in" />
          </imageobject>
        </inlinemediaobject>To leave the keyboard editor, type the
        escape key, or just click on the background of the scripting
        area.
      </para>
    </section>
    <section xml:id="navigating-in-the-keyboard-editor">
      <title>Navigating in the keyboard editor</title>
      <para>
        To move to a different script, type the tab key. Shift-tab to
        move through the scripts in reverse order.
      </para>
      <para>
        A script is a vertical stack of command blocks. A command block
        may have input slots, and each input slot may have a reporter
        block in it; the reporter may itself have input slots that may
        have other reporters. You can navigate through a script quickly
        by using the up arrow and down arrow keys to move between
        command blocks. Once you find the command block that you want to
        edit, the left and right arrow keys move between editable items
        within that command. (Left and right arrow when there are no
        more editable items within the current command block will move
        up or down to another command block, respectively.) Here is a
        sequence of pictures showing the results of repeated right arrow
        keys starting from the position shown above:
      </para>
      <para>
        You can rearrange scripts within the scripting area from the
        keyboard. Typing shift-arrow keys (left, right, up, or down)
        will move the current script. If you move it onto another
        script, the two won’t snap together; the one you’re moving will
        overlap the one already there. This means that you can move
        across another script to get to a free space.
      </para>
    </section>
    <section xml:id="editing-a-script">
      <title>Editing a script</title>
      <para>
        Note that the keyboard editor <emphasis>focus,</emphasis> the
        point shown as a white bar or halo, is either
        <emphasis>between</emphasis> two command blocks or
        <emphasis>on</emphasis> an input slot. The editing keys do
        somewhat different things in each of those two cases.
      </para>
      <para>
        The backspace key deletes a block. If the focus is between two
        commands, the one <emphasis>before</emphasis> (above) the
        blinking bar is deleted. If the focus is on an input slot, the
        reporter in that slot is deleted. (If that input slot has a
        default value, it will appear in the slot.) If the focus is on a
        <emphasis>variadic</emphasis> input (one that can change the
        number of inputs by clicking on arrowheads), then
        <emphasis>one</emphasis> input slot is deleted. (When you
        right-arrow into a variadic input, the focus first covers the
        entire thing, including the arrowheads; another right-arrow
        focuses on the first slot within that input group. The focus is
        “on the variadic input” when it covers the entire thing.)
      </para>
      <para>
        The enter key does nothing if the focus is between commands, or
        on a reporter. If the focus is on a variadic input, the enter
        key adds one more input slot. If the focus is on a white input
        slot (one that doesn’t have a reporter in it), then the enter
        key selects that input slot for <emphasis>editing;</emphasis>
        that is, you can type into it, just as if you’d clicked on the
        input slot. (Of course, if the focus is on an input slot
        containing a reporter, you can use the backspace key to delete
        that reporter, and then use the enter key to type a value into
        it.) When you finish typing the value, type the enter key again
        to accept it and return to navigation, or the escape key if you
        decide not to change the value already in the slot.
      </para>
      <para>
        The space key is used to see a menu of possibilities for the
        input slot in focus. It does nothing unless the focus is on a
        single input slot. If the focus is on a slot with a pulldown
        menu of options, then the space key shows that menu. (If it’s a
        block-colored slot, meaning that only the choices in the menu
        can be used, the enter key will do the same thing. But if it’s a
        white slot with a menu, such as in the turn blocks, then enter
        lets you type a value, while space shows the menu.) Otherwise,
        the space key shows a menu of variables available at this point
        in the script. In either case, use the up and down arrow keys to
        navigate the menu, use the enter key to accept the highlighted
        entry, or use the escape key to leave the menu without choosing
        an option.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1110.png" width="1.53472in" depth="1.69444in" />
          </imageobject>
        </inlinemediaobject>Typing any other character key (not special
        keys on fancy keyboards that do something other than generating
        a character) activates the <emphasis>block search
        palette.</emphasis> This palette, which is also accessible by
        typing control-F or command-F outside the keyboard editor, or by
        clicking the search button floating at the top of the palette,
        has a text entry field at the top, followed by blocks whose
        title text includes what you type. The character key you typed
        to start the block search palette is entered into the text
        field, so you start with a palette of blocks containing that
        character. Within the palette, blocks whose titles
        <emphasis>start</emphasis> with the text you type come first,
        then blocks in which <emphasis>a word</emphasis> of the title
        starts with the text you type, and finally blocks in which the
        text appears inside a word of the title. Once you have typed
        enough text to see the block you want, use the arrow keys to
        navigate to that block in the palette, then enter to insert that
        block, or escape to leave the block search palette without
        inserting the block. (When not in the keyboard editor, instead
        of navigating with the arrow keys, you drag the block you want
        into the script, as you would from any other palette.)
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1111.png" width="2.83333in" depth="0.84097in" />
          </imageobject>
        </inlinemediaobject>If you type an arithmetic operator (+-*/) or
        comparison operator (&lt;=&gt;) into the block search text box,
        you can type an arbitrarily complicated expression, and a
        collection of arithmetic operator blocks will be constructed to
        match:
      </para>
      <para>
        As the example shows, you can also use parentheses for grouping,
        and non-numeric operands are treated as variables or primitive
        functions. (A variable name entered in this way may or may not
        already exist in the script. Only round and the ones in the
        pulldown menu of the sqrt block can be used as function names.)
      </para>
    </section>
    <section xml:id="running-the-selected-script">
      <title>Running the selected script</title>
      <para>
        Type control-shift-enter to run the script with the editor
        focus, like clicking the script.
      </para>
    </section>
  </section>
  <section xml:id="controls-on-the-stage">
    <title>Controls on the Stage</title>
    <para>
      The stage is the area in the top right of the
      Snap<emphasis>!</emphasis> window in which sprites move.
    </para>
    <section xml:id="sprites">
      <title>Sprites</title>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1112.png" width="0.60139in" depth="1.08333in" />
          </imageobject>
        </inlinemediaobject>Most sprites can be moved by clicking and
        dragging them. (If you have unchecked the draggable checkbox for
        a sprite, then dragging it has no effect.)
        Control-clicking/right-clicking a sprite shows this context
        menu:
      </para>
      <para>
        The duplicate option makes another sprite with copies of the
        same scripts, same costumes, etc., as this sprite. The new
        sprite starts at a randomly chosen position different from the
        original, so you can see quickly which is which. The new sprite
        is <emphasis>selected:</emphasis> It becomes the current sprite,
        the one shown in the scripting area. The clone option makes a
        permanent clone of this sprite, with some shared attributes, and
        selects it.
      </para>
      <para>
        The delete option deletes the sprite. It’s not just hidden; it’s
        gone for good. (But you can undelete it by clicking the
        wastebasket just below the right edge of the stage.) The edit
        option selects the sprite. It doesn’t actually change anything
        about the sprite, despite the name; it’s just that making
        changes in the scripting area will change this sprite.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1113.png" width="0.65278in" depth="0.88889in" />
          </imageobject>
          <textobject>
            <phrase>Macintosh HD:Users:bh:Desktop:pix:move-handle.png</phrase>
          </textobject>
        </inlinemediaobject>The move option shows a “move handle” inside
        the sprite (the diagonal striped square in the middle):
      </para>
      <para>
        You can ordinarily just grab and move the sprite without this
        option, but there are two reasons you might need it: First, it
        works even if the “draggable” checkbox above the scripting area
        is unchecked. Second, it works for part sprites relative to
        their anchor; ordinarily, dragging a part moves the entire
        nested sprite.
      </para>
      <para>
        The rotate option displays a rotation menu:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1114.png" width="0.93333in" depth="1.58333in" />
          </imageobject>
        </inlinemediaobject>You can choose one of the four compass
        directions in the lower part (the same as in the point in
        direction block) or use the mouse to rotate the handle on the
        dial in 15° increments.
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1115.png" width="0.65278in" depth="0.84722in" />
          </imageobject>
          <textobject>
            <phrase>Macintosh HD:Users:bh:Desktop:pix:pivot-handle.png</phrase>
          </textobject>
        </inlinemediaobject>The pivot option shows a crosshair inside
        the sprite:
      </para>
      <para>
        You can click and drag the crosshair anywhere onstage to set the
        costume’s pivot point. (If you move it outside the sprite, then
        turning the sprite will revolve as well as rotate it around the
        pivot.) When done, click on the stage not on the crosshair. Note
        that, unlike moving the pivot point in the Paint Editor, this
        technique does not visibly move the sprite on the stage.
        Instead, the values of x position and y position will change.
      </para>
      <para>
        The edit option makes this the selected sprite, highlighting it
        in the sprite corral and showing its scripting area. If the
        sprite was a temporary clone, it becomes permanent.
      </para>
      <para>
        The export… option saves, or opens a new browser tab containing,
        the XML text representation of the sprite. (Not just its
        costume, but all of its costumes, scripts, local variables and
        blocks, and other properties.) You can save this tab into a file
        on your computer, and later import the sprite into another
        project. (In some browsers, the sprite is directly saved into a
        file.)
      </para>
    </section>
    <section xml:id="macintosh-hdusersbhdesktopwatcher-menu.pngvariable-watchers">
      <title><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1116.png" width="0.95833in" depth="1.44792in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:watcher-menu.png</phrase>
        </textobject>
      </inlinemediaobject>Variable watchers</title>
      <para>
        Right-clicking on a variable watcher shows this menu:
      </para>
      <para>
        The first section of the menu lets you choose one of three
        visualizations of the watcher:
      </para>
      <para>
        The first (normal) visualization is for debugging. The second
        (large) is for displaying information to the user of a project,
        often the score in a game. And the third (slider) is for
        allowing the user to control the program behavior interactively.
        When the watcher is displayed as a slider, the middle section of
        the menu allows you to control the range of values possible in
        the slider. It will take the minimum value when the slider is
        all the way to the left, the maximum value when all the way to
        the right.
      </para>
      <para>
        The third section of the menu allows data to be passed between
        your computer and the variable. The import… option will read a
        computer text file. Its name must end with .txt, in which case
        the text is read into the variable as is, or .csv or .json, in
        which case the text is converted into a list structure, which
        will always be a two-dimensional array for csv (comma-separated
        values) data, but can be any shape for json data. The raw data…
        option prevents that conversion to list form. The export… option
        does the opposite conversion, passing a text-valued variable
        value into a .txt file unchanged, but converting a list value
        into csv format if the list is one- or two-dimensional, or into
        json format if the list is more complicated. (The scalar values
        within the list must be numbers and/or text; lists of blocks,
        sprites, costumes, etc. cannot be exported.)
      </para>
      <para>
        An alternative to using the import… option is simply to drag the
        file onto the Snap<emphasis>!</emphasis> window, in which case a
        variable will be created if necessary with the same name as the
        file (but without the extension).
      </para>
      <para>
        If the value of the variable is a list, then the menu will
        include an additional blockify option; clicking it will generate
        an expression with nested list blocks that, if evaluated, will
        reconstruct the list. It’s useful if you imported a list and
        then want to write code that will construct the same list later.
      </para>
    </section>
    <section xml:id="the-stage-itself">
      <title>
      The stage itself</title>
      <para>
        Control-clicking/right-clicking on the stage background (that
        is, anywhere on the stage except on a sprite or watcher) shows
        the stage’s own context menu:
      </para>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="media/image1123.png" width="0.82153in" depth="0.84722in" />
          </imageobject>
        </inlinemediaobject>The stage’s edit option selects the stage,
        so the stage’s scripts and backgrounds are seen in the scripting
        area. Note that when the stage is selected, some blocks,
        especially the Motion ones, are not in the palette area because
        the stage can’t move.
      </para>
      <para>
        The show all option makes all sprites visible, both in the sense
        of the show block and by bringing the sprite onstage if it has
        moved past the edge of the stage.
      </para>
      <para>
        The pic… option saves, or opens a browser tab with, a picture of
        everything on the stage: its background, lines drawn with the
        pen, and any visible sprites. What you see is what you get. (If
        you want a picture of just the background, select the stage,
        open its costumes tab, control-click/right-click on a
        background, and export it.)
      </para>
      <para>
        The pen trails option creates a new costume for the currently
        selected sprite consisting of all lines drawn on the stage by
        the pen of any sprite. The costume’s rotation center will be the
        current position of the sprite.
      </para>
      <para>
        If you previously turned on the log pen vectors option, and
        there are logged vectors, the menu includes an extra option,
        svg…, that exports a picture of the stage in vector format. Only
        lines are logged, not color regions made with the fill block.
      </para>
    </section>
  </section>
  <section xml:id="the-sprite-corral-and-sprite-creation-buttons">
    <title>The Sprite Corral and Sprite Creation Buttons</title>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1083.png" width="0.37917in" depth="0.20556in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:pix:camera.png</phrase>
        </textobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1124.png" width="0.29167in" depth="0.16667in" />
        </imageobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1125.png" width="0.29167in" depth="0.16667in" />
        </imageobject>
      </inlinemediaobject>Between the stage and the sprite corral at the
      bottom right of the Snap<emphasis>!</emphasis> window is a dark
      grey bar containing three buttons at the left and one at the
      right. The first three are used to create a new sprite. The first
      button makes a sprite with just the turtle costume, with a
      randomly chosen position and pen color. (If you hold down the
      Shift key while clicking, the new sprite’s direction will also be
      random.) The second button makes a sprite and opens the Paint
      Editor so that you can make your own costume for it. (Of course
      you could click the first button and then click the paint button
      in its costumes tab; this paint button is a shortcut for all
      that.) Similarly, the third button uses your camera, if possible,
      to make a costume for the new sprite.
    </para>
    <para>
      The trash can button <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1126.png" width="0.29167in" depth="0.17361in" />
        </imageobject>
      </inlinemediaobject> at the right has two uses. You can drag a
      sprite thumbnail onto it from the sprite corral to delete that
      sprite, or you can click it to undelete a sprite you deleted by
      accident.
    </para>
    <para>
      In the sprite corral, you click on a sprite’s “thumbnail” picture
      to select that sprite (to make it the one whose scripts, costumes,
      etc. are shown in the scripting area). You can drag sprite
      thumbnails (but not the stage one) to reorder them; this has no
      special effect on your project, but lets you put related ones next
      to each other, for example. Double-clicking a thumbnail flashes a
      halo around the actual sprite on the stage.
    </para>
    <para>
      You can right-click/control-click a sprite’s thumbnail to get this
      context menu:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1127.png" width="0.67708in" depth="1.10903in" />
        </imageobject>
      </inlinemediaobject>The show option makes the sprite visible, if
      it was hidden, and also brings it onto the stage, if it had moved
      past the stage boundary. The next three options are the same as in
      the context menu of the actual sprite on the stage, discussed
      above.
    </para>
    <para>
      The parent… option displays a menu of all other sprites, showing
      which if any is this sprite’s parent, and allowing you to choose
      another sprite (replacing any existing parent). The release option
      is shown only if this sprite is a (permanent, or it wouldn’t be in
      the sprite corral) clone; it changes the sprite to a temporary
      clone. (The name is supposed to mean that the sprite is released
      from the corral.) The export… option exports the sprite, like the
      same option on the stage.
    </para>
    <para>
      The context menu for the stage thumbnail has only one option,
      pic…, which takes a picture of everything on the stage, just like
      the same option in the context menu of the stage background. If
      pen trails are being logged, there will also be an svg… option.
    </para>
    <para>
      If your project includes scenes, then under the stage icon in the
      sprite corral will be the <emphasis>scene corral:</emphasis>
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1128.png" width="3.33333in" depth="1.70833in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:scene-corral.png</phrase>
        </textobject>
      </inlinemediaobject>Clicking on a scene will select it;
      right-clicking will present a menu in which you can rename,
      delete, or export the scene.
    </para>
  </section>
  <section xml:id="preloading-a-project-when-starting-snap">
    <title>Preloading a Project when Starting
    Snap<emphasis>!</emphasis></title>
    <para>
      There are several ways to include a pointer to a project in the
      URL when starting Snap<emphasis>!</emphasis> in order to load a
      project automatically. You can think of such a URL as just running
      the project rather than as running Snap<emphasis>!</emphasis>,
      especially if the URL says to start in presentation mode and click
      the green flag. The general form is
    </para>
    <para>
      https://snap.berkeley.edu/run#<emphasis><emphasis role="strong">verb</emphasis></emphasis>:<emphasis><emphasis role="strong">project</emphasis></emphasis>&amp;<emphasis><emphasis role="strong">flag</emphasis></emphasis>&amp;<emphasis><emphasis role="strong">flag</emphasis></emphasis>…
    </para>
    <para>
      The “verb” above can be any of open, run, cloud, present, or dl.
      The last three are for shared projects in the
      Snap<emphasis>!</emphasis> cloud; the first two are for projects
      that have been exported and made available anywhere on the
      Internet.
    </para>
    <para>
      Here’s an example that loads a project stored at the
      Snap<emphasis>!</emphasis> web site (not the
      Snap<emphasis>!</emphasis> cloud!):
    </para>
    <para>
      https://snap.berkeley.edu/run#open:https://snap.berkeley.edu/snapsource/Examples/vee.xml
    </para>
    <para>
      The project file will be opened, and Snap<emphasis>!</emphasis>
      will start in edit mode (with the program visible). Using #run:
      instead of #open: will start in presentation mode (with only the
      stage visible) and will “start” the project by clicking the green
      flag. (“Start” is in quotation marks because there is no guarantee
      that the project includes any scripts triggered by the green flag.
      Some projects are started by typing on the keyboard or by clicking
      a sprite.)
    </para>
    <para>
      If the verb is run, then you can also use any subset of the
      following flags:
    </para>
    <para>
      &amp;editMode Start in edit mode, not presentation mode.
    </para>
    <para>
      &amp;noRun Don’t click the green flag.
    </para>
    <para>
      &amp;hideControls Don’t show the row of buttons above the stage
      (edit mode, green flag, pause, stop).
    </para>
    <para>
      &amp;lang=fr Set language to (in this example) French.
    </para>
    <para>
      &amp;noCloud Don’t allow cloud operations from this project (for
      running projects from unknown
    </para>
    <para>
      sources that include JavaScript code)
    </para>
    <para>
      &amp;noExitWarning When closing the window or loading a different
      URL, don’t show the browser
    </para>
    <para>
      “are you sure you want to leave this page” message.
    </para>
    <para>
      &amp;blocksZoom=n Like the Zoom blocks option in the Settings
      menu.
    </para>
    <para>
      The last of these flags is intended for use on a web page in which
      a Snap<emphasis>!</emphasis> window is embedded.
    </para>
    <para>
      Here’s an example that loads a shared (public) project from the
      Snap<emphasis>!</emphasis> cloud:
    </para>
    <para>
      https://snap.berkeley.edu/run#present:Username=jens&amp;ProjectName=tree%20animation
    </para>
    <para>
      (Note that “Username” and “ProjectName” are TitleCased, even
      though the flags such as “noRun” are camelCased. Note also that a
      space in the project name must be represented in Unicode as %20.)
      The verb present behaves like run: it ordinarily starts the
      project in presentation mode, but its behavior can be modified
      with the same four flags as for run. The verb cloud (yes, we know
      it’s not a verb in its ordinary use) behaves like open except that
      it loads from the Snap<emphasis>!</emphasis> cloud rather than
      from the Internet in general. The verb dl (short for “download”)
      does not start Snap<emphasis>!</emphasis> but just downloads a
      cloud-saved project to your computer as an .xml file. This is
      useful for debugging; sometimes a defective project that
      Snap<emphasis>!</emphasis> won’t run can be downloaded, edited,
      and then re-saved to the cloud.
    </para>
  </section>
  <section xml:id="mirror-sites">
    <title>Mirror Sites</title>
    <para>
      If the site snap.berkeley.edu is ever unavailable, you can load
      Snap<emphasis>!</emphasis> at the following mirror sites:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          https://bjc.edc.org/snapsource/snap.html
        </para>
      </listitem>
      <listitem>
        <para>
          https://cs10.org/snap
        </para>
      </listitem>
    </itemizedlist>
  </section>
</section>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="appendix-a.-snap-color-library" role="unnumbered">
  <title>
  Appendix A. Snap<emphasis>!</emphasis> color library</title>
  <para>
    The Colors and Crayons library provides several tools for
    manipulating color. Although its main purpose is controlling a
    sprite’s pen color, it also establishes colors as a first class data
    type:
  </para>
  <para>
    <inlinemediaobject>
      <imageobject>
        <imagedata fileref="media/image1135.png" width="3.13333in" depth="0.51667in" />
      </imageobject>
      <textobject>
        <phrase>Macintosh HD:Users:bh:Desktop:crayon-Pen.png</phrase>
      </textobject>
    </inlinemediaobject>For people who just want colors in their
    projects without having to be color experts, we provide two simple
    mechanisms: a <emphasis>color number</emphasis> scale with a broad
    range of continuous color variation and a set of 100
    <emphasis>crayons</emphasis> organized by color family (ten reds,
    ten oranges, etc.) The crayons include the block colors:
  </para>
  <para>
    <inlinemediaobject>
      <imageobject>
        <imagedata fileref="media/image1136.png" width="7.16667in" depth="1.1in" />
      </imageobject>
      <textobject>
        <phrase>Macintosh HD:Users:bh:Desktop:hsl-from-x11.png</phrase>
      </textobject>
    </inlinemediaobject>For experts, we provide color selection by RGB,
    HSL, HSV, X11/W3C names, and variants on those scales.
  </para>
  <section xml:id="introduction-to-color">
    <title>Introduction to Color</title>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1137.png" width="0.23611in" depth="0.23611in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:Google Chrome002.png</phrase>
        </textobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1138.png" width="0.23611in" depth="0.23611in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:Google Chrome001.png</phrase>
        </textobject>
      </inlinemediaobject>Your computer monitor can display millions of
      colors, but you probably can’t distinguish that many. For example,
      here’s red 57, green 180, blue 200: And here’s red 57, green
      <emphasis>182,</emphasis> blue 200: You might be able to tell them
      apart if you see them side by side: … but maybe not even then.
    </para>
    <para>
      Color space—the collection of all possible colors—is
      three-dimensional, but there are many ways to choose the
      dimensions. RGB (red-green-blue), the one most commonly used in
      computers, matches the way TVs and displays produce color. Behind
      every dot on the screen are three tiny lights: a red one, a green
      one, and a blue one. But if you want to print colors on paper,
      your printer probably uses a different set of three colors: CMY
      (cyan-magenta-yellow). You may have seen the abbreviation CMYK,
      which represents the common technique of adding black ink to the
      collection. (Mixing cyan, magenta, and yellow in equal amounts is
      supposed to result in black ink, but typically it comes out a
      muddy brown instead, because chemistry.) Other systems that try to
      mimic human perception are HSL (hue-saturation-lightness) and HSV
      (hue-saturation-value). There are many, many more, each designed
      for a particular purpose.
    </para>
    <para>
      If you are a color professional—a printer, a web designer, a
      graphic designer, an artist—then you need to understand all this.
      It can also be interesting to learn about. For example, there are
      colors that you can see but your computer display can’t generate.
      If that intrigues you, look up
      <link xlink:href="https://en.wikipedia.org/wiki/Color_theory">color
      theory</link> in Wikipedia.
    </para>
  </section>
  <section xml:id="crayons-and-color-numbers">
    <title>Crayons and Color Numbers</title>
    <para>
      But if you just want some colors in your project, we provide a
      simple, one-dimensional subset of the available colors. Two
      subsets, actually: <emphasis>crayons</emphasis> and
      <emphasis>color numbers.</emphasis> Here’s the difference:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1144.png" width="0.23611in" depth="0.23611in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:Google Chrome005.png</phrase>
        </textobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1145.png" width="0.23611in" depth="0.23611in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:Google Chrome003.png</phrase>
        </textobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1146.png" width="0.23611in" depth="0.23611in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:Google Chrome004.png</phrase>
        </textobject>
      </inlinemediaobject>The first row shows 100 distinct colors. They
      have names; this is pumpkin, and this is denim. You’re supposed to
      think of them as a big box of 100 crayons. They’re arranged in
      families: grays, pinks, reds, browns, oranges, etc. But they’re
      not consistently ordered within a family; you’d be unlikely to say
      “next crayon” in a project. (But look at the crayon spiral on page
      <link linkend="spirals">145</link>.) Instead, you’d think “I want
      this to look like a really old-fashioned photo” and so you’d find
      sepia as crayon number 33. You don’t have to memorize the numbers!
      You can find them in a menu with a submenu for each family.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1147.png" width="2.15972in" depth="0.25694in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:set-crayon-name.png</phrase>
        </textobject>
      </inlinemediaobject>Or, if you know the crayon name, just .
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1154.png" width="5.79306in" depth="0.3in" />
        </imageobject>
      </inlinemediaobject>The crayon numbers are chosen so that skipping
      by 10 gives a sensible box of ten crayons:
    </para>
    <para>
      Alternatively, skipping by 5 gives a still-sensible set of twenty
      crayons:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1155.png" width="5.8in" depth="0.3in" />
        </imageobject>
      </inlinemediaobject>
    </para>
    <para>
      The set of <emphasis>color numbers</emphasis> is arranged so that
      each color number is visually near each of its neighbors. Bright
      and dark colors alternate for each family. Color numbers range
      from 0 to 99, like crayon numbers, but you can use fractional
      numbers to get as tiny a step as you like:
    </para>
    <para>
      (“As tiny as you like” isn’t <emphasis>quite</emphasis> true
      because in the end, your color has to be rounded to integer RGB
      values for display.)
    </para>
    <para>
      Both of these scales include the range of shades of gray, from
      black to white. Since black is the initial pen color, and black
      isn’t a hue, Scratch and Snap<emphasis>!</emphasis> users would
      traditionally try to use set color to escape from black, and it
      wouldn’t work. By including black in the same scale as other
      colors, we eliminate the Black Hole problem if people use only the
      recommended color scales.
    </para>
<literallayout>We are making a point of saying “color number” for what was sometimes called just “color” in earlier versions of the library, because we now reserve the name “color” for an actual color, an instance of the color data type.
<emphasis role="strong">How to Use the Library</emphasis></literallayout>
    <para>
      There are three library blocks specifically about controlling the
      pen. They have the same names as three of the primitive Pen
      blocks:
    </para>
    <para>
      The first (Pen block-colored) input slot is used to select which
      color scale you want to use. (These blocks also allow reading or
      setting two block properties that are not colors: the pen size and
      its transparency.) The pen reporter requires no other inputs; it
      reports the state of the pen in whatever dimension you choose.
    </para>
    <para>
      As the last example shows, you can’t ask for the pen color in a
      scale incompatible with how you set it, unless the block can
      deduce what you want from what it knows about the current pen
      color.
    </para>
    <para>
      The change pen block applies only to numeric scales (including
      vectors of three or four numbers). It adds its numeric or list
      input to the current pen value(s), doing vector (item-by-item)
      addition for vector scales.
    </para>
    <para>
      The set pen block changes the pen color to the value(s) you
      specify. The meaning of the white input slots depends on which
      attribute of the pen you’re setting:
    </para>
    <para>
      In the last example, the number 37 sets the
      <emphasis>transparency,</emphasis> on the scale 0=opaque,
      100=invisible. (All color attributes are on a 0–100 scale except
      for RGB components, which are 0–255.) A transparency value can be
      combined with any of these attribute scales.
    </para>
    <para>
      The library also includes two constructors and a selector for
      colors as a data type:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image402.png" width="1.80556in" depth="0.19444in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:color-from-and.png</phrase>
        </textobject>
      </inlinemediaobject>The latter two are inverses of each other,
      translating between colors and their attributes. The color from
      block’s attribute menu has fewer choices than the similar set pen
      block because you can, for example, set the Red value of the
      existing pen color leaving the rest unchanged, but when creating a
      color out of nothing you have to provide its entire specification,
      e.g., all of Red, Green, and Blue, or the equivalent in other
      scales. (As you’ll see on the next page, we provide two
      <emphasis>linear</emphasis> (one-dimensional) color scales that
      allow you to specify a color with a single number, at the cost of
      including only a small subset of the millions of colors your
      computer can generate.) If you have a color and want another color
      that’s the same except for one number, as in the Red example, you
      can use this block:
    </para>
    <para>
      Finally, the library includes the mix block and a helper:
    </para>
    <para>
      We’ll have more to say about these after a detour through color
      theory.
    </para>
<literallayout>That’s all you have to know about colors! <emphasis>Crayons</emphasis> for specific interesting ones, <emphasis>color numbers</emphasis> for gradual transformation from one color to the next. But there’s a bit more to say, if you’re interested. If not, stop here. (But look at the samples of the different scales on page <link linkend="spirals">145</link>.)
<emphasis role="strong">More about Colors: Fair Hues and Shades</emphasis></literallayout>
    <para>
      Several of the three-dimensional arrangements of colors use the
      concept of “hue,” which more or less means where a color would
      appear in a rainbow (magenta, near the right, is
      <link xlink:href="https://en.wikipedia.org/wiki/Magenta">a long
      story</link>):
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1189.png" width="5.80667in" depth="0.30667in" />
        </imageobject>
      </inlinemediaobject>
    </para>
    <para>
      These are called “spectral” colors, after the
      <emphasis>spectrum</emphasis> of rainbow colors. But these colors
      aren’t equally distributed. There’s an awful lot of green, hardly
      any yellow, and just a sliver of orange. And no brown at all.
    </para>
    <para>
      And this is already a handwave, because the range of colors that
      can be generated by RGB monitors doesn’t include some of the
      <emphasis>true</emphasis> spectral colors. See
      <link xlink:href="https://en.wikipedia.org/wiki/Spectral_color">Spectral
      color</link> in Wikipedia for all the gory details.
    </para>
    <para>
      This isn’t a problem with the physics of rainbows. It’s in the
      human eye and the human brain that certain ranges of wavelength of
      light waves are lumped together as named colors. The eye is just
      “tuned” to recognize a wide range of colors as green. (See
      <link xlink:href="https://en.wikipedia.org/w/index.php?title=Rods_and_cones">Rods
      and Cones</link>.) And different human cultures give names to
      different color ranges. Nevertheless, in old Scratch projects,
      you’d say change pen color by 1 and it’d take forever to reach a
      color that wasn’t green.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1190.png" width="5.99444in" depth="0.29931in" />
        </imageobject>
      </inlinemediaobject>For color professionals, there are good
      reasons to want to work with the physical rainbow hue layout. But
      for amateurs using a simplified, one-dimensional color model,
      there’s no reason not to use a more programmer-friendly hue scale:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1191.png" width="1.45972in" depth="1.35833in" />
        </imageobject>
      </inlinemediaobject>In this scale, each of the seven rainbow
      colors and brown get an equal share. (Red’s looks too small, but
      that’s because it’s split between the two ends: hue 0 is pure red,
      brownish reds are to its right, and purplish reds are wrapped
      around to the right end.) We call this scale “fair hue” because
      each color family gets a fair share of the total hue range. (By
      the way, you were probably taught “… green, blue, indigo, violet”
      in school, but it turns out that color names were different in
      Isaac Newton’s day, and the color he called “blue” is more like
      modern cyan, while his “indigo” is more like modern blue. See
      Wikipedia
      <link xlink:href="https://en.wikipedia.org/wiki/Indigo">Indigo</link>.)
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1192.png" width="0.23611in" depth="0.23611in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:pink.png</phrase>
        </textobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1193.png" width="0.23611in" depth="0.23611in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:maroon.png</phrase>
        </textobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1194.png" width="0.23611in" depth="0.23611in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:candy.png</phrase>
        </textobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1195.png" width="0.23611in" depth="0.23611in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:red.png</phrase>
        </textobject>
      </inlinemediaobject>Our <emphasis>color number</emphasis> scale is
      based on fair hues, adding a range of grays from black (color
      number 0) to white (color number14) and also adding
      <emphasis>shades</emphasis> of the spectral colors. (In color
      terminology, a <emphasis>shade</emphasis> is a darker version of a
      color; a lighter version is called a <emphasis>tint.</emphasis>)
      Why do we add shades but not tints? Partly because I find shades
      more exciting. A shade of red can be dark candy apple red or
      maroon , but a tint is just some kind of pink . This admitted
      prejudice is supported by an objective fact: Most projects are
      made on a white background, so dark colors stand out better than
      light ones.
    </para>
    <para>
      So, in our color number scale, color numbers 0 to 14 are kinds of
      gray; the remaining color numbers go through the fair hues, but
      alternating full-strength colors with shades.
    </para>
    <para>
      crayons by 10
    </para>
    <para>
      crayons by 5
    </para>
    <para>
      crayons
    </para>
    <para>
      fair hues
    </para>
    <para>
      color numbers
    </para>
    <para>
      color numbers by 5
    </para>
    <para>
      color numbers by 10
    </para>
    <para>
      This chart shows how the color scales discussed so far are
      related. Note that all scales range from 0 to 100; the fair hues
      scale has been compressed in the chart so that similar colors line
      up vertically. (Its dimensions are different because it doesn’t
      include the grays at the left. Since there are eight color
      families, the pure, named fair hues are at multiples of
      100/8=12.5, starting with red=0.)
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1198.png" width="1.85in" depth="1.07986in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:Prism_compare_rainbow_01.png</phrase>
        </textobject>
      </inlinemediaobject>White is crayon 14 and color number 14. This
      value was deliberately chosen <emphasis>not</emphasis> to be a
      multiple of 5 so that the every-fifth-crayon and
      every-tenth-crayon selections don’t include it, so that all of the
      crayons in those smaller boxes are visible against a white stage
      background.
    </para>
    <para>
      Among purples, the official spectral violet (crayon 90) is the end
      of the spectrum. Magenta, brighter than violet, isn’t a spectral
      color at all. <anchor xml:id="rainbow" />(In the picture at the
      left, the top part is the spectrum of white light spread out
      through a prism; the middle part is a photograph of a rainbow, and
      the bottom part is a digital simulation of a rainbow.) Magenta is
      a mixture of red and blue. (attribution: Wikipedia user Andys. CC
      BY-SA.)
    </para>
    <para>
      The light gray at color number 10 is slightly different from
      crayon 10 just because of roundoff in computing crayon values.
      Color number 90 is different from crayon 90 because the official
      RGB violet (equal parts red and blue) is actually lighter than
      spectral violet. The purple family is also unusual because
      magenta, crayon and color number 95, is lighter than the violet at
      90. In other families, the color numbers, crayons, and (scaled)
      fair hues all agree at multiples of ten. These multiple-of-ten
      positions are the standard RGB primary and secondary colors, e.g.,
      the yellow at color number 50 is (255, 255, 0) in RGB. (Gray,
      brown, and orange don’t have such simple RGB settings.)
    </para>
    <para>
      The color numbers at odd multiples of five are generally darker
      shades than the corresponding crayons. The latter are often
      official named shades, e.g., teal, crayon 65, is a half-intensity
      shade of cyan. The odd-five <emphasis>color numbers,</emphasis>
      though, are often darker, since they are chosen to be the darkest
      color in a given family that’s visibly different from black. The
      pink at color number 15, though, is quite different from crayon
      15, because the former is a pure tint of red, whereas the crayon,
      to get a more interesting pink, has a little magenta mixed in.
      Color numbers at multiples of five are looked up in a table; other
      color values are determined by linear interpolation in RGB space.
      (<emphasis>Crayons</emphasis> are of course all found by table
      lookup.)
    </para>
    <para>
      The from color block behaves specially when you ask for the
      <emphasis>color number</emphasis> of a color. Most colors don’t
      exactly match a color number, and for other attributes of a color
      (crayon number, X11 name) you don’t get an answer unless the color
      exactly matches one of the names or numbers in that attribute. But
      for color number, the block tries to find the <emphasis>nearest
      color number</emphasis> to the color you specify. The result will
      be only approximate; you can’t use the number you get to recreate
      the input color. But you can start choosing nearby color numbers
      as you animate the sprite.
    </para>
  </section>
  <section xml:id="perceptual-spaces-hsv-and-hsl">
    <title>Perceptual Spaces: HSV and HSL</title>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1199.png" width="0.73611in" depth="0.72222in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:blues.png</phrase>
        </textobject>
      </inlinemediaobject>RGB is the right way to think about colors if
      you’re building or programming a display monitor; CMYK is the
      right way if you’re building or programming a color printer. But
      neither of those coordinate systems is very intuitive if you’re
      trying to understand what color <emphasis>you see</emphasis> if,
      for example, you mix 37% red light, 52% green, and 11% blue. The
      <emphasis>hue</emphasis> scale is one dimension of most attempts
      at a perceptual scale. The square at the right has pale blues
      along the top edge, dark blues along the right edge, various
      shades of gray toward the left, black at the bottom, and pure
      spectral blue in the top right corner. Although no other point in
      the square is pure blue, you can tell at a glance that no other
      spectral color is mixed with the blue.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1200.png" width="2.69167in" depth="1.19028in" />
        </imageobject>
      </inlinemediaobject>Aside from hue, the other two dimensions of a
      color space have to represent how much white and/or black is mixed
      with the spectral color. (Bear in mind that “mixing black” is a
      metaphor when it comes to monitors. There really is black paint,
      but there’s no such thing as black light.) One such space, HSV,
      has one dimension for the amount of color (vs. white), called
      <emphasis>saturation,</emphasis> and one for the amount of black,
      imaginatively called <emphasis>value.</emphasis> HSV stands for
      Hue-Saturation-Value. (Value is also called
      <emphasis>brightness.</emphasis>) The <emphasis>value</emphasis>
      is actually measured backward from the above description; that is,
      if value is 0, the color is pure black; if value is 100, then a
      saturation of 0 means all white, no spectral color; a saturation
      of 100 means no white at all. In the square in the previous
      paragraph, the <emphasis>x</emphasis> axis is the saturation and
      the <emphasis>y</emphasis> axis is the value. The entire bottom
      edge is black, but only the top left corner is white. HSV is the
      traditional color space used in Scratch and
      Snap<emphasis>!.</emphasis> Set pen color set the hue; set pen
      shade set the value. There was originally no Pen block to set the
      saturation, but there’s a set brightness effect Looks block to
      control the saturation of the sprite’s costume. (I speculate that
      the Scratch designers, like me, thought tints were less vivid than
      shades against a white background, so they made it harder to
      control tinting.)
    </para>
    <para>
      attribution: Wikipedia user SharkD, CC BY-SA 3.0
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1201.png" width="1.56389in" depth="0.29306in" />
        </imageobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1202.png" width="1.55556in" depth="0.26597in" />
        </imageobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1203.png" width="0.76389in" depth="0.76389in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:HSL-blue.png</phrase>
        </textobject>
      </inlinemediaobject>But if you’re looking at colors on a computer
      display, HSV isn’t really a good match for human perception.
      Intuitively, black and white should be treated symmetrically. This
      is the HSL (hue-saturation-lightness) color space.
      <emphasis>Saturation,</emphasis> in HSL, is a measure of the
      <emphasis>grayness</emphasis> or <emphasis>dullness</emphasis> of
      a color (how close it comes to being on a black-and-white scale)
      and <emphasis>lightness</emphasis> measures
      <emphasis>spectralness</emphasis> with pure white at one end, pure
      black at the other end, and spectral color in the middle. The
      <emphasis>saturation</emphasis> number is actually the opposite of
      grayness: 0 means pure gray, and 100 means pure spectral color,
      provided that the <emphasis>lightness</emphasis> is 50, midway
      between black and white. Colors with lightness other than 50 have
      some black or white mixed in, but saturation 100 means that the
      color is as fully saturated as it can be, given the amount of
      white or black needed to achieve that lightness. Saturation less
      than 100 means that <emphasis>both white and black</emphasis> are
      mixed with the spectral color. (Such mixtures are called
      <emphasis>tones</emphasis> of the spectral color. Perceptually,
      colors with saturation 100% don’t look gray: but colors with
      saturation 75% do:
    </para>
    <para>
      Note that HSV and HSL both have a dimension called “saturation,”
      but <emphasis>they’re not the same thing!</emphasis> In HSV,
      “saturation” means non-whiteness, whereas in HSL it means
      non-grayness (vividness).
    </para>
    <para>
      More fine print: It’s misleading to talk about the spectrum of
      light wavelengths as if it were the same as perceived hue. If your
      computer display is showing you a yellow area, for example, it’s
      doing it by turning on its red and green LEDs over that area, and
      what hits your retina <emphasis>is still two wavelengths of light,
      red and green, superimposed.</emphasis> You could make what’s
      perceptually the same yellow by using a single intermediate
      wavelength. Your eye and brain don’t distinguish between those two
      kinds of yellow. Also, your brain automatically adjusts perceived
      hue to correct for differences in illumination. When you place a
      monochrome object so that it’s half in sunlight and half in the
      shade, you see it as one even though what’s reaching your eyes
      from the two regions differs a lot. And, sadly, it’s HSL whose use
      of “saturation” disagrees with the official international color
      vocabulary standardization committee. I learned all this from
      <link xlink:href="http://www.huevaluechroma.com/011.php">this
      tutorial</link>, which you might find more coherent than jumping
      around Wikipedia if you’re interested.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1204.png" width="1.64375in" depth="0.84167in" />
        </imageobject>
      </inlinemediaobject>Although traditional Scratch and
      Snap<emphasis>!</emphasis> use HSV in programs, they use HSL in
      the color picker. The horizontal axis is hue (fair hue, in this
      version) and the vertical axis is <emphasis>lightness,</emphasis>
      the scale with black at one end and white at the other end. It
      would make no sense to have only the bottom half of this selector
      (HSV Value) or only the top half (HSV Saturation). And, given that
      you can only fit two dimensions on a flat screen, it makes sense
      to pick HSL saturation (vividness) as the one to keep at 100%. (In
      this fair-hue picker, some colors appear twice: “spectral” (50%
      lightness) browns as shades (≈33% lightness) of red or orange, and
      shades of those browns.)
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1205.png" width="0.20278in" depth="0.20278in" />
        </imageobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1206.png" width="0.18889in" depth="0.18889in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:yellow.png</phrase>
        </textobject>
      </inlinemediaobject>Software that isn’t primarily about colors
      (so, <emphasis>not</emphasis> including Photoshop, for example)
      typically use HSV or HSL, with web-based software more likely to
      use HSV because that’s what’s built into the JavaScript
      programming language provided by browsers. But if the goal is to
      model human color perception, neither of these color spaces is
      satisfactory, because they assume that all full-intensity spectral
      colors are equally bright. But if you’re like most people, you see
      spectral yellow as much brighter than spectral blue . There are
      better perceptual color spaces with names like L*u*v* and L*a*b*
      that are based on research with human subjects to determine true
      perceived brightness. Wikipedia explains all this and more at
      <link xlink:href="https://en.wikipedia.org/wiki/HSL_and_HSV">HSL
      and HSV</link>, where they recommend ditching both of these
      simplistic color spaces. ☺
    </para>
  </section>
  <section xml:id="mixing-colors">
    <title>
    Mixing Colors</title>
    <para>
      Given first class colors, the next question is, what operations
      apply to them, the way arithmetic operators apply to numbers and
      higher order functions apply to lists? The equivalent to adding
      numbers is mixing colors, but unfortunately there isn’t a simple
      answer to what that means.
    </para>
    <para>
      The easiest kind of color mixing to understand is
      <emphasis>additive</emphasis> mixing, which is what happens when
      you shine two colored lights onto a (white) wall. It’s also what
      happens in your computer screen, where each dot (pixel) of an
      image is created by a tiny red light, a tiny green light, and a
      tiny blue light that can be combined at different strengths to
      make different colors. Essentially, additive mixing of two colors
      is computed by adding the two red components, the two green
      components, and the two blue components. It’s not
      <emphasis>quite</emphasis> that simple only because each component
      of the result must be in the range 0 to 255. So, red (255, 0, 0)
      mixed with green (0, 255, 0) gives (255, 255, 0), which is yellow.
      But red (255, 0, 0) plus yellow (255, 255, 0) can’t give (510,
      255, 0). Just limiting the red in the result to 255 would mean
      that red plus yellow is yellow, which doesn’t make sense. Instead,
      if the red value has to be reduced by half (from 510 to 255), then
      <emphasis>all three</emphasis> values must be reduced by half, so
      the result is (255, 128, 0), which is orange. (Half of 255 is
      127.5, but each RGB value must be an integer.)
    </para>
    <para>
      A different kind of color mixing based on light is done when
      different colored transparent plastic sheets are held in front of
      a white light, as is done in theatrical lighting. In that
      situation, the light that gets through both filters is what
      remains after some light is filtered out by the first one and some
      of what’s left is filtered out by the second one. In
      red-green-blue terms, a red filter filters out green and blue; a
      yellow filter allows red and green through, filtering out blue.
      But there isn’t any green light for the yellow filter to pass; it
      was filtered out by the red filter. Each filter can only remove
      light, not add light, so this is called
      <emphasis>subtractive</emphasis> mixing:
    </para>
    <para>
      Perhaps confusingly, the numerical computation of subtractive
      mixing is done by <emphasis>multiplying</emphasis> the RGB values,
      taken as fractions of the maximum 255, so red (1, 0, 0) times
      yellow (1, 1, 0) is red again.
    </para>
    <para>
      Those are both straightforward to compute. Much, much more
      complicated is trying to simulate the result of mixing
      <emphasis>paints.</emphasis> It’s not just that we’d have to
      compute a more complicated function of the red, green, and blue
      values; it’s that RGB values (or any other three-dimensional color
      space) are inadequate to describe the behavior of paints. Two
      paints can look identical, and have the same RGB values, but may
      still behave very differently when mixed with other colors. The
      differences are mostly due to the chemistry of the paints, but are
      also affected by exactly how the colors are mixed. The mixing is
      mostly subtractive; red paint <emphasis>absorbs</emphasis> most of
      the colors other than red, so what’s reflected off the surface is
      whatever isn’t absorbed by the colors being mixed. But there can
      be an additive component also.
    </para>
    <para>
      The proper mathematical abstraction to describe a paint is a
      <emphasis>reflectance</emphasis> graph, like this:
    </para>
    <para>
      (These aren’t paints, but minerals, and one software-generated
      spectrum, from the US Geological Survey’s
      <link xlink:href="https://www.usgs.gov/labs/spec-lab/capabilities/spectral-library">Spectral
      Library</link>. The details don’t matter, just the fact that a
      graph like these gives much more information than three RGB
      numbers.) To mix two paints properly, you multiply the
      <emphasis>y</emphasis> values (as fractions) at each matching
      <emphasis>x</emphasis> coordinate of the two graphs.
    </para>
    <para>
      Having said all that, the mix block takes the colors it is given
      as inputs and converts them into what we hope are
      <emphasis>typical</emphasis> paint reflectance spectra that would
      look like those colors, and then mixes those spectra and converts
      back to RGB.
    </para>
    <para>
      But unlike the other two kinds of mixing, in this case we can’t
      say that these colors are “the right answer”; what would happen
      with real paints depends on their chemical composition and how
      they’re mixed. There are three more mixing options, but these
      three are the ones that correspond to real-world color mixing.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1231.png" width="4.34028in" depth="0.65278in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:5R-3G-paint.png</phrase>
        </textobject>
      </inlinemediaobject>The mix block will accept any number of
      colors, and will mix them in equal proportion. If (for any kind of
      mixing) you want more of one color than another, use the color at
      weight block to make a “weighted color”:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1232.png" width="5.16667in" depth="0.43056in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:4R-1G-paint.png</phrase>
        </textobject>
      </inlinemediaobject>This mixes four parts red paint to one part
      green paint. All colors in a mixture can be weighted:
    </para>
    <para>
      (Thanks to
      <link xlink:href="http://scottburns.us/subtractive-color-mixture/">Scott
      Burns</link> for his help in understanding paint mixing, along
      with
      <link xlink:href="http://www.huevaluechroma.com/061.php">David
      Briggs</link>’s tutorial. Remaining mistakes are bh’s.)
    </para>
  </section>
  <section xml:id="tldr">
    <title>tl;dr</title>
    <para>
      For normal people, Snap<emphasis>!</emphasis> provides three
      simple, one-dimensional scales:
      <emphasis><emphasis role="underline">crayons</emphasis></emphasis>
      for specific interesting colors,
      <emphasis><emphasis role="underline">color
      numbers</emphasis></emphasis> for a continuum of high-contrast
      colors with a range of hues and shading, and
      <emphasis><emphasis role="underline">fair
      hues</emphasis></emphasis> for a continuum without shading. For
      color nerds, it provides three-dimensional color spaces RGB, HSL,
      HSV, and fair-hue variants of the latter two.
      <anchor xml:id="spirals" />We recommend “fair HSL” for zeroing in
      on a desired color.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1241.png" width="1.53472in" depth="1.84722in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:squiral-script.png</phrase>
        </textobject>
      </inlinemediaobject>
    </para>
  </section>
  <section xml:id="subappendix-geeky-details-on-fair-hue">
    <title>
    Subappendix: Geeky details on fair hue</title>
    <para>
      Color numbers, no grays.
    </para>
    <para>
      All color numbers.
    </para>
    <para>
      Crayons, no grays.
    </para>
    <para>
      Just grays.
    </para>
    <para>
      Fair hues.
    </para>
    <para>
      The left graph shows that, unsurprisingly, all of the brown fair
      hues make essentially no progress in real hue, with the
      orange-brown section actually a little retrograde, since browns
      are really shades of orange and so the real hues overlap between
      fair browns and fair oranges. Green makes up some of the distance,
      because there are too many green real hues and part of the goal of
      the fair hue scale is to squeeze that part of the hue spectrum.
      But much of the catching up happens very quickly, between pure
      magenta at fair hue 93.75 and the start of the purple-red section
      at fair hue 97. This abrupt change is unfortunate, but the
      alternatives involve either stealing space from red or stealing
      space from purple (which already has to include both spectral
      violet and RGB magenta). The graph has discontinuous derivative at
      the table-lookup points, of which there are two in each color
      family, one at the pure-named-RGB colors at multiples of 12.5, and
      the other <emphasis>roughly</emphasis> halfway to the next color
      family, except for the purple family, which has lookup points at
      87.5 (approximate spectral violet), 93.75 (RGB magenta), and 97
      (turning point toward the red family). (In the color picker, blue
      captures cyan and purple space in dark shades. This, too, is an
      artifact of human vision.)
    </para>
    <para>
      The right graph shows the HSV saturation and value for all the
      fair hues. Saturation is at 100%, as it should be in a hue scale,
      except for a very slight drop in part of the browns. (Browns are
      shades of orange, not tints, so one would expect full saturation,
      except that some of the browns are actually mixtures with related
      hues.) But value, also as expected, falls substantially in the
      browns, to a low of about 56% (halfway to black) for the “pure”
      brown at 45° (fair hue 12.5). But the curve is smooth, without
      inflection points other than that minimum-value pure brown.
    </para>
    <para>
      “Fair saturation” and “fair value” are by definition 100% for the
      entire range of fair hues. This means that in the browns, the real
      saturation and value are the product (in percent) of the innate
      shading of the specific brown fair hue and the user’s fair
      saturation/value setting. When the user’s previous color setting
      was in a real scale and the new setting is in a fair scale, the
      program assumes that the previous saturation and value were
      entirely user-determined; when the previous color setting was in a
      brown fair hue and the new setting is also in a fair scale, the
      program remembers the user’s intention from the previous setting.
      (Internal calculations are based on HSV, even though we recommend
      HSL to users, because HSV comes to us directly from the JavaScript
      color management implementation.) This is why the set pen block
      includes options for “fair saturation” and so on.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1258.png" width="5.9875in" depth="0.37847in" />
        </imageobject>
      </inlinemediaobject>For the extra-geeky, here are the exact table
      lookup points (fair hue, [0,100]):
    </para>
    <para>
      and here are the RGB settings at those points:
    </para>
  </section>
  <section xml:id="subappendix-geeky-details-on-color-numbers">
    <title><inlinemediaobject>
      <imageobject>
        <imagedata fileref="media/image1259.png" width="5.98403in" depth="1.37361in" />
      </imageobject>
    </inlinemediaobject>
    Subappendix: Geeky details on color numbers</title>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1260.png" width="2.08333in" depth="2.29167in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:integers.png</phrase>
        </textobject>
      </inlinemediaobject>Here is a picture of integer color numbers,
      but remember that color numbers are continuous. (As usual,
      “continuous” values are ultimately converted to integer RGB
      values, so there’s really some granularity.) Color numbers 0-14
      are continuously varying grayscale, from 0=black to 14=white.
      Color numbers 14+ε to 20 are linearly varying shades of pink, with
      RGB Red at color number 20.
    </para>
    <para>
      Beyond that point, in each color family, the multiple of ten color
      number in the middle is the RGB standard color of that family, in
      which each component is either 255 or 0. (Exceptions are brown,
      which is of course darker than any of those colors; orange, with
      its green component half-strength: [255, 127, 0]; and violet,
      discussed below.) The following multiple of five is the number of
      the darkest color in that family, although not necessarily the
      same hue as the multiple of ten color number. Color numbers
      between the multiple of ten and the following multiple of five are
      shades of colors entirely within the family. Color numbers in the
      four <emphasis>before</emphasis> the multiple of ten are mixtures
      of this family and the one before it. So, for example, in the
      green family, we have
    </para>
    <para>
      55 Darkest yellow.
    </para>
    <para>
      (55, 60) shades of yellow-green mixtures. As the color number
      increases, both the hue and the lightness (or value, depending on
      your religion) increase, so we get brighter and greener colors.
    </para>
    <para>
      60 Canonical green, [0, 255, 0], whose W3C color name is “lime,”
      not “green.”
    </para>
    <para>
      (60, 65) Shades of green. No cyan mixed in.
    </para>
    <para>
      65 Darkest green.
    </para>
    <para>
      (65,70) Shades of green-cyan mixtures.
    </para>
    <para>
      In the color number chart, all the dark color numbers look a lot
      like black, but they’re quite different. Here are the darkest
      colors in each color number family.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1261.png" width="1.38889in" depth="1.38889in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:darkest.png</phrase>
        </textobject>
      </inlinemediaobject>Darkest yellow doesn’t look entirely yellow.
      You might see it as greenish or brownish. As it turns out, the
      darkest color that really looks yellow is hardly dark at all. This
      color was hand-tweaked to look neither green nor brown to me, but
      ymmv.
    </para>
    <para>
      In some families, the center+5 <emphasis>crayon</emphasis> is an
      important named darker version of the center color: In the red
      family, [128, 0, 0] is “maroon.” In the cyan family, [0, 128, 128]
      is “teal.” An early version of the color number scale used these
      named shades as the center+5 color number also. But on this page
      we use the word “darkest” advisedly: You can’t find a darker shade
      of this family anywhere in the color number scale, but you
      <emphasis>can</emphasis> find lighter shades. Teal is color number
      73.1, ($70 + 5 \bullet \frac{255 - 128}{255 - 50}$), because
      darkest cyan, color 75, is [0, 50, 50]. The color number for
      maroon is left as an exercise for the reader.
    </para>
    <para>
      The purple family is different from the others, because it has to
      include both spectral violet and extraspectral RGB magenta. Violet
      is usually given as RGB [128, 0, 255], but that’s much brighter
      than the violet in an actual spectrum (see page
      <link linkend="rainbow">142</link>). We use [80, 0, 90], a value
      hand-tweaked to look as much as possible like the violet in
      rainbow photos, as color number 90. (<emphasis>Crayon</emphasis>
      90 is [128, 0, 255].) Magenta, [255, 0, 255], is color number 95.
      This means that the colors get <emphasis>brighter,</emphasis> not
      darker, between 90 and 95. The darkest violet is actually color
      number 87.5, so it’s bluer than standard violet, but still plainly
      a purple and not a blue. It’s [39,0,76]. It’s
      <emphasis>not</emphasis> hand-tweaked; it’s a linear interpolation
      between darkest blue, [0, 0, 64], and the violet at color number
      90. I determined by experiment that color number 87.5 is the
      darkest one that’s still unambiguously purple. (According to
      Wikipedia, “violet” names only the spectral color, while “purple”
      is the name of the whole color family.)
    </para>
    <para>
      Here are the reference points for color numbers that are multiples
      of five, except for item 4, which is used for color 14, not color
      15:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1262.png" width="4.58333in" depth="1.27778in" />
        </imageobject>
      </inlinemediaobject>
    </para>
    <para>
      The very pale three-input list blocks are for color numbers that
      are odd multiples of five, generally the “darkest” members of each
      color family. (The block colors were adjusted in Photoshop; don’t
      ask how to get blocks this color in Snap<emphasis>!</emphasis>.)
    </para>
  </section>
</section>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="appendix-b.-apl-features" role="unnumbered">
  <title>
  Appendix B. APL features</title>
  <para>
    The book <emphasis>A Programming Language</emphasis> was published
    by mathematician Kenneth E. Iverson in 1962. He wanted a formal
    language that would look like what mathematicians write on
    chalkboards. The then-unnamed language would later take its name
    from the first letters of the words in the book’s title. It was
    little-known until 1964, when a formal description of the
    just-announced IBM System/360 in the <emphasis>IBM Systems
    Journal</emphasis> used APL notation. (Around the same time,
    Iverson’s associate Adin Falkoff gave a talk on APL to a New York
    Association for Computing Machinery chapter, with an excited
    14-year-old Brian Harvey in the audience.) But it wasn’t until 1966
    that the first public implementation of the language for the
    System/360 was published by IBM. (It was called “APL\360” because
    the normal slash character / represents the “reduce” operator in
    APL, while backslash is “expand.”)
  </para>
  <para>
    The crucial idea behind APL is that mathematicians think about
    collections of numbers, one-dimensional <emphasis>vectors</emphasis>
    and two-dimensional <emphasis>matrices,</emphasis> as valid objects
    in themselves, what computer scientists later learned to call “first
    class data.” A mathematician who wants to add two vectors writes
    <emphasis role="strong"><emphasis>v</emphasis><subscript>1</subscript></emphasis>
    +
    <emphasis role="strong"><emphasis>v</emphasis><subscript>2</subscript></emphasis>,
    not “for i = 1 to length(v1), result[i]=v1[i]+v2[i].” Same for a
    programmer using APL.
  </para>
  <para>
    There are three kinds of function in APL: scalar functions, mixed
    functions, and operators. A <emphasis>scalar function</emphasis> is
    one whose natural domain is individual numbers or text characters. A
    <emphasis>mixed function</emphasis> is one whose domain includes
    arrays (vectors, matrices, or higher-dimensional collections). In
    Snap<emphasis>!</emphasis>, scalar functions are generally found in
    the green Operators palette, while mixed functions are in the red
    Lists palette. The third category, confusingly for
    Snap<emphasis>!</emphasis> users, is called
    <emphasis>operators</emphasis> in APL, but corresponds to what we
    call higher order functions: functions whose domain includes
    functions.
  </para>
  <para>
    Snap<emphasis>!</emphasis> hyperblocks are scalar functions that
    behave like APL scalar functions: they can be called with arrays as
    inputs, and the underlying function is applied to each number in the
    arrays. (If the function is <emphasis>monadic,</emphasis> meaning
    that it takes one input, then there’s no complexity to this idea.
    Take the square root of an array, and you are taking the square root
    of each number in the array. If the function is
    <emphasis>dyadic,</emphasis> taking two inputs, then the two arrays
    must have the same shape. Snap<emphasis>!</emphasis> is more
    forgiving than APL; if the arrays don’t agree in number of
    dimensions, called the <emphasis>rank</emphasis> of the array, the
    lower-rank array is matched repeatedly with subsets of the
    higher-rank one; if they don’t agree in length along one dimension,
    the result has the shorter length and some of the numbers in the
    longer-length array are ignored. An exception in both languages is
    that if one of the two inputs is a scalar, then it is matched with
    every number in the other array input.)
  </para>
  <para>
    As explained in Section IV.F, this termwise extension of scalar
    functions is the main APL-like feature built into
    Snap<emphasis>!</emphasis> itself. We also include an extension of
    the item block to address multiple dimensions, an extension to the
    length block with five list functions from APL, and a new primitive
    reshape block. The APL library extends the implementation of APL
    features to include a few missing scalar functions and several
    missing mixed functions and operators.
  </para>
  <para>
    Programming in APL really is <emphasis>very</emphasis> different in
    style from programming in other languages, even
    Snap<emphasis>!</emphasis>. This appendix can’t hope to be a
    complete reference for APL, let alone a tutorial. If you’re
    interested, find one of those in a library or a (probably used)
    bookstore, read it, and <emphasis>do the exercises.</emphasis> Sorry
    to sound like a teacher, but the notation is sufficiently weird as
    to take a lot of practice before you start to think in APL.
  </para>
  <para>
    A note on versions: There is a widely standardized APL2, several
    idiosyncratic extensions, and a successor language named J. The
    latter uses plain ASCII characters, unlike the ones with APL in
    their names, which use the mathematician’s character set, with Greek
    letters, typestyles (boldface and/or italics in books; underlined,
    upper case, or lower case in APL) as loose type declarations, and
    symbols not part of anyone’s alphabet, such as ⌊ for floor and ⌈ for
    ceiling. To use the original APL, you needed expensive special
    computer terminals. (This was before you could download fonts in
    software. Today the more unusual APL characters are in Unicode at
    U+2336 to U+2395.) The character set was probably the main reason
    APL didn’t take over the world. APL2 has a lot to recommend it for
    Snap<emphasis>!</emphasis> users, mainly because it moves from the
    original APL idea that all arrays must be uniform in dimension, and
    the elements of arrays must be numbers or single text characters, to
    our idea that a list can be an element of another list, and that
    such elements don’t all have to have the same dimensions.
    Nevertheless, its mechanism for allowing both old-style APL arrays
    and more general “nested arrays” is complicated and hard for an APL
    beginner (probably all but two or three Snap<emphasis>!</emphasis>
    users) to understand. So we are starting with plain APL. If it turns
    out to be wildly popular, we may decide later to include APL2
    features.
  </para>
  <para>
    Here are some of the guiding ideas in the design of the APL library:
  </para>
  <para>
    <inlinemediaobject>
      <imageobject>
        <imagedata fileref="media/image1263.png" width="4.45139in" depth="0.52083in" />
      </imageobject>
    </inlinemediaobject>Goal:  Enable interested
    <emphasis role="strong">Snap<emphasis>!</emphasis></emphasis> users
    to learn the feel and style of APL programming. It’s really worth
    the effort. For example, we didn’t hyperize the = block because
    Snap<emphasis>!</emphasis> users expect it to give a single
    yes-or-no answer about the equality of two complete structures,
    whatever their types and shapes. In APL, = is a scalar function; it
    compares two numbers or two characters. How could APL users live
    without the ability to ask if two <emphasis>structures</emphasis>
    are equal? Because in APL you can say
    <emphasis role="strong">∧</emphasis>/,a=b to get that answer.
    Reading from right to left, a=b reports an array of Booleans
    (represented in APL as 0 for False, 1 for True); the comma operator
    turns the shape of the array into a simple vector; and
    <emphasis role="strong">∧</emphasis>/ means “reduce with and”;
    “reduce” is our combine function. That six-character program is much
    less effort than the equivalent
  </para>
<literallayout><inlinemediaobject>
<imageobject>
<imagedata fileref="media/image1264.png" width="0.99306in" depth="0.20833in" />
</imageobject>
</inlinemediaobject>in Snap<emphasis>!</emphasis>. Note in passing that if you wanted to know <emphasis>how many</emphasis> corresponding elements of the two arrays are equal, you’d just use +/ instead of <emphasis role="strong">∧</emphasis>/. Note also that our APLish blocks are a little verbose, because they include up to three notations for the function: the usual Snap<emphasis>!</emphasis> name (e.g., flatten), the name APL programmers use when talking about it (ravel), and, in yellow type, the symbol used in actual APL code (,). We’re not consistent about it; seems self-documenting. And LCM (and) is different even though it has two names; it turns out that if you represent Boolean values as 0 and 1, then the algorithm to compute the least common multiple of two integers computes the and function if the two inputs happen to be Boolean. Including the APL symbols serves two purposes: the two or three Snap<emphasis>!</emphasis> users who’ve actually programmed in APL will be sure what function they’re using, but more importantly, the ones who are reading an APL tutorial while building programs in Snap<emphasis>!</emphasis> will find the block that matches the APL they’re reading.

Goal:  Bring the best and most general APL ideas into “mainstream” <emphasis role="strong">Snap<emphasis>!</emphasis></emphasis> programming style. Media computation, in particular, becomes much simpler when scalar functions can be applied to an entire picture or sound. Yes, map provides essentially the same capability, but the notation gets complicated if you want to map over columns rather than rows. Also, Snap<emphasis>!</emphasis> lists are fundamentally one-dimensional, but real data often have more dimensions. A Snap<emphasis>!</emphasis> programmer has to be thinking all the time about the convention that we represent a matrix as a list of rows, each of which is a list of individual cells. That is, row 23 of a spreadsheet is item 23 of spreadsheet, but column 23 is map (item 23 of _) over spreadsheet. APL treats rows and columns more symmetrically.

Non-goal:  Allow programs written originally in APL to run in <emphasis role="strong">Snap<emphasis>!</emphasis></emphasis> essentially unchanged.  For example, in APL the atomic text unit is a single character, and strings of characters are lists. We treat a text string as scalar, and that isn’t going to change. Because APL programmers rarely use conditionals, instead computing functions involving arrays of Boolean values to achieve the same effect, the notation they do have for conditionals is primitive (in the sense of Paleolithic, not in the sense of built in). We’re not changing ours.

Non-goal:  Emulate the terse APL syntax. It’s too bad, in a way; as noted above, the terseness of expressing a computation affects APL programmers’ sense of what’s difficult and what isn’t. But you can’t say “terse” and “block language” in the same sentence. Our whole <emphasis>raison d’être</emphasis> is to make it possible to build a program without having to memorize the syntax or the names of functions, and to allow those names to be long enough to be self-documenting. And APL’s syntax has its own issues, of which the biggest is that it’s hard to use functions with more than two inputs; because most mathematical dyadic functions use infix notation (the function symbol between the two inputs), the notion of “left argument” and “right argument” is universal in APL documentation. The thing people most complain about, that there is no operator precedence (like the multiplication-before-addition rule in normal arithmetic notation), really doesn’t turn out to be a problem. Function grouping is strictly right to left, so 2×3+4 means two times seven, not six plus four. That takes some getting used to, but it really doesn’t take long if you immerse yourself in APL. The reason is that there are too many infix operators for people to memorize a precedence table. But in any case, block notation eliminates the problem, especially with Snap<emphasis>!</emphasis>’s zebra coloring. You can see and control the grouping by which block is inside which other block’s input slot. Another problem with APL’s syntax is that it bends over backward not to have reserved words, as opposed to Fortran, its main competition back then. So the dyadic <emphasis role="strong">○</emphasis> “circular functions” function uses the left argument to select a trig function. 1<emphasis role="strong">○</emphasis>x is sin(x), 2<emphasis role="strong">○</emphasis>x is cos(x), and so on. <emphasis role="strong">‾</emphasis>1<emphasis role="strong">○</emphasis>x is arcsin(x). What’s 0<emphasis role="strong">○</emphasis>x? Glad you asked; it’s$\ \sqrt{1 - x^{2}}$.</literallayout>
  <section xml:id="boolean-values">
    <title>Boolean values</title>
    <para>
      Snap<emphasis>!</emphasis> uses distinct Boolean values true and
      false that are different from other data types. APL uses 1 and 0,
      respectively. The APL style of programming depends heavily on
      doing arithmetic on Booleans, although their conditionals insist
      on only 0 or 1 in a Boolean input slot, not other numbers.
      Snap<emphasis>!</emphasis> <emphasis>arithmetic</emphasis>
      functions treat false as 0 and true as 1, so our APL library tries
      to report Snap<emphasis>!</emphasis> Boolean values from predicate
      functions.
    </para>
  </section>
  <section xml:id="scalar-functions">
    <title><inlinemediaobject>
      <imageobject>
        <imagedata fileref="media/image1265.png" width="5.73333in" depth="1.10667in" />
      </imageobject>
    </inlinemediaobject>Scalar functions</title>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1266.png" width="2.56667in" depth="0.21667in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:roll-8-dice.png</phrase>
        </textobject>
      </inlinemediaobject>These are the scalar functions in the APL
      library. Most of them are straightforward to figure out. The
      scalar = block provides an APL-style version of = (and other
      exceptions) as a hyperblock that extends termwise to arrays. Join,
      the only non-predicate non-hyper scalar primitive, has its own
      scalar join block. 7 deal 52 reports a random vector of seven
      numbers from 1 to 52 with no repetitions, as in dealing a hand of
      cards. Signum of a number reports 1 if the number is positive, 0
      if it’s zero, or -1 if it’s negative. Roll 6 reports a random roll
      of a six-sided die. To roll 8 dice, use , which would look much
      more pleasant as ?8⍴6. But perhaps our version is more instantly
      readable by someone who didn’t grow up with APL. All the library
      functions have help messages available.
    </para>
  </section>
  <section xml:id="mixed-functions">
    <title>Mixed functions</title>
    <para>
      Mixed functions include lists in their natural domain or range.
      That is, one or both of its inputs <emphasis>must</emphasis> be a
      list, or it always reports a list. Sometimes both inputs are
      naturally lists; sometimes one input of a dyadic mixed function is
      naturally a scalar, and the function treats a list in that input
      slot as an implicit map, as for scalar functions. This means you
      have to learn the rule for each mixed function individually.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1267.png" width="4.275in" depth="1.1in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:shape-example.png</phrase>
        </textobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1268.png" width="1.06667in" depth="0.18333in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:shape-of.png</phrase>
        </textobject>
      </inlinemediaobject>The shape of function takes any input and
      reports a vector of the maximum size of the structure along each
      dimension. For a vector, it returns a list of length 1 containing
      the length of the input. For a matrix, it returns a two-item list
      of the number of rows and number of columns of the input. And so
      on for higher dimensions. If the input isn’t a list at all, then
      it has zero dimensions, and shape of reports an empty vector.
    </para>
    <para>
      Equivalent to the dimensions of primitive, as of 6.6.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1269.png" width="1.04167in" depth="0.18333in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:rank.png</phrase>
        </textobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1270.png" width="2.03333in" depth="0.18333in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:reshape.png</phrase>
        </textobject>
      </inlinemediaobject>Rank of isn’t an actual APL primitive, but the
      composition ⍴⍴ (shape of shape of a structure), which reports the
      number of dimensions of the structure (the length of its shape
      vector), is too useful to omit. (It’s very easy to type the same
      character twice on the APL keyboard, but less easy to drag blocks
      together.) Equivalent to the rank of primitive, as of 6.6.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1271.png" width="7.325in" depth="0.83333in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:reshape-ex.png</phrase>
        </textobject>
      </inlinemediaobject>Reshape takes a shape vector (such as shape
      might report) on the left and any structure on the right. It
      ignores the shape of the right input, stringing the atomic
      elements into a vector in row-major order (that is, all of the
      first row left to right, then all of the second row, etc.). (The
      primitive reshape takes the inputs in the other order.) It then
      reports an array with the shape specified by the first input
      containing the items of the second:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1272.png" width="6.575in" depth="1.04167in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:identity-matrix.png</phrase>
        </textobject>
      </inlinemediaobject>If the right input has more atomic elements
      than are required by the left-input shape vector, the excess are
      ignored without reporting an error. If the right input has too
      <emphasis>few</emphasis> atomic elements, the process of filling
      the reported array starts again from the first element. This is
      most useful in the specific case of an atomic right input, which
      produces an array of any desired shape all of whose atomic
      elements are equal. But other cases are sometimes useful too:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1275.png" width="1.43333in" depth="0.18333in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:ravel.png</phrase>
        </textobject>
      </inlinemediaobject>Flatten takes an arbitrary structure as input
      and reports a vector of its atomic elements in row-major order.
      Lispians call this flattening the structure, but APLers call it
      “ravel” because of the metaphor of pulling on a ball of yarn, so
      what they really mean is “unravel.” (But the snarky sound of that
      is uncalled-for, because a more advanced version that we might
      implement someday is more like raveling.) One APL idiom is to
      apply this to a scalar in order to turn it into a one-element
      vector, but we can’t use it that way because you can’t type a
      scalar value into the List-type input slot. Equivalent to the
      primitive flatten of block.
    </para>
    <para>
      ID ← {(⍵,⍵)⍴1,⍵⍴0}
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1280.png" width="7.20417in" depth="0.58333in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:catenate-ex.png</phrase>
        </textobject>
      </inlinemediaobject>Catenate is like our primitive append, with
      two differences: First, if either input is a scalar, it is treated
      like a one-item vector. Second, if the two inputs are of different
      rank, the catenate function is recursively mapped over the
      higher-rank input:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1281.png" width="0.53333in" depth="0.25in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:iota.png</phrase>
        </textobject>
      </inlinemediaobject>Catenate vertically is similar, but it adds
      new rows instead of adding new columns.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1282.png" width="6.34167in" depth="1.04167in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:numbers-ex.png</phrase>
        </textobject>
      </inlinemediaobject>Integers (I think that’s what it stands for,
      although APLers just say “iota”) takes a positive integer input
      and reports a vector of the integers from 1 to the input. This is
      an example of a function classed as “mixed” not because of its
      domain but because of its range. The difference between this block
      and the primitive numbers from block is in its treatment of lists
      as inputs. Numbers from is a hyperblock, applying itself to each
      item of its input list:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1283.png" width="6.025in" depth="0.83333in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:iota-list-ex.png</phrase>
        </textobject>
      </inlinemediaobject>Iota has a special meaning for list inputs:
      The input must be a shape vector; the result is an array with that
      shape in which each item is a list of the indices of the cell
      along each dimension. A picture is worth
      10<superscript>3</superscript> words, but
      Snap<emphasis>!</emphasis> isn’t so good at displaying arrays with
      more than two dimensions, so here we reduce each cell’s index list
      to a string:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1284.png" width="1.475in" depth="0.25in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:dyadic-iota.png</phrase>
        </textobject>
      </inlinemediaobject>
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1285.png" width="5.95in" depth="1.1in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:dy-iota-ex.png</phrase>
        </textobject>
      </inlinemediaobject>Dyadic iota is like the index of primitive
      except for its handling of multi-dimensional arrays. It looks only
      for atomic elements, so a vector in the second input doesn’t mean
      to search for that vector as a row of a matrix, which is what it
      means to index of, but rather to look separately for each item of
      the vector, and report a list of the locations of each item. If
      the first input is a multi-dimensional array, then the location of
      an item is a vector with the indices along each row.
    </para>
    <para>
      In this example, the 4 is in the second row, second column. (This
      is actually an extension of APL iota, which is more like a
      hyperized index of.) Generalizing, if the rank of the second input
      is less than the rank of the first input by two or more, then iota
      looks for the entire second input in the first input. The reported
      position is a vector <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1286.png" width="5.84167in" depth="0.35in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:dy-iota-ex2.png</phrase>
        </textobject>
      </inlinemediaobject>whose length is equal to the difference
      between the two ranks. If the rank of the second input is one less
      than the rank of the first, the reported value is a scalar, the
      index of the entire second input in the first.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1287.png" width="5.38333in" depth="1.1in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:dy-iota-ex3.png</phrase>
        </textobject>
      </inlinemediaobject>
    </para>
    <para>
      However, if the two ranks are equal, then the block is hyperized;
      each item of the second input is located in the first input. As
      the next example shows, only the first instance of each item is
      found (e.g., the 1 in position 2, not the 1 in position 4); if an
      item does not occur in the left input, what is reported is one
      more than the length of the left input (here, 8).
    </para>
    <para>
      Why the strange design decision to report length+1 when something
      isn’t found, instead of a more obvious flag value such as 0 or
      false? Here’s why:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1292.png" width="2.175in" depth="0.225in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:contained.png</phrase>
        </textobject>
      </inlinemediaobject>Note that code has 27 items, not 26. The
      asterisk at the end is the ciphertext is the translation of all
      non-alphabet characters (spaces and the apostrophe in “doesn’t”).
      This is a silly example, because it makes up a random cipher every
      time it’s called, and it doesn’t report the cipher, so the
      recipient can’t decipher the message. And you wouldn’t want to
      make the spaces in the message so obvious. But despite being
      silly, the example shows the benefit of reporting length+1 as the
      position of items not found.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1293.png" width="7.48542in" depth="0.65972in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:contained-ex.png</phrase>
        </textobject>
      </inlinemediaobject>The contained in block is like a hyperized
      contains with the input order reversed. It reports an array of
      Booleans the same shape as the left input. The shape of the right
      input doesn’t matter; the block looks only for atomic elements.
    </para>
    <para>
      The blocks grade up and grade down are used for sorting data.
      Given an array as input, it reports a vector of the indices in
      which the items (the rows, if a matrix) should be rearranged in
      order to be sorted. This will be clearer with an example:
    </para>
    <para>
      The result from grade up tells us that item 3 of
      <emphasis role="strong">foo</emphasis> comes first in sorted
      order, then item 4, then 2, then 1. When we actually select items
      of <emphasis role="strong">foo</emphasis> based on this ordering,
      we get the desired sorted version. The result reported by grade
      down is almost the reverse of that from grade up, but not quite,
      if there are equal items in the list. (The sort is stable, so if
      there are equal items, then whichever comes first in the input
      list will also be first in the sorted list.)
    </para>
    <para>
      Why this two-step process? Why not just have a sort primitive in
      APL? One answer is that in a database application you might want
      to sort one array based on the order of another array:
    </para>
    <para>
      This is the list of employees of a small company. (Taken from
      <emphasis>Structure and Interpretation of Computer
      Programs</emphasis> by Abelson and Sussman. Creative Commons
      licensed.) Each of the smaller lists contains a person's name, job
      title, and yearly salary. <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1304.png" width="5.48333in" depth="2.2in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:database.png</phrase>
        </textobject>
      </inlinemediaobject>We would like to sort the employees’ names in
      big-to-small order of salary. First we extract column 3 of the
      database, the salaries:
    </para>
<literallayout><inlinemediaobject>
<imageobject>
<imagedata fileref="media/image1305.png" width="3.55903in" depth="1.97639in" />
</imageobject>
</inlinemediaobject>
Then we use grade down to get the reordering indices:</literallayout>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1306.png" width="5.33333in" depth="2.37333in" />
        </imageobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1307.png" width="4.97847in" depth="2.23333in" />
        </imageobject>
      </inlinemediaobject>At this point we <emphasis>could</emphasis>
      use the index vector to sort the salaries:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1308.png" width="5.59333in" depth="2.3in" />
        </imageobject>
      </inlinemediaobject>But what we actually want is a list of
      <emphasis>names,</emphasis> sorted by salary:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1309.png" width="2.30833in" depth="0.275in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:row-select.png</phrase>
        </textobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1310.png" width="2.91667in" depth="0.325in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:column-select.png</phrase>
        </textobject>
      </inlinemediaobject>By taking the index vector from grade down of
      column 3 and telling item to apply it to column 1, we get what we
      set out to find. As usual the code is more elegant in APL:
      database[⍒database[;3];1].
    </para>
    <para>
      In case you’ve forgotten, or would select the third
      <emphasis>row</emphasis> of the database; we need the list 3 in
      the second input slot of the outer list to select by columns
      rather than by rows.
    </para>
    <para>
      Select (if take) or select all but (if drop) the first (if
      <emphasis>n</emphasis>&gt;0) or last (if
      <emphasis>n</emphasis>&lt;0) |<emphasis>n</emphasis>| items from a
      vector, or rows from a matrix. Alternatively, if the left input is
      a two-item vector, select rows with the first item and columns
      with the second.
    </para>
    <para>
      The compress block selects a subset of its right input based on
      the Boolean values in its left input, which must be a vector of
      Booleans whose length equals the length of the array (the number
      of rows, for a matrix) in the right input. The block reports an
      array of the same rank as the right input, but containing only
      those rows whose corresponding Boolean value is true. The columns
      version <emphasis role="strong">⌿</emphasis> is the same but
      selecting columns rather than selecting rows.
    </para>
    <para>
      A word about the possibly confusing names of these blocks: There
      are two ways to think about what they do. Take the standard /
      version, to avoid talking about both at once. One way to think
      about it is that it selects some of the rows. The other way is
      that it shortens the columns. For Lispians, which includes you
      since you’ve learned about keep, the natural way to think about /
      is that it keeps some of the rows. Since we represent a matrix as
      a list of rows, that also fits with how this function is
      implemented. (Read the code; you’ll find a keep inside.) But APL
      people think about it the other way, so when you read APL
      documentation, / is described as operating on the last dimension
      (the columns), while <emphasis role="strong">⌿</emphasis> is
      described as operating on rows. We were more than a month into
      this project before I understood all this. You get long block
      names so it won’t take you a month!
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1319.png" width="3.175in" depth="0.18333in" />
        </imageobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1320.png" width="2.99444in" depth="0.23333in" />
        </imageobject>
      </inlinemediaobject><inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1321.png" width="1.11181in" depth="0.23333in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:transpose.png</phrase>
        </textobject>
      </inlinemediaobject>Don’t confuse this block with the reduce
      block, whose APL symbol is also a slash. In that block, what comes
      to the left of the slash is a dyadic combining function; it’s the
      APL equivalent of combine. This block is more nearly equivalent to
      keep. But keep takes a predicate function as input, and calls the
      function for each item of the second input. With compress, the
      predicate function, if any, has already been called on all the
      items of the right input in parallel, resulting in a vector of
      Boolean values. This is a typical APL move; since hyperblocks are
      equivalent to an implicit map, it’s easy to make the vector of
      Booleans, because any scalar function, including predicates, can
      be applied to a list instead of to a scalar. The reason both
      blocks use the / character is that both of them reduce the size of
      the input array, although in different ways.
    </para>
    <para>
      The reverse row order, reverse column order, and transpose blocks
      form a group: the group of reflections of a matrix. The APL
      symbols are all a circle with a line through it; the lines are the
      different axes of reflection. So the reverse row order block
      reverses which row is where; the reverse column order block
      reverses which column is where; and the transpose block turns rows
      into columns and vice versa:
    </para>
    <para>
      Except for reverse row order, these work only on full arrays, not
      ragged-right lists of lists, because the result of the other two
      would be an array in which some rows had “holes”: items 1 and 3
      exist, but not item 2. We don’t have a representation for that.
      (In APL, all arrays are full, so it’s even more restrictive.)
    </para>
  </section>
  <section xml:id="higher-order-functions">
    <title>Higher order functions</title>
    <para>
      The final category of function is operators—APL higher order
      functions. APL has no explicit map function, because the
      hyperblock capability serves much the same need. But APL2 did add
      an explicit map, which we might get around to adding to the
      library next time around. Its symbol is
      <emphasis role="strong">¨</emphasis> (diaeresis or umlaut).
    </para>
    <para>
      The APL equivalent of keep is compress, but it’s not a higher
      order function. You create a vector of Booleans (0s and 1s, in
      APL) before applying the function to the array you want to
      compress.
    </para>
    <para>
      But APL does have a higher order version of combine:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1332.png" width="6.68333in" depth="1.04167in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:matrix.png</phrase>
        </textobject>
      </inlinemediaobject>The reduce block works just like combine,
      taking a dyadic function and a list. The / version translates each
      row to a single value; the <emphasis role="strong">⌿</emphasis>
      version translates each column to a single value. That’s the only
      way to think about it from the perspective of combining individual
      elements: you are adding up, or whatever the function is, the
      numbers in a single row (/) or in a single column
      (<emphasis role="strong">⌿</emphasis>). But APLers think of a
      matrix as made up of vectors, either row vectors or column
      vectors. And if you think of what these blocks do as adding
      vectors, rather than adding individual numbers, it’s clear that in
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1333.png" width="5.83333in" depth="1.1in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:add-matrix.png</phrase>
        </textobject>
      </inlinemediaobject>
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1334.png" width="4.80833in" depth="1.1in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:non-apl-combine.png</phrase>
        </textobject>
      </inlinemediaobject>the <emphasis>vector</emphasis> (10, 26, 42)
      is the sum of <emphasis>column vectors</emphasis> (1, 5, 9)+(2, 6,
      10)+(3, 7, 11)+(4, 8, 12). In pre-6.0 Snap<emphasis>!</emphasis>,
      we’d get the same result this way:
    </para>
<literallayout>mapping over the <emphasis>rows</emphasis> of the matrix, applying combine to each row. Combining rows, reducing column vectors.
The outer product block takes two arrays (vectors, typically) and a dyadic scalar function as inputs. It reports an array whose rank is the sum of the ranks of the inputs (so, typically a matrix), in which each item is the result of applying the function to an atomic element of each array. The third element of the second row of the result is the value reported by the function with the second element of the left input and the third element of the right input. (The APL symbol ◦. is pronounced “jot dot.”) The way to think about this block is “multiplication table” from elementary school:</literallayout>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1335.png" width="7.24in" depth="1.52in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:outer-ex.png</phrase>
        </textobject>
      </inlinemediaobject>
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1336.png" width="2.16667in" depth="0.24167in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:outer.png</phrase>
        </textobject>
      </inlinemediaobject>
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1337.png" width="2.61667in" depth="0.24167in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:inner.png</phrase>
        </textobject>
      </inlinemediaobject>
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1338.png" width="7.33861in" depth="1.00694in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:inner-ex.png</phrase>
        </textobject>
      </inlinemediaobject>The inner product block takes two matrices and
      two operations as input. The number of columns in the left matrix
      must equal the number of rows in the right matrix. When the two
      operations are + and ×, this is the matrix multiplication familiar
      to mathematicians:
    </para>
    <para>
      But other operations can be used. One common inner product is ∨.∧
      (“or dot and”) applied to Boolean matrices, to find rows and
      columns that have corresponding items in common.
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1339.png" width="0.95833in" depth="0.18333in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:printable.png</phrase>
        </textobject>
      </inlinemediaobject>The printable block isn’t an APL function;
      it’s an aid to exploring APL-in-Snap<emphasis>!</emphasis>. It
      transforms arrays to a compact representation that still makes the
      structure clear:
    </para>
    <para>
      <inlinemediaobject>
        <imageobject>
          <imagedata fileref="media/image1340.png" width="5.99792in" depth="0.33333in" />
        </imageobject>
        <textobject>
          <phrase>Macintosh HD:Users:bh:Desktop:printable-ex.png</phrase>
        </textobject>
      </inlinemediaobject>Experts will recognize this as the Lisp
      representation of list structure,
    </para>
    <para>
      Index
    </para>
    <para>
      ! block · 32
    </para>
    <para>
      .csv file · 134
    </para>
    <para>
      .json file · 134
    </para>
    <para>
      .txt file · 134
    </para>
    <para>
      # variable · 25
    </para>
    <para>
      #1 · 69
    </para>
    <para>
      + block · 22
    </para>
    <para>
      × block · 22
    </para>
    <para>
      ≠ block · 20
    </para>
    <para>
      ≤ block · 20
    </para>
    <para>
      ≥ block · 20
    </para>
    <para>
      ⚡ (lightning bolt) · 123
    </para>
    <para>
      A
    </para>
    <para>
      a new clone of block · 77
    </para>
    <para>
      <emphasis>A Programming Language</emphasis> · 148
    </para>
    <para>
      Abelson, Hal · 4
    </para>
    <para>
      About option · 107
    </para>
    <para>
      add comment option · 124, 125
    </para>
    <para>
      Add scene… option · 111
    </para>
    <para>
      additive mixing · 144
    </para>
    <para>
      Advanced Placement Computer Science Principles · 110
    </para>
    <para>
      AGPL · 107
    </para>
    <para>
      all but first blocks · 27
    </para>
    <para>
      all but first of block · 49
    </para>
    <para>
      all but first of stream block · 26
    </para>
    <para>
      all but last blocks · 27
    </para>
    <para>
      all of block · 28
    </para>
    <para>
      Alonzo · 9, 55
    </para>
    <para>
      anchor · 10
    </para>
    <para>
      anchor (in my block) · 78
    </para>
    <para>
      animate block · 33
    </para>
    <para>
      animation · 12
    </para>
    <para>
      animation library · 33
    </para>
    <para>
      anonymous list · 46
    </para>
    <para>
      Any (unevaluated) type · 72
    </para>
    <para>
      any of block · 28
    </para>
    <para>
      Any type · 60
    </para>
    <para>
      APL · 4, 58, 148
    </para>
    <para>
      APL character set · 149
    </para>
    <para>
      APL library · 35, 148
    </para>
    <para>
      APL2 · 149
    </para>
    <para>
      APL\360 · 148
    </para>
    <para>
      Arduino · 92
    </para>
    <para>
      arithmetic · 11
    </para>
    <para>
      array, dynamic · 49
    </para>
    <para>
      arrow, upward-pointing · 63
    </para>
    <para>
      arrowheads · 46, 63, 69
    </para>
    <para>
      ask and wait block · 24
    </para>
    <para>
      ask block · 86
    </para>
    <para>
      assoc block · 25
    </para>
    <para>
      association list · 88
    </para>
    <para>
      associative function · 51
    </para>
    <para>
      at block · 19
    </para>
    <para>
      atan2 block · 20
    </para>
    <para>
      atomic data · 57
    </para>
    <para>
      attribute · 76
    </para>
    <para>
      attributes, list of · 78
    </para>
    <para>
      audio comp library · 34
    </para>
    <para>
      B
    </para>
    <para>
      background blocks · 19
    </para>
    <para>
      Backgrounds… option · 112
    </para>
    <para>
      backspace key (keyboard editor) · 131
    </para>
    <para>
      Ball, Michael · 4
    </para>
    <para>
      bar chart block · 28
    </para>
    <para>
      bar charts library · 28
    </para>
    <para>
      base case · 44
    </para>
    <para>
      BIGNUMS block · 32
    </para>
    <para>
      binary tree · 47
    </para>
    <para>
      bitmap · 79, 112
    </para>
    <para>
      bitwise library · 36
    </para>
    <para>
      bjc.edc.org · 137
    </para>
    <para>
      Black Hole problem · 139
    </para>
    <para>
      block · 6; command · 6; C-shaped · 7; hat · 6; predicate · 12;
      reporter · 10; sprite-local · 75
    </para>
    <para>
      Block Editor · 41, 42, 59
    </para>
    <para>
      block label · 102
    </para>
    <para>
      block library · 45, 110
    </para>
    <para>
      block picture option · 124
    </para>
    <para>
      block shapes · 40, 60
    </para>
    <para>
      block variable · 43
    </para>
    <para>
      block with no name · 32
    </para>
    <para>
      blockify option · 134
    </para>
    <para>
      blocks, color of · 40
    </para>
    <para>
      Boole, George · 12
    </para>
    <para>
      Boolean · 12
    </para>
    <para>
      Boolean (unevaluated) type · 72
    </para>
    <para>
      Boolean constant · 12
    </para>
    <para>
      box of ten crayons · 139
    </para>
    <para>
      box of twenty crayons · 139
    </para>
    <para>
      break command · 99
    </para>
    <para>
      breakpoint · 17, 118
    </para>
    <para>
      Briggs, David · 145
    </para>
    <para>
      broadcast and wait block · 9, 125
    </para>
    <para>
      broadcast block · 21, 23, 73, 125
    </para>
    <para>
      brown dot · 9
    </para>
    <para>
      Build Your Own Blocks · 40
    </para>
    <para>
      Burns, Scott · 145
    </para>
    <para>
      button: pause · 17; recover · 39; visible stepping · 18
    </para>
    <para>
      C
    </para>
    <para>
      C programming language · 68
    </para>
    <para>
      call block · 65, 68
    </para>
    <para>
      call w/continuation block · 97
    </para>
    <para>
      camera icon · 126
    </para>
    <para>
      Cancel button · 129
    </para>
    <para>
      carriage return character · 20
    </para>
    <para>
      cascade blocks · 26
    </para>
    <para>
      case-independent comparisons block · 33
    </para>
    <para>
      cases block · 28
    </para>
    <para>
      catch block · 26, 99
    </para>
    <para>
      catch errors library · 31
    </para>
    <para>
      catenate block · 152
    </para>
    <para>
      catenate vertically block · 152
    </para>
    <para>
      center of the stage · 22
    </para>
    <para>
      center x (in my block) · 78
    </para>
    <para>
      center y (in my block) · 78
    </para>
    <para>
      Chandra, Kartik · 4
    </para>
    <para>
      change background block · 22
    </para>
    <para>
      Change password… option · 113
    </para>
    <para>
      change pen block · 24, 29, 117, 140
    </para>
    <para>
      child class · 87
    </para>
    <para>
      children (in my block) · 78
    </para>
    <para>
      Church, Alonzo · 9
    </para>
    <para>
      class · 85
    </para>
    <para>
      class/instance · 76
    </para>
    <para>
      clean up option · 125
    </para>
    <para>
      clear button · 129
    </para>
    <para>
      clicking on a script · 122
    </para>
    <para>
      Clicking sound option · 116
    </para>
    <para>
      clone: permanent · 74; temporary · 74
    </para>
    <para>
      clone of block · 89
    </para>
    <para>
      clones (in my block) · 78
    </para>
    <para>
      cloud (startup option) · 136
    </para>
    <para>
      Cloud button · 37, 108
    </para>
    <para>
      cloud icon · 113
    </para>
    <para>
      cloud storage · 37
    </para>
    <para>
      CMY · 138
    </para>
    <para>
      CMYK · 138
    </para>
    <para>
      codification support option · 117
    </para>
    <para>
      color at weight block · 145
    </para>
    <para>
      color block · 140
    </para>
    <para>
      color chart · 147
    </para>
    <para>
      color from block · 29, 140
    </para>
    <para>
      color nerds · 145
    </para>
    <para>
      color numbers · 29, 138, 139
    </para>
    <para>
      color of blocks · 40
    </para>
    <para>
      color palette · 128
    </para>
    <para>
      color picker · 143
    </para>
    <para>
      color scales · 141
    </para>
    <para>
      color space · 138
    </para>
    <para>
      color theory · 138
    </para>
    <para>
      Colors and Crayons library · 138
    </para>
    <para>
      colors library · 29
    </para>
    <para>
      columns of block · 57
    </para>
    <para>
      combine block · 50
    </para>
    <para>
      combine block (APL) · 157
    </para>
    <para>
      command block · 6
    </para>
    <para>
      comment box · 125
    </para>
    <para>
      compile menu option · 123
    </para>
    <para>
      compose block · 26
    </para>
    <para>
      compress block · 156
    </para>
    <para>
      Computer Science Principles · 110
    </para>
    <para>
      cond in Lisp · 28
    </para>
    <para>
      conditional library: multiple-branch · 28
    </para>
    <para>
      constant functions · 71
    </para>
    <para>
      constructors · 47
    </para>
    <para>
      contained in block · 153
    </para>
    <para>
      context menu · 119
    </para>
    <para>
      context menu for the palette background · 120
    </para>
    <para>
      context menus for palette blocks · 119
    </para>
    <para>
      continuation · 93
    </para>
    <para>
      continuation passing style · 94
    </para>
    <para>
      Control palette · 7
    </para>
    <para>
      controls in the Costumes tab · 126
    </para>
    <para>
      controls in the Sounds tab · 130
    </para>
    <para>
      controls on the stage · 132
    </para>
    <para>
      control-shift-enter (keyboard editor) · 132
    </para>
    <para>
      copy of a list · 50
    </para>
    <para>
      CORS · 92
    </para>
    <para>
      cors proxies · 92
    </para>
    <para>
      costume · 6, 8
    </para>
    <para>
      costume from text block · 31
    </para>
    <para>
      costume with background block · 31
    </para>
    <para>
      costumes (in my block) · 78
    </para>
    <para>
      Costumes tab · 9, 126
    </para>
    <para>
      costumes, first class · 79
    </para>
    <para>
      Costumes… option · 112
    </para>
    <para>
      counter class · 85
    </para>
    <para>
      CPS · 96
    </para>
    <para>
      crayon library · 31
    </para>
    <para>
      crayons · 29, 138, 139
    </para>
    <para>
      create var block · 32
    </para>
    <para>
      create variables library · 32
    </para>
    <para>
      Cross-Origin Resource Sharing · 92
    </para>
    <para>
      crossproduct · 70
    </para>
    <para>
      cs10.org · 137
    </para>
    <para>
      C-shaped block · 7, 67
    </para>
    <para>
      C-shaped slot · 72
    </para>
    <para>
      CSV (comma-separated values) · 54
    </para>
    <para>
      CSV format · 20
    </para>
    <para>
      csv of block · 57
    </para>
    <para>
      current block · 92
    </para>
    <para>
      current date or time · 92
    </para>
    <para>
      current location block · 34
    </para>
    <para>
      current sprite · 122
    </para>
    <para>
      custom block in a script · 124
    </para>
    <para>
      custom? of block block · 102
    </para>
    <para>
      cyan · 142
    </para>
    <para>
      D
    </para>
    <para>
      dangling rotation · 10
    </para>
    <para>
      dangling? (in my block) · 78
    </para>
    <para>
      dark candy apple red · 141
    </para>
    <para>
      data hiding · 73
    </para>
    <para>
      data structure · 47
    </para>
    <para>
      data table · 88
    </para>
    <para>
      data type · 19, 59
    </para>
    <para>
      database library · 34
    </para>
    <para>
      date · 92
    </para>
    <para>
      Dave, Achal · 4
    </para>
    <para>
      deal block · 150
    </para>
    <para>
      debugging · 118
    </para>
    <para>
      Debugging · 17
    </para>
    <para>
      deep copy of a list · 50
    </para>
    <para>
      default value · 63
    </para>
    <para>
      define block · 102
    </para>
    <para>
      define of recursive procedure · 104
    </para>
    <para>
      <emphasis>definition (of block)</emphasis> · 102
    </para>
    <para>
      definition of block · 101
    </para>
    <para>
      delegation · 87
    </para>
    <para>
      Delete a variable · 14
    </para>
    <para>
      delete block definition… option · 120
    </para>
    <para>
      delete option · 124, 128, 133
    </para>
    <para>
      delete var block · 32
    </para>
    <para>
      denim · 139
    </para>
    <para>
      design principle · 46, 77
    </para>
    <para>
      devices · 91, 92
    </para>
    <para>
      dialog, input name · 42
    </para>
    <para>
      dimensions of block · 57
    </para>
    <para>
      Dinsmore, Nathan · 4
    </para>
    <para>
      direction to block · 22
    </para>
    <para>
      Disable click-to-run option · 117
    </para>
    <para>
      dispatch procedure · 85, 86, 88
    </para>
    <para>
      distance to block · 22
    </para>
    <para>
      dl (startup option) · 136
    </para>
    <para>
      do in parallel block · 31
    </para>
    <para>
      does var exist block · 32
    </para>
    <para>
      down arrow (keyboard editor) · 131
    </para>
    <para>
      Download source option · 108
    </para>
    <para>
      drag from prototype · 43
    </para>
    <para>
      draggable checkbox · 122, 132
    </para>
    <para>
      dragging onto the arrowheads · 69
    </para>
    <para>
      drop block · 155
    </para>
    <para>
      duplicate block definition… option · 120
    </para>
    <para>
      duplicate option · 124, 128, 132
    </para>
    <para>
      dynamic array · 49
    </para>
    <para>
      E
    </para>
    <para>
      easing block · 33
    </para>
    <para>
      easing function · 33
    </para>
    <para>
      edge color · 129
    </para>
    <para>
      edit option · 128, 133, 135
    </para>
    <para>
      edit… option · 120
    </para>
    <para>
      editMode (startup option) · 137
    </para>
    <para>
      effect block · 19
    </para>
    <para>
      ellipse tool · 128, 129
    </para>
    <para>
      ellipsis · 63
    </para>
    <para>
      else block · 28
    </para>
    <para>
      else if block · 28
    </para>
    <para>
      empty input slots, filling · 66, 68, 70
    </para>
    <para>
      enter key (keyboard editor) · 131
    </para>
    <para>
      equality of complete structures · 149
    </para>
    <para>
      eraser tool · 128
    </para>
    <para>
      error block · 31
    </para>
    <para>
      error catching library · 31
    </para>
    <para>
      escape key (keyboard editor) · 130
    </para>
    <para>
      Examples button · 108
    </para>
    <para>
      Execute on slider change option · 115
    </para>
    <para>
      export block definition… option · 120
    </para>
    <para>
      Export blocks… option · 110
    </para>
    <para>
      export option · 128, 133
    </para>
    <para>
      Export project… option · 110
    </para>
    <para>
      export… option · 134, 136
    </para>
    <para>
      expression · 11
    </para>
    <para>
      Extension blocks option · 115
    </para>
    <para>
      extract option · 124
    </para>
    <para>
      eyedropper tool · 128, 129
    </para>
    <para>
      F
    </para>
    <para>
      factorial · 44, 71
    </para>
    <para>
      factorial · 32
    </para>
    <para>
      Fade blocks… option · 114
    </para>
    <para>
      fair HSL · 145
    </para>
    <para>
      fair hue · 29, 141, 143, 146
    </para>
    <para>
      fair hue table · 146
    </para>
    <para>
      fair saturation · 146
    </para>
    <para>
      fair value · 146
    </para>
    <para>
      Falkoff, Adin · 148
    </para>
    <para>
      false block · 19
    </para>
    <para>
      file icon menu · 108
    </para>
    <para>
      fill color · 129
    </para>
    <para>
      Finch · 92
    </para>
    <para>
      find blocks… option · 120
    </para>
    <para>
      find first · 50
    </para>
    <para>
      first class data · 148
    </para>
    <para>
      first class data type · 46
    </para>
    <para>
      ﬁrst class procedures · 65
    </para>
    <para>
      ﬁrst class sprites · 73
    </para>
    <para>
      first word block · 27
    </para>
    <para>
      flag, green · 6
    </para>
    <para>
      Flat design option · 116
    </para>
    <para>
      flat line ends option · 117
    </para>
    <para>
      flatten block · 152
    </para>
    <para>
      flatten of block · 57
    </para>
    <para>
      floodfill tool, · 128
    </para>
    <para>
      focus (keyboard editor) · 131
    </para>
    <para>
      footprint button · 117
    </para>
    <para>
      for block · 13, 19, 26, 64, 65
    </para>
    <para>
      for each block · 20
    </para>
    <para>
      for each item block · 25
    </para>
    <para>
      For this sprite only · 15
    </para>
    <para>
      formal parameters · 69
    </para>
    <para>
      frequency distribution analysis library · 34
    </para>
    <para>
      from color block · 29, 140, 142
    </para>
    <para>
      function, associative · 51
    </para>
    <para>
      function, higher order · 49, 148
    </para>
    <para>
      function, mixed · 148, 151
    </para>
    <para>
      function, scalar · 55, 148
    </para>
    <para>
      functional programming style · 48
    </para>
    <para>
      G
    </para>
    <para>
      generic hat block · 6
    </para>
    <para>
      generic when · 6
    </para>
    <para>
      get blocks option · 128
    </para>
    <para>
      getter · 76
    </para>
    <para>
      getter/setter library · 32
    </para>
    <para>
      glide block · 115
    </para>
    <para>
      global variable · 14, 15
    </para>
    <para>
      go to block · 22
    </para>
    <para>
      grade down block · 154
    </para>
    <para>
      grade up block · 154
    </para>
    <para>
      graphics effect · 19
    </para>
    <para>
      gray · 139, 141
    </para>
    <para>
      green flag · 6
    </para>
    <para>
      green flag button · 118
    </para>
    <para>
      green halo · 123
    </para>
    <para>
      Guillén i Pelegay, Joan · 4
    </para>
    <para>
      H
    </para>
    <para>
      halo · 11, 123; red · 69
    </para>
    <para>
      hat block · 6, 41; generic · 6
    </para>
    <para>
      help… option · 119, 123
    </para>
    <para>
      help… option for custom block · 119
    </para>
    <para>
      hexagonal blocks · 41, 60
    </para>
    <para>
      hexagonal shape · 12
    </para>
    <para>
      hide and show primitives · 17
    </para>
    <para>
      hide blocks option · 120
    </para>
    <para>
      Hide blocks… option · 111
    </para>
    <para>
      hide var block · 32
    </para>
    <para>
      hide variable block · 17
    </para>
    <para>
      hideControls (startup option) · 137
    </para>
    <para>
      higher order function · 49, 70, 148, 157
    </para>
    <para>
      higher order procedure · 66
    </para>
    <para>
      histogram · 34
    </para>
    <para>
      Hotchkiss. Kyle · 4
    </para>
    <para>
      HSL · 138, 143
    </para>
    <para>
      HSL color · 29
    </para>
    <para>
      HSL pen color model option · 117
    </para>
    <para>
      HSV · 138, 142
    </para>
    <para>
      HTML (HyperText Markup Language) · 91
    </para>
    <para>
      HTTP · 92
    </para>
    <para>
      HTTPS · 92, 126
    </para>
    <para>
      Hudson, Connor · 4
    </para>
    <para>
      hue · 141
    </para>
    <para>
      Huegle, Jadga · 4
    </para>
    <para>
      Hummingbird · 92
    </para>
    <para>
      hyperblocks · 148
    </para>
    <para>
      Hyperblocks · 55
    </para>
    <para>
      Hz for block · 34
    </para>
    <para>
      I
    </para>
    <para>
      IBM System/360 · 148
    </para>
    <para>
      ice cream · 109
    </para>
    <para>
      icons in title text · 64
    </para>
    <para>
      id block · 71
    </para>
    <para>
      id option · 22
    </para>
    <para>
      identical to · 20
    </para>
    <para>
      identity function · 71
    </para>
    <para>
      if block · 12
    </para>
    <para>
      if do and pause all block · 26
    </para>
    <para>
      if else block · 71
    </para>
    <para>
      if else reporter block · 19
    </para>
    <para>
      ignore block · 26
    </para>
    <para>
      imperative programming style · 48
    </para>
    <para>
      import… option · 134
    </para>
    <para>
      Import… option · 110
    </para>
    <para>
      in front of block · 49
    </para>
    <para>
      in front of stream block · 26
    </para>
    <para>
      index of block (APL) · 152
    </para>
    <para>
      index variable · 19
    </para>
    <para>
      indigo · 141
    </para>
    <para>
      infinite precision integer library · 32
    </para>
    <para>
      Ingalls, Dan · 4
    </para>
    <para>
      inherit block · 77
    </para>
    <para>
      inheritance · 73, 87
    </para>
    <para>
      inner product block · 158
    </para>
    <para>
      input · 6
    </para>
    <para>
      input list · 68, 69
    </para>
    <para>
      input name · 69
    </para>
    <para>
      input name dialog · 42, 59
    </para>
    <para>
      Input sliders option · 115
    </para>
    <para>
      input-type shapes · 59
    </para>
    <para>
      instance · 85
    </para>
    <para>
      integers block · 152
    </para>
    <para>
      interaction · 15
    </para>
    <para>
      internal variable · 63
    </para>
    <para>
      iota block · 152
    </para>
    <para>
      is _ a _ ? block · 19
    </para>
    <para>
      is flag block · 20
    </para>
    <para>
      is identical to · 20
    </para>
    <para>
      item 1 of block · 49
    </para>
    <para>
      item 1 of stream block · 26
    </para>
    <para>
      item block · 148
    </para>
    <para>
      item of block · 56
    </para>
    <para>
      iteration library · 26
    </para>
    <para>
      Iverson, Kenneth E. · 4, 148
    </para>
    <para>
      J
    </para>
    <para>
      jaggies · 79
    </para>
    <para>
      Java programming language · 68
    </para>
    <para>
      JavaScript · 19, 143
    </para>
    <para>
      JavaScript extensions option · 115
    </para>
    <para>
      JavaScript function block · 115
    </para>
    <para>
      jigsaw-piece blocks · 40, 60
    </para>
    <para>
      join block · 102
    </para>
    <para>
      JSON (JavaScript Object Notation) file · 54
    </para>
    <para>
      JSON format · 20
    </para>
    <para>
      json of block · 57
    </para>
    <para>
      jukebox · 9
    </para>
    <para>
      K
    </para>
    <para>
      Kay, Alan · 4
    </para>
    <para>
      key:value: block · 34
    </para>
    <para>
      keyboard editing button · 123
    </para>
    <para>
      keyboard editor · 130
    </para>
    <para>
      keyboard shortcuts · 108
    </para>
    <para>
      key-value pair · 88
    </para>
    <para>
      L
    </para>
    <para>
      L*a*b* · 143
    </para>
    <para>
      L*u*v* · 143
    </para>
    <para>
      label, block · 102
    </para>
    <para>
      lambda · 67
    </para>
    <para>
      lang= (startup option) · 137
    </para>
    <para>
      Language… option · 114
    </para>
    <para>
      large option · 134
    </para>
    <para>
      last blocks · 27
    </para>
    <para>
      layout, window · 5
    </para>
    <para>
      Leap Motion · 92
    </para>
    <para>
      left arrow (keyboard editor) · 131
    </para>
    <para>
      Lego NXT · 92
    </para>
    <para>
      length block · 148
    </para>
    <para>
      length of block · 57
    </para>
    <para>
      length of text block · 22
    </para>
    <para>
      letter (1) of (world) block · 27
    </para>
    <para>
      lexical scope · 85
    </para>
    <para>
      lg option · 22
    </para>
    <para>
      Libraries… option · 25, 111
    </para>
    <para>
      library: block · 45
    </para>
    <para>
      license · 107
    </para>
    <para>
      Lieberman, Henry · 77
    </para>
    <para>
      Lifelong Kindergarten Group · 4
    </para>
    <para>
      lightness · 143
    </para>
    <para>
      lightness option · 117
    </para>
    <para>
      lightning bolt symbol · 25, 123
    </para>
    <para>
      line break in block · 64
    </para>
    <para>
      line drawing tool · 128
    </para>
    <para>
      lines of block · 57
    </para>
    <para>
      linked list · 49
    </para>
    <para>
      Lisp · 58
    </para>
    <para>
      list ➔ sentence block · 27
    </para>
    <para>
      list ➔ word block · 27
    </para>
    <para>
      list block · 46
    </para>
    <para>
      list comprehension library · 35
    </para>
    <para>
      list copy · 50
    </para>
    <para>
      list library · 25
    </para>
    <para>
      list of procedures · 70
    </para>
    <para>
      List type · 60
    </para>
    <para>
      list view · 51
    </para>
    <para>
      list, linked · 49
    </para>
    <para>
      list, multi-dimensional · 55
    </para>
    <para>
      listify block · 34
    </para>
    <para>
      lists of lists · 47
    </para>
    <para>
      little people · 44, 96
    </para>
    <para>
      loading saved projects · 38
    </para>
    <para>
      local state · 73
    </para>
    <para>
      local variables · 19
    </para>
    <para>
      location-pin · 15
    </para>
    <para>
      Login… option · 113
    </para>
    <para>
      Logo tradition · 27
    </para>
    <para>
      Logout option · 113
    </para>
    <para>
      Long form input dialog option · 116
    </para>
    <para>
      long input name dialog · 59
    </para>
    <para>
      M
    </para>
    <para>
      macros · 105
    </para>
    <para>
      magenta · 141, 142
    </para>
    <para>
      Make a block · 40
    </para>
    <para>
      Make a block button · 119
    </para>
    <para>
      make a block… option · 126
    </para>
    <para>
      Make a list · 46
    </para>
    <para>
      Make a variable · 14
    </para>
    <para>
      make internal variable visible · 63
    </para>
    <para>
      Maloney, John · 4
    </para>
    <para>
      map block · 50, 65
    </para>
    <para>
      map library · 35
    </para>
    <para>
      map over stream block · 26
    </para>
    <para>
      map to code block · 117
    </para>
    <para>
      map-pin symbol · 75
    </para>
    <para>
      maroon · 141
    </para>
    <para>
      Massachusetts Institute of Technology · 4
    </para>
    <para>
      mathematicians · 148
    </para>
    <para>
      matrices · 148
    </para>
    <para>
      matrix multiplication · 158
    </para>
    <para>
      max block · 20
    </para>
    <para>
      McCarthy, John · 4
    </para>
    <para>
      media computation · 55, 149
    </para>
    <para>
      Media Lab · 4
    </para>
    <para>
      memory · 16
    </para>
    <para>
      menus library · 36
    </para>
    <para>
      message · 73
    </para>
    <para>
      message passing · 73, 86
    </para>
    <para>
      method · 73, 75, 86
    </para>
    <para>
      methods table · 88
    </para>
    <para>
      microphone · 82
    </para>
    <para>
      microphone block · 82
    </para>
    <para>
      middle option · 127
    </para>
    <para>
      min block · 20
    </para>
    <para>
      mirror sites · 137
    </para>
    <para>
      MIT Artificial Intelligence Lab · 4
    </para>
    <para>
      MIT Media Lab · 4
    </para>
    <para>
      mix block · 140
    </para>
    <para>
      mix colors block · 29
    </para>
    <para>
      mixed function · 148, 151
    </para>
    <para>
      mixing paints · 144
    </para>
    <para>
      Modrow, Eckart · 121
    </para>
    <para>
      monadic negation operator · 22
    </para>
    <para>
      Morphic · 4
    </para>
    <para>
      Motyashov, Ivan · 4
    </para>
    <para>
      mouse position block · 21
    </para>
    <para>
      move option · 133
    </para>
    <para>
      MQTT library · 36
    </para>
    <para>
      multiline block · 33
    </para>
    <para>
      multimap block · 25
    </para>
    <para>
      multiple input · 63
    </para>
    <para>
      multiple-branch conditional library · 28
    </para>
    <para>
      multiplication table · 158
    </para>
    <para>
      multiplication, matrix · 158
    </para>
    <para>
      mutation · 48
    </para>
    <para>
      mutators · 47
    </para>
    <para>
      my block · 73, 76
    </para>
    <para>
      my blocks block · 102
    </para>
    <para>
      my categories block · 102
    </para>
    <para>
      N
    </para>
    <para>
      name (in my block) · 78
    </para>
    <para>
      name box · 122
    </para>
    <para>
      name, input · 69
    </para>
    <para>
      nearest color number · 142
    </para>
    <para>
      neg option · 22
    </para>
    <para>
      negation operator · 22
    </para>
    <para>
      neighbors (in my block) · 78
    </para>
    <para>
      nested calls · 70
    </para>
    <para>
      Nesting Sprites · 10
    </para>
    <para>
      New category… option · 111
    </para>
    <para>
      new costume block · 80
    </para>
    <para>
      new line character · 64
    </para>
    <para>
      New option · 108
    </para>
    <para>
      New scene option · 111
    </para>
    <para>
      new sound block · 84
    </para>
    <para>
      new sprite button · 8
    </para>
    <para>
      newline character · 20
    </para>
    <para>
      Nintendo · 92
    </para>
    <para>
      noExitWarning (startup option) · 137
    </para>
    <para>
      nonlocal exit · 99
    </para>
    <para>
      normal option · 134
    </para>
    <para>
      normal people · 145
    </para>
    <para>
      noRun (startup option) · 137
    </para>
    <para>
      Number type · 60
    </para>
    <para>
      numbers from block · 20
    </para>
    <para>
      O
    </para>
    <para>
      object block · 73
    </para>
    <para>
      Object Logo · 77
    </para>
    <para>
      object oriented programming · 73, 85
    </para>
    <para>
      Object type · 60
    </para>
    <para>
      objects, building explicitly · 85
    </para>
    <para>
      of block (operators) · 22
    </para>
    <para>
      of block (sensing) · 24, 106
    </para>
    <para>
      of costume block · 79
    </para>
    <para>
      open (startup option) · 136
    </para>
    <para>
      Open in Community Site option · 113
    </para>
    <para>
      Open… option · 108
    </para>
    <para>
      operator (APL) · 148, 157
    </para>
    <para>
      orange oval · 13
    </para>
    <para>
      other clones (in my block) · 78
    </para>
    <para>
      other sprites (in my block) · 78
    </para>
    <para>
      outer product block · 158
    </para>
    <para>
      outlined ellipse tool · 128
    </para>
    <para>
      outlined rectangle tool · 128
    </para>
    <para>
      oval blocks · 40, 60
    </para>
    <para>
      P
    </para>
    <para>
      paint brush icon · 126
    </para>
    <para>
      Paint Editor · 126
    </para>
    <para>
      Paint Editor window · 128
    </para>
    <para>
      paintbrush tool · 128
    </para>
    <para>
      paints · 144
    </para>
    <para>
      Paleolithic · 150
    </para>
    <para>
      palette · 6
    </para>
    <para>
      palette area · 119
    </para>
    <para>
      palette background · 120
    </para>
    <para>
      Parallax S2 · 92
    </para>
    <para>
      parallelism · 8, 48
    </para>
    <para>
      parallelization library · 31
    </para>
    <para>
      parent (in my block) · 78
    </para>
    <para>
      parent attribute · 77
    </para>
    <para>
      parent class · 87
    </para>
    <para>
      parent… option · 136
    </para>
    <para>
      <emphasis>Parsons problems</emphasis> · 117
    </para>
    <para>
      parts (in my block) · 78
    </para>
    <para>
      parts (of nested sprite) · 10
    </para>
    <para>
      pause all block · 17, 118
    </para>
    <para>
      pause button · 17, 118
    </para>
    <para>
      pen block · 24, 29, 117, 140
    </para>
    <para>
      pen down? block · 19
    </para>
    <para>
      pen trails block · 18
    </para>
    <para>
      pen trails option · 135
    </para>
    <para>
      pen vectors block · 18
    </para>
    <para>
      permanent clone · 74, 136
    </para>
    <para>
      physical devices · 91
    </para>
    <para>
      pic… option · 135, 136
    </para>
    <para>
      picture of script · 124
    </para>
    <para>
      picture with speech balloon · 124
    </para>
    <para>
      picture, smart · 124
    </para>
    <para>
      pink · 141
    </para>
    <para>
      pivot option · 133
    </para>
    <para>
      pixel · 79
    </para>
    <para>
      pixel, screen · 19
    </para>
    <para>
      pixels library · 27
    </para>
    <para>
      Plain prototype labels option · 116
    </para>
    <para>
      play block · 34
    </para>
    <para>
      play sound block · 9
    </para>
    <para>
      playing sounds · 9
    </para>
    <para>
      plot bar chart block · 28
    </para>
    <para>
      plot sound block · 34
    </para>
    <para>
      point towards block · 22
    </para>
    <para>
      points as inputs · 22
    </para>
    <para>
      polymorphism · 75
    </para>
    <para>
      position block · 21, 33
    </para>
    <para>
      Predicate block · 12
    </para>
    <para>
      preloading a project · 136
    </para>
    <para>
      present (startup option) · 136
    </para>
    <para>
      presentation mode button · 118
    </para>
    <para>
      primitive block within a script · 123
    </para>
    <para>
      printable block · 27, 158
    </para>
    <para>
      procedure · 12, 66
    </para>
    <para>
      Procedure type · 72
    </para>
    <para>
      procedures as data · 9
    </para>
    <para>
      product block · 22, 28
    </para>
    <para>
      project control buttons · 118
    </para>
    <para>
      Project notes option · 108
    </para>
    <para>
      Prolog · 58
    </para>
    <para>
      prototype · 41
    </para>
    <para>
      prototyping · 76, 88
    </para>
    <para>
      pulldown input · 61
    </para>
    <para>
      pumpkin · 139
    </para>
    <para>
      purple · 142
    </para>
    <para>
      R
    </para>
    <para>
      rainbow · 141
    </para>
    <para>
      rank · 148
    </para>
    <para>
      rank of block · 57, 151
    </para>
    <para>
      ravel block · 149
    </para>
    <para>
      raw data… option · 134
    </para>
    <para>
      ray length block · 22
    </para>
    <para>
      read-only pulldown input · 61
    </para>
    <para>
      receivers… option · 125
    </para>
    <para>
      recover button · 39
    </para>
    <para>
      rectangle tool · 128
    </para>
    <para>
      recursion · 43
    </para>
    <para>
      recursive call · 68
    </para>
    <para>
      recursive operator · 71
    </para>
    <para>
      recursive procedure using define · 104
    </para>
    <para>
      red halo · 68, 69, 123
    </para>
    <para>
      redo button · 123
    </para>
    <para>
      redrop option · 125
    </para>
    <para>
      reduce block · 156, 157
    </para>
    <para>
      Reference manual option · 108
    </para>
    <para>
      reflectance graph · 144
    </para>
    <para>
      relabel option · 20
    </para>
    <para>
      relabel… option · 123, 124
    </para>
    <para>
      release option · 136
    </para>
    <para>
      Remove a category… option · 111
    </para>
    <para>
      remove duplicates from block · 25
    </para>
    <para>
      rename option · 128
    </para>
    <para>
      renaming variables · 15
    </para>
    <para>
      <emphasis role="strong">repeat</emphasis> block · 7, 67
    </para>
    <para>
      repeat blocks · 26
    </para>
    <para>
      repeat until block · 12
    </para>
    <para>
      report block · 44
    </para>
    <para>
      Reporter block · 10
    </para>
    <para>
      reporter <emphasis role="strong">if</emphasis> block · 12
    </para>
    <para>
      reporter if else block · 19
    </para>
    <para>
      reporters, recursive · 44
    </para>
    <para>
      Reset Password… option · 113
    </para>
    <para>
      reshape block · 56, 148, 151
    </para>
    <para>
      Restore unsaved project option · 39
    </para>
    <para>
      result pic… option · 124, 125
    </para>
    <para>
      reverse block · 156
    </para>
    <para>
      reverse columns block · 156
    </para>
    <para>
      Reynolds, Ian · 4
    </para>
    <para>
      RGB · 138
    </para>
    <para>
      RGBA option · 19
    </para>
    <para>
      right arrow (keyboard editor) · 131
    </para>
    <para>
      ring, gray · 49, 66, 68
    </para>
    <para>
      ringify · 66
    </para>
    <para>
      ringify option · 124
    </para>
    <para>
      Roberts, Eric · 44
    </para>
    <para>
      robots · 91, 92
    </para>
    <para>
      rods and cones · 141
    </para>
    <para>
      roll block · 150
    </para>
    <para>
      Romagosa, Bernat · 4
    </para>
    <para>
      rotation buttons · 122
    </para>
    <para>
      rotation point tool · 128, 129
    </para>
    <para>
      rotation x (in my block) · 78
    </para>
    <para>
      rotation y (in my block) · 78
    </para>
    <para>
      run (startup option) · 136
    </para>
    <para>
      run block · 65, 68
    </para>
    <para>
      run w/continuation · 99
    </para>
    <para>
      S
    </para>
    <para>
      safely try block · 31
    </para>
    <para>
      sample · 82
    </para>
    <para>
      saturation · 143
    </para>
    <para>
      Save as… option · 110
    </para>
    <para>
      Save option · 110
    </para>
    <para>
      save your project in the cloud · 37
    </para>
    <para>
      scalar = block · 150
    </para>
    <para>
      scalar function · 55, 148, 150
    </para>
    <para>
      scalar join block · 150
    </para>
    <para>
      scenes · 111, 136
    </para>
    <para>
      Scenes… option · 111
    </para>
    <para>
      Scheme · 4
    </para>
    <para>
      Scheme number block · 32
    </para>
    <para>
      SciSnap<emphasis>!</emphasis> · 121
    </para>
    <para>
      SciSnap<emphasis>!</emphasis> library · 36
    </para>
    <para>
      scope: lexical · 85
    </para>
    <para>
      Scratch · 5, 9, 40, 46, 47, 48, 59
    </para>
    <para>
      Scratch Team · 4
    </para>
    <para>
      screen pixel · 19
    </para>
    <para>
      script · 5
    </para>
    <para>
      script pic · 43
    </para>
    <para>
      script pic… option · 124
    </para>
    <para>
      <emphasis role="strong">script variables</emphasis> block · 15,
      19, 86
    </para>
    <para>
      scripting area · 6, 122
    </para>
    <para>
      scripting area background context menu · 125
    </para>
    <para>
      scripts pic… option · 126
    </para>
    <para>
      search bar · 109
    </para>
    <para>
      search button · 119
    </para>
    <para>
      secrets · 107
    </para>
    <para>
      select block · 156
    </para>
    <para>
      selectors · 47
    </para>
    <para>
      self (in my block) · 78
    </para>
    <para>
      senders… option · 125
    </para>
    <para>
      sensors · 91
    </para>
    <para>
      sentence ➔ list block · 27
    </para>
    <para>
      sentence block · 25
    </para>
    <para>
      sentence library · 27
    </para>
    <para>
      sentence➔list block · 25
    </para>
    <para>
      separator: menu · 62
    </para>
    <para>
      sepia · 139
    </para>
    <para>
      serial-ports library · 33
    </para>
    <para>
      Servilla, Deborah · 4
    </para>
    <para>
      set _ of block _ to _ block · 102
    </para>
    <para>
      set background block · 22
    </para>
    <para>
      <emphasis role="strong">set</emphasis> block · 15
    </para>
    <para>
      set flag block · 20, 32
    </para>
    <para>
      set pen block · 24, 29, 117, 139, 140
    </para>
    <para>
      set pen to crayon block · 30, 139
    </para>
    <para>
      set value block · 32
    </para>
    <para>
      set var block · 32
    </para>
    <para>
      setter · 76
    </para>
    <para>
      setting block · 32
    </para>
    <para>
      settings icon · 114
    </para>
    <para>
      shade · 141
    </para>
    <para>
      shallow copy of a list · 50
    </para>
    <para>
      shape of block · 151
    </para>
    <para>
      shapes of blocks · 40
    </para>
    <para>
      shift-arrow keys (keyboard editor) · 131
    </para>
    <para>
      Shift-click (keyboard editor) · 130
    </para>
    <para>
      shift-click on block · 124
    </para>
    <para>
      shift-clicking · 107
    </para>
    <para>
      shift-enter (keyboard editor) · 130
    </para>
    <para>
      Shift-tab (keyboard editor) · 130
    </para>
    <para>
      shortcut · 126, 135
    </para>
    <para>
      shortcuts: keyboard · 108
    </para>
    <para>
      show all option · 135
    </para>
    <para>
      Show buttons option · 117
    </para>
    <para>
      Show categories option · 117
    </para>
    <para>
      show option · 136
    </para>
    <para>
      show primitives option · 121
    </para>
    <para>
      show stream block · 26
    </para>
    <para>
      show var block · 32
    </para>
    <para>
      show variable block · 17
    </para>
    <para>
      shown? block · 19
    </para>
    <para>
      shrink/grow button · 118
    </para>
    <para>
      sieve block · 26
    </para>
    <para>
      sign option · 22
    </para>
    <para>
      Signada library · 36
    </para>
    <para>
      signum block · 150
    </para>
    <para>
      Signup… option · 113
    </para>
    <para>
      simulation · 73
    </para>
    <para>
      sine wave · 83
    </para>
    <para>
      Single palette option · 117
    </para>
    <para>
      single stepping · 18
    </para>
    <para>
      slider: stepping speed · 18
    </para>
    <para>
      slider max… option · 134
    </para>
    <para>
      slider min… option · 134
    </para>
    <para>
      slider option · 134
    </para>
    <para>
      Smalltalk · 58
    </para>
    <para>
      smart picture · 124
    </para>
    <para>
      snap block · 27
    </para>
    <para>
      snap option · 22
    </para>
    <para>
      Snap<emphasis>!</emphasis> logo menu · 107
    </para>
    <para>
      Snap<emphasis>!</emphasis> manual · 124
    </para>
    <para>
      Snap<emphasis>!</emphasis> program · 5
    </para>
    <para>
      Snap! website option · 108
    </para>
    <para>
      snap.berkeley.edu · 108
    </para>
    <para>
      solid ellipse tool · 128
    </para>
    <para>
      solid rectangle tool · 128
    </para>
    <para>
      sophistication · 72
    </para>
    <para>
      sort block · 25
    </para>
    <para>
      sound · 82
    </para>
    <para>
      sound manipulation library · 34
    </para>
    <para>
      sounds (in my block) · 78
    </para>
    <para>
      sounds, first class · 79
    </para>
    <para>
      Sounds… option · 113
    </para>
    <para>
      source files for Snap<emphasis>!</emphasis> · 108
    </para>
    <para>
      space key (keyboard editor) · 131
    </para>
    <para>
      speak block · 31
    </para>
    <para>
      special form · 72
    </para>
    <para>
      spectral colors · 141
    </para>
    <para>
      speech balloon · 124
    </para>
    <para>
      speech synthesis library · 31
    </para>
    <para>
      split block · 20, 91
    </para>
    <para>
      split by blocks block · 101
    </para>
    <para>
      split by line block · 57
    </para>
    <para>
      spreadsheet · 149
    </para>
    <para>
      sprite · 6, 73
    </para>
    <para>
      sprite appearance and behavior controls · 122
    </para>
    <para>
      sprite corral · 8, 135
    </para>
    <para>
      sprite creation buttons · 135
    </para>
    <para>
      sprite nesting · 10
    </para>
    <para>
      sprite-local block · 75
    </para>
    <para>
      sprite-local variable · 14, 15
    </para>
    <para>
      square stop sign · 6
    </para>
    <para>
      squiral · 13
    </para>
    <para>
      stack of blocks · 6
    </para>
    <para>
      stage · 6, 73
    </para>
    <para>
      stage (in my block) · 78
    </para>
    <para>
      stage blocks · 19
    </para>
    <para>
      Stage resizing buttons · 118
    </para>
    <para>
      Stage size… option · 114
    </para>
    <para>
      Stanford Artificial Intelligence Lab · 4
    </para>
    <para>
      starting Snap<emphasis>!</emphasis> · 136
    </para>
    <para>
      Steele, Guy · 4
    </para>
    <para>
      stop all block · 118
    </para>
    <para>
      stop block · 22
    </para>
    <para>
      stop block block · 44
    </para>
    <para>
      stop button · 118
    </para>
    <para>
      stop script block · 44
    </para>
    <para>
      stop sign · 8
    </para>
    <para>
      stop sign, square · 6
    </para>
    <para>
      Stream block · 26
    </para>
    <para>
      stream library · 26
    </para>
    <para>
      Stream with numbers from block · 26
    </para>
    <para>
      stretch block · 80
    </para>
    <para>
      string processing library · 33
    </para>
    <para>
      <emphasis>Structure and Interpretation of Computer
      Programs</emphasis> · 4
    </para>
    <para>
      submenu · 62
    </para>
    <para>
      substring block · 33
    </para>
    <para>
      subtractive mixing · 144
    </para>
    <para>
      sum block · 22, 28
    </para>
    <para>
      Super-Awesome Sylvia · 92
    </para>
    <para>
      Sussman, Gerald J. · 4
    </para>
    <para>
      Sussman, Julie · 4
    </para>
    <para>
      svg… option · 135
    </para>
    <para>
      switch in C · 28
    </para>
    <para>
      symbols in title text · 64
    </para>
    <para>
      synchronous rotation · 10
    </para>
    <para>
      system getter/setter library · 32
    </para>
    <para>
      T
    </para>
    <para>
      tab character · 20
    </para>
    <para>
      tab key (keyboard editor) · 130
    </para>
    <para>
      table · 158
    </para>
    <para>
      table view · 51
    </para>
    <para>
      take block · 155
    </para>
    <para>
      teal · 142
    </para>
    <para>
      temporary clone · 74, 133
    </para>
    <para>
      Terms of Service · 38
    </para>
    <para>
      termwise extension · 148
    </para>
    <para>
      text costume library · 31
    </para>
    <para>
      text input · 9
    </para>
    <para>
      Text type · 60
    </para>
    <para>
      text-based language · 117
    </para>
    <para>
      text-to-speech library · 31
    </para>
    <para>
      <emphasis>Thinking Recursively</emphasis> · 44
    </para>
    <para>
      thread · 100
    </para>
    <para>
      thread block · 100
    </para>
    <para>
      Thread safe scripts option · 116
    </para>
    <para>
      throw block · 26
    </para>
    <para>
      thumbnail · 122
    </para>
    <para>
      time · 92
    </para>
    <para>
      tint · 141
    </para>
    <para>
      tip option · 127
    </para>
    <para>
      title text · 42
    </para>
    <para>
      to block · 22
    </para>
    <para>
      tool bar · 6
    </para>
    <para>
      tool bar features · 107
    </para>
    <para>
      touching block · 22
    </para>
    <para>
      transient variable · 16
    </para>
    <para>
      translation · 114
    </para>
    <para>
      translations option · 43
    </para>
    <para>
      transparency · 30, 79, 140
    </para>
    <para>
      transparent paint · 129
    </para>
    <para>
      transpose block · 156
    </para>
    <para>
      true block · 19
    </para>
    <para>
      TuneScope library · 36
    </para>
    <para>
      Turbo mode option · 115
    </para>
    <para>
      turtle costume · 126
    </para>
    <para>
      Turtle costume · 9
    </para>
    <para>
      turtle’s rotation point · 127
    </para>
    <para>
      two-item (x,y) lists · 22
    </para>
    <para>
      type · 19
    </para>
    <para>
      U
    </para>
    <para>
      Undefined! blocks · 120
    </para>
    <para>
      Undelete sprites… option · 113
    </para>
    <para>
      undo button · 123, 129
    </para>
    <para>
      undrop option · 125
    </para>
    <para>
      unevaluated procedure types · 61
    </para>
    <para>
      unevaluated type · 72
    </para>
    <para>
      Unicode · 149
    </para>
    <para>
      Uniform Resource Locator · 91
    </para>
    <para>
      unringify · 66, 86
    </para>
    <para>
      unringify option · 124
    </para>
    <para>
      Unused blocks… option · 111
    </para>
    <para>
      up arrow (keyboard editor) · 131
    </para>
    <para>
      upvar · 64
    </para>
    <para>
      upward-pointing arrow · 63
    </para>
    <para>
      url block · 34, 91
    </para>
    <para>
      USE BIGNUMS block · 32
    </para>
    <para>
      use case-independent comparisons block · 33
    </para>
    <para>
      user interface elements · 107
    </para>
    <para>
      user name · 37
    </para>
    <para>
      V
    </para>
    <para>
      value · 143
    </para>
    <para>
      value at key block · 34
    </para>
    <para>
      var block · 32
    </para>
    <para>
      variable · 13, 76; block · 43; global · 14; renaming · 15;
      script-local · 15; sprite-local · 14, 15; transient · 16
    </para>
    <para>
      variable watcher · 14
    </para>
    <para>
      variable-input slot · 68
    </para>
    <para>
      variables in ring slots · 66
    </para>
    <para>
      variables library · 32
    </para>
    <para>
      variables, local · 19
    </para>
    <para>
      variadic · 22
    </para>
    <para>
      variadic input · 46, 63
    </para>
    <para>
      variadic library · 28
    </para>
    <para>
      vector · 112
    </para>
    <para>
      vector editor · 129
    </para>
    <para>
      vectors · 148
    </para>
    <para>
      video block · 22
    </para>
    <para>
      video on block · 80
    </para>
    <para>
      violet · 142
    </para>
    <para>
      visible stepping · 45, 117
    </para>
    <para>
      visible stepping button · 18
    </para>
    <para>
      visible stepping option · 115
    </para>
    <para>
      visual representation of a sentence · 27
    </para>
    <para>
      W
    </para>
    <para>
      wardrobe · 9
    </para>
    <para>
      warp block · 19, 123
    </para>
    <para>
      watcher · 15
    </para>
    <para>
      Water Color Bot · 92
    </para>
    <para>
      web services library · 34
    </para>
    <para>
      when I am block · 23
    </para>
    <para>
      when I am stopped script · 23
    </para>
    <para>
      when I receive block · 23
    </para>
    <para>
      when, generic · 6
    </para>
    <para>
      white · 142
    </para>
    <para>
      white background · 141
    </para>
    <para>
      whitespace · 20
    </para>
    <para>
      Wiimote · 92
    </para>
    <para>
      window layout · 5
    </para>
    <para>
      with inputs · 66
    </para>
    <para>
      word ➔ list block · 27
    </para>
    <para>
      word and sentence library · 27
    </para>
    <para>
      world map library · 35
    </para>
    <para>
      World Wide Web · 91
    </para>
    <para>
      write block · 18
    </para>
    <para>
      writeable pulldown inputs · 61
    </para>
    <para>
      X
    </para>
    <para>
      X position · 11
    </para>
    <para>
      X11/W3C color names · 29
    </para>
    <para>
      Xerox PARC · 4
    </para>
    <para>
      Y
    </para>
    <para>
      Y position · 11
    </para>
    <para>
      yield block · 100
    </para>
    <para>
      Yuan, Yuan · 4
    </para>
    <para>
      Z
    </para>
    <para>
      zebra coloring · 11
    </para>
    <para>
      Zoom blocks... option · 114
    </para>
  </section>
</section>
