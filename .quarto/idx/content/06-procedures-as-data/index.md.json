{"title":"Procedures as Data","markdown":{"headingText":"Procedures as Data","containsRefs":false,"markdown":"\n## Call and Run\n\n![image692.png](assets/image692.png) <!--  style=\"width:3.67292in;height:1.58333in\" / --> In the for block \\index{for\nblock} example above, the input named action has been declared as type\n“Command (C-shaped)”; that’s why the finished block is C-shaped. But how\ndoes the block actually tell Snap*!* to carry out the commands inside\nthe C-slot? Here is a simple version of the block script:\n\nThis is simplified because it assumes, without checking, that the ending\nvalue is greater than the starting value; if not, the block should\n(depending on the designer’s purposes) either not run at all, or change\nthe variable by −1 for each repetition instead of by 1.\n\n![image693.png](assets/image693.png) <!--  style=\"width:0.5in;height:0.15625in\" / --> The\nimportant part of this script is the run block \\index{run block} near\nthe end. This is a Snap*!* built-in command block that takes a\nCommand-type value (a script) as its input, and carries out its\ninstructions. (In this example, the value of the input is the script\nthat the user puts in the C-slot of the my for block.) There is a\nsimilar call reporter block for invoking a Reporter or Predicate block.\nThe call \\index{call block } and run blocks are at the heart of\nSnap*!*’s ﬁrst class procedure \\index{ﬁrst class procedures} feature;\nthey allow scripts and blocks to be used as data—in this example, as an\ninput to a block—and eventually carried out under control of the user’s\nprogram.\n\nHere’s another example, this time using a Reporter-type input in a map\nblock (see page [50](#map)): \\index{map block}\n\nHere we are calling the Reporter “multiply by 10” three times, once with\neach item of the given list as its input, and collecting the results as\na list. (The reported list will always be the same length as the input\nlist.) Note that the multiplication block has two inputs, but here we\nhave specified a particular value for one of them (10), so the call\nblock knows to use the input value given to it just to fill the other\n(empty) input slot in the multiplication block. In the my map\ndefinition, the input function is declared to be type Reporter, and data\nis of type List.\n\n### Call/Run with inputs\n\n![image698.png](assets/image698.png) <!--  style=\"width:1.8125in;height:0.20833in\" / --> The\ncall block (like the run block) has a right arrowhead at the end;\nclicking on it adds the phrase “with inputs” and then a slot into which\nan input can be inserted:\n\nIf the left arrowhead is used to remove the last input slot, the “with\ninputs \\index{with inputs} ” disappears also. The right arrowhead can be\nclicked as many times as needed for the number of inputs required by the\nreporter block being called.\n\n![image699.png](assets/image699.png) <!--  style=\"width:2.72917in;height:0.31806in\" / --> If the number of inputs given\nto call (not counting the Reporter-type input that comes first) is the\nsame as the number of empty input slots \\index{empty input slots,\nfilling} , then the empty slots are filled from left to right with the\ngiven input values. If call is given exactly one input, then *every*\nempty input slot of the called block is filled with the same value:\n\nIf the number of inputs provided is neither one nor the number of empty\nslots, then there is no automatic filling of empty slots. (Instead you\nmust use explicit parameters in the ring, as discussed in Section C\nbelow.)\n\nAn even more important thing to notice about these examples is the\n*ring* \\index{ring, gray} around the Reporter-type input slots in call\nand map above. This notation indicates that *the block itself,* not the\nnumber or other value that the block would report when called, is the\ninput. If you want to use a block itself in a non-Reporter-type (e.g.,\nAny-type) input slot, you can enclose it explicitly in a ring, found at\nthe top of the Operators palette.\n\nAs a shortcut, if you right-click or control-click on a block (such as\nthe + block in this example), one of the choices in the menu that\nappears is “ringify \\index{ringify} ” and/or “unringify\n\\index{unringify}.” The ring indicating a Reporter-type or\nPredicate-type input slot is essentially the same idea for reporters as\nthe C-shaped input slot with which you’re already familiar; with a\nC-shaped slot, it’s *the script* you put in the slot that becomes the\ninput to the C-shaped block.\n\nThere are three ring shapes. All are oval on the outside, indicating\nthat the ring reports a value, the block or script inside it, but the\ninside shapes are command, reporter, or predicate, indicating what kind\nof block or script is expected. Sometimes you want to put something more\ncomplicated than a single reporter inside a reporter ring; if so, you\ncan use a script, but the script must report a value, as in a custom\nreporter definition.\n\n### Variables in Ring Slots\n\nNote that the run block \\index{variables in ring slots} in the\ndefinition of the my for block (page [65](#call-and-run)) doesn’t have a\nring around its input variable action. When you drag a variable into a\nringed input slot, you generally *do* want to use *the value of* the\nvariable, which will be the block or script you’re trying to run or\ncall, rather than the orange variable reporter itself. So Snap*!*\nautomatically removes the ring in this case. If you ever do want to use\nthe variable *block itself,* rather than the value of the variable, as a\nProcedure-type input, you can drag the variable into the input slot,\nthen control-click or right-click it and choose “ringify” from the menu\nthat appears. (Similarly, if you ever want to call a function that will\nreport a block to use as the input, such as item 1 of applied to a list\n*of blocks,* you can choose “unringify” from the menu. Almost all the\ntime, though, Snap*!* does what you mean without help.)\n\n## Writing Higher Order Procedures\n\nA *higher order procedure* \\index{higher order procedure} is one that\ntakes another procedure as an input, or that reports a procedure. In\nthis document, the word “procedure \\index{procedure} ” encompasses\nscripts, individual blocks, and nested reporters. (Unless specified\notherwise, “reporter” includes predicates. When the word is capitalized\ninside a sentence, it means specifically oval-shaped blocks. So, “nested\nreporters” includes predicates, but “a Reporter-type input” doesn’t.)\n\nAlthough an Any-type input slot (what you get if you use the small\ninput-name dialog box) will accept a procedure input, it doesn’t\nautomatically ring the input as described above. So the declaration of\nProcedure-type inputs makes the use of your custom higher order block\nmuch more convenient.\n\n![image708.png](assets/image708.png) <!--  style=\"width:2.375in;height:1.35417in\" / --> Why\nwould you want a block to take a procedure as input? This is actually\nnot an obscure thing to do; the primitive conditional and looping blocks\n(the C-shaped ones in the Control palette) take a script as input. Users\njust don’t usually think about it in those terms! We could write the\nrepeat block \\index{repeat block} as a custom block this way, if Snap*!*\ndidn’t already have one:\n\nThe lambda (λ) next to action in the prototype indicates that this is a\nC-shaped block \\index{C-shaped block}, and that the script enclosed by\nthe C when the block is used is the input named action in the body of\nthe script. The only way to make sense of the variable action is to\nunderstand that its value is a script.\n\n![image509.png](assets/image509.png) <!--  style=\"width:2.58333in;height:1.60417in\" / --> To declare an input to be\nProcedure-type, open the input name dialog as usual, and click on the\narrowhead:\n\nThen, in the long dialog, choose the appropriate Procedure type. The\nthird row of input types has a ring in the shape of each block type\n(jigsaw for Commands, oval for Reporters, and hexagonal for Predicates).\nIn practice, though, in the case of Commands it’s more common to choose\nthe C-shaped slot on the fourth row, because this “container” for\ncommand scripts is familiar to Scratch users. Technically the C-shaped\nslot is an *unevaluated* procedure type, something discussed in Section\nE below. The two Command-related input types (inline and C-shaped) are\nconnected by the fact that if a variable, an item (#) of \\[list\\] block,\nor a custom Reporter block is dropped onto a C-shaped slot of a custom\nblock, it turns into an inline slot, as in the repeater block’s\nrecursive call above. (Other built-in Reporters can’t report scripts, so\nthey aren’t accepted in a C-shaped slot.)\n\n![image658.png](assets/image658.png) <!--  style=\"width:0.19792in;height:0.19792in\" alt=\"Macintosh HD:Users:bh:Desktop:gear-part.png\" / --> ![image709.png](assets/image709.png) <!--  style=\"width:3.65278in;height:2.75455in\" / -->   \nWhy would you ever choose an inline Command slot rather than a C shape?\nOther than the run block ![image710.png](assets/image710.png) <!--  style=\"width:2.11458in;height:0.46875in\" / --> discussed below, the only\ncase I can think of is something like the C \\index{C programming\nlanguage} /C++/Java \\index{Java programming language} for loop, which\nactually has *three* command script inputs (and one predicate input),\nonly one of which is the “featured” loop body:\n\nOkay, now that we have procedures as inputs to our blocks, how do we use\nthem? We use the blocks run \\index{run block} (for commands) and call\n\\index{call block } (for reporters). The run block’s script input is an\ninline ring, not C-shaped, because we anticipate that it will be rare to\nuse a specific, literal script as the input. Instead, the input will\ngenerally be a variable whose *value* is a script.\n\nThe run and call blocks have arrowheads at the end that can be used to\nopen slots for inputs to the called procedures. How does Snap*!* know\nwhere to use those inputs? If the called procedure (block or script) has\nempty input slots, Snap*!* “does the right thing.” This has several\npossible meanings:\n\n![image711.png](assets/image711.png) <!--  style=\"width:3.44792in;height:0.34406in\" / --> 1. If the number of empty\nslots \\index{empty input slots, filling} is exactly equal to the number\nof inputs provided, then Snap*!* fills the empty slots from left to\nright:\n\n2\\. If exactly one input is provided, Snap*!* will fill any number of\nempty slots with it:\n\n![image712.png](assets/image712.png) <!--  style=\"width:2.80208in;height:0.30694in\" / --> \n\n3\\. Otherwise, Snap*!* won’t fill any slots, because the user’s\nintention is unclear.\n\nIf the user wants to override these rules, the solution is to use a ring\n\\index{ring, gray} with explicit input names that can be put into the\ngiven block or script to indicate how inputs are to be used. This will\nbe discussed more fully below.\n\n### Recursive Calls to Multiple-Input Blocks\n\nA relatively rare situation not yet considered here is the case of a\nrecursive block that has a variable number of inputs. Let’s say the user\nof your project calls your block with five inputs one time, and 87\ninputs another time. How do you write the recursive call\n\\index{recursive call} to your block when you don’t know how many inputs\nto give it? The answer is that you collect the inputs in a list\n\\index{input list} (recall that, when you declare an input name to\nrepresent a variable number of inputs, your block sees those inputs as a\nlist of values in the first place), and then, in the recursive call, you\ndrop that input list *onto the arrowheads* that indicate a\nvariable-input slot \\index{variable-input slot}, rather than onto the\ninput slot:\n\n![image658.png](assets/image658.png) <!--  style=\"width:0.13194in;height:0.13194in\" alt=\"Macintosh HD:Users:bh:Desktop:gear-part.png\" / --> ![image713.png](assets/image713.png) <!--  style=\"width:2.50139in;height:1.94444in\" / --> ![image714.png](assets/image714.png) <!--  style=\"width:2.225in;height:1.17083in\" / --> ![image715.png](assets/image715.png) <!--  style=\"width:2.27569in;height:1.59722in\" / -->   \nNote that the halo \\index{halo:red} you see while dragging onto the\narrowheads \\index{arrowheads} is red \\index{red halo} instead of white,\nand covers the input slot as well as the arrowheads. And when you drop\nthe expression onto the arrowheads, the words “input list \\index{input\nlist} :” are added to the block text and the arrowheads disappear (in\nthis invocation only) to remind you that the list represents all of the\nmultiple inputs, not just a single input. The items in the list are\ntaken *individually* as inputs to the script. Since numbers is a list of\nnumbers, each individual item is a number, just what sizes wants. This\nblock will take any number of numbers as inputs, and will make the\nsprite grow and shrink accordingly:\n\n![image722.png](assets/image722.png) <!--  style=\"width:2.95833in;height:0.6875in\" / --> The\nuser of this block calls it with any number of *individual numbers* as\ninputs. But inside the definition of the block, all of those numbers\nform *a* *list* that has a single input name, numbers. This recursive\ndefinition ﬁrst checks to make sure there are any inputs at all. If so,\nit processes the ﬁrst input (item 1 of the list), then it wants to make\na recursive call with all but the ﬁrst number. But sizes doesn’t take a\nlist as input; it takes numbers as inputs! So this would be wrong:\n\n## Formal Parameters\n\nThe rings around Procedure-type inputs \\index{input name} have an\narrowhead at the right. Clicking the arrowhead allows you to give the\ninputs to a block or script explicit names \\index{name, input}, instead\nof using empty input slots as we’ve done until now.\n\nThe names \\#1 \\index{#1}, \\#2, etc. are provided by default, but you\ncan change a name by clicking on its orange oval in the input names\nlist. Be careful not to *drag* the oval when clicking; that’s how you\nuse the input inside the ring. The names of the input variables are\ncalled the *formal parameters* \\index{formal parameters} of the\nencapsulated procedure.\n\n![image731.png](assets/image731.png) <!--  style=\"width:4.32292in;height:0.45417in\" / --> Here’s a simple but contrived\nexample using explicit names to control which input goes where inside\nthe ring:\n\nHere we just want to put one of the inputs into two different slots. If\nwe left all three slots empty, Snap*!* would not fill any of them,\nbecause the number of inputs provided (2) would not match the number of\nempty slots (3).\n\n![image732.png](assets/image732.png) <!--  style=\"width:4.67986in;height:3.01806in\" / --> Here is a more realistic,\nmuch more advanced example \\index{crossproduct} :\n\n![image733.png](assets/image733.png) <!--  style=\"width:4.34722in;height:1.40278in\" / --> \n\nThis is the definition of a block that takes any number of lists, and\nreports the list of all possible combinations of one item from each\nlist. The important part for this discussion is that near the bottom\nthere are two *nested* calls \\index{nested calls} to map, the higher\norder function \\index{higher order function} that applies an input\nfunction to each item of an input list. In the inner block, the function\nbeing mapped is in front of, and that block takes two inputs. The\nsecond, the empty List-type slot, will get its value in each call from\nan item of the inner map’s list input. But there is no way for the outer\nmap to communicate values to empty slots of the in front of block. We\nmust give an explicit name, newitem, to the value that the outer map is\ngiving to the inner one, then drag that variable into the in front of\nblock.\n\nBy the way, once the called block provides names for its inputs, Snap*!*\nwill not automatically fill empty slots \\index{empty input slots,\nfilling} , on the theory that the user has taken control. In fact,\nthat’s another reason you might want to name the inputs explicitly: to\nstop Snap*!* from filling a slot that should really remain empty.\n\n## Procedures as Data\n\n![image734.png](assets/image734.png) <!--  style=\"width:5.1875in;height:1.65625in\" / --> Here’s\nan example of a situation in which a procedure must be explicitly marked\nas data by pulling a ring from the Operators palette and putting the\nprocedure (block or script) inside it:\n\nHere, we are making a list of procedures \\index{list of procedures}.\nBut the list block accepts inputs of any type, so its input slots are\nnot ringed. We must say explicitly that we want the block *itself* as\nthe input, rather than whatever value would result from evaluating the\nblock.\n\n![image735.png](assets/image735.png) <!--  style=\"width:3.83333in;height:0.84375in\" / --> Besides the list block in the\nexample above, other blocks into which you may want to put procedures\nare set (to set the value of a variable to a procedure), say and think\n(to display a procedure to the user), and report (for a reporter that\nreports a procedure):\n\n## Special Forms\n\n![image736.png](assets/image736.png) <!--  style=\"width:2.49931in;height:0.27847in\" / --> ![image737.png](assets/image737.png) <!--  style=\"width:2.40208in;height:1.42708in\" / --> The primitive if else\n\\index{if else block } block has two C-shaped command slots and chooses\none or the other depending on a Boolean test. Because Scratch doesn’t\nemphasize functional programming, it lacks a corresponding reporter\nblock to choose between two expressions. Snap*!* has one, but we could\nwrite our own:\n\n![image738.png](assets/image738.png) <!--  style=\"width:4.29167in;height:0.84861in\" / --> ![image739.png](assets/image739.png) <!--  style=\"width:3.81899in;height:0.27433in\" / --> Our block works for these\nsimple examples, but if we try to use it in writing a recursive operator\n\\index{recursive operator}, it’ll fail:\n\nThe problem is that when any block is called, all of its inputs are\ncomputed (evaluated) before the block itself runs. The block itself\nknows only the values of its inputs, not what expressions were used to\ncompute them. In particular, all of the inputs to our if then else block\nare evaluated ﬁrst thing. That means that even in the base case,\nfactorial \\index{factorial} will try to call itself recursively, causing\nan infinite loop. We need our if then else block to be able to select\nonly one of the two alternatives to be evaluated.\n\nWe have a mechanism to allow that: declare the then and else inputs to\nbe of type Reporter rather than type Any. Then, when calling the block,\nthose inputs will be enclosed in a ring so that the expressions\nthemselves, rather than their values, become the inputs:\n\n![image740.png](assets/image740.png) <!--  style=\"width:1.11458in;height:0.69792in\" / --> ![image741.png](assets/image741.png) <!--  style=\"width:4.52083in;height:1.02292in\" / --> ![image742.png](assets/image742.png) <!--  style=\"width:2.61736in;height:1.51042in\" / --> \n\nIn this version, the program works, with no infinite loop. But we’ve\npaid a heavy price: this reporter-if is no longer as intuitively obvious\nas the Scratch command-if. You have to know about procedures as data,\nabout rings, and about a trick to get a constant value in a ringed slot\n\\index{constant functions}. (The id block \\index{id block} implements\nthe identity function \\index{identity function}, which reports its\ninput.[6] We need it because rings take only reporters as input, not\nnumbers.) What we’d like is a reporter-if that *behaves* like this one,\ndelaying the evaluation of its inputs, but *looks* like our ﬁrst\nversion, which was easy to use except that it didn’t work.\n\nSuch blocks are indeed possible. A block that seems to take a simple\nexpression as input, but delays the evaluation of that input by wrapping\nan “invisible ring” around it (and, if necessary, an id-like\ntransformation of constant data into constant functions) is called a\n*special form* \\index{special form}. To turn our if block into a\nspecial form, we edit the block’s prototype, declaring the inputs yes\nand no to be of type “Any (unevaluated) \\index{Any (unevaluated) type} ”\ninstead of type Reporter. The script for the block is still that of the\nsecond version, including the use of call to evaluate either yes or no\nbut not both. But the slots appear as white Any-type rectangles, not\nReporter-type rings, and the factorial block will look like our ﬁrst\nattempt.\n\nIn a special form’s prototype, the unevaluated \\index{unevaluated type}\ninput slot(s) are indicated by a lambda (λ) next to the input name, just\nas if they were declared as Procedure type \\index{Procedure type}. They\n*are* Procedure type, really; they’re just disguised to the user of the\nblock.\n\nSpecial forms trade off implementor sophistication\n\\index{sophistication} for user sophistication. That is, you have to\nunderstand all about procedures as data to make sense of the special\nform implementation of my if then else. But any experienced Scratch\nprogrammer can *use* my if then else without thinking at all about how\nit works internally.\n\n### Special Forms in Scratch\n\nSpecial forms are actually not a new invention in Snap*!*. Many of\nScratch’s conditional and looping blocks are really special forms. The\nhexagonal input slot in the if block is a straightforward Boolean value,\nbecause the value can be computed once, before the if block makes its\ndecision about whether or not to run its action input. But the forever\nif, repeat until, and wait until blocks’ inputs can’t be Booleans; they\nhave to be of type “Boolean (unevaluated) \\index{Boolean (unevaluated)\ntype} ,” so that Scratch can evaluate them over and over again. Since\nScratch doesn’t have custom C‑shaped blocks, it can afford to handwave\naway the distinction between evaluated and unevaluated Booleans, but\nSnap*!* can’t. The pedagogic value of special forms is proven by the\nfact that no Scratcher ever notices that there’s anything strange about\nthe way in which the hexagonal inputs in the Control blocks are\nevaluated.\n\nAlso, the C-shaped slot \\index{C-shaped slot} familiar to Scratch users\nis an unevaluated procedure type; you don’t have to use a ring to keep\nthe commands in the C-slot from being run before the C-shaped block is\nrun. Those commands themselves, not the result of running them, are the\ninput to the C-shaped Control block. (This is taken for granted by\nScratch users, especially because Scratchers don’t think of the contents\nof a C-slot as an input at all.) This is why it makes sense that\n“C‑shaped” is on the fourth row of types in the long form input dialog,\nwith other unevaluated types.\n\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"brand":{"brand":{"color":{"palette":{"dark-grey":"#222222","blue":"#003262"},"primary":"black"},"logo":{"medium":"images/snap-logo.png"},"typography":{"fonts":[{"family":"Open Sans","source":"google"}],"base":"Open Sans","headings":"Freight Text Pro"}},"data":{"color":{"palette":{"dark-grey":"#222222","blue":"#003262"},"primary":"black"},"logo":{"medium":"images/snap-logo.png"},"typography":{"fonts":[{"family":"Open Sans","source":"google"}],"base":"Open Sans","headings":"Freight Text Pro"}},"brandDir":"C:\\Users\\victo\\snap-manual-new","projectDir":"C:\\Users\\victo\\snap-manual-new","processedData":{"color":{"dark-grey":"#222222","blue":"#003262","primary":"black"},"typography":{"base":"Open Sans","headings":"Freight Text Pro"},"logo":{"images":{},"medium":{"light":{"path":"images/snap-logo.png"},"dark":{"path":"images/snap-logo.png"}}}}}},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","filters":["../../scripts/collect-index.lua"],"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.42","bibliography":["../../references.bib"],"number-depth":1,"theme":["none","../../styles/snap-manual.scss"],"strip-comment":true,"navbar":{"logo":"../../images/snap-logo.png"}},"extensions":{"book":{"multiFile":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":true,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"brand":{"brand":{"color":{"palette":{"dark-grey":"#222222","blue":"#003262"},"primary":"black"},"logo":{"medium":"images/snap-logo.png"},"typography":{"fonts":[{"family":"Open Sans","source":"google"}],"base":"Open Sans","headings":"Freight Text Pro"}},"data":{"color":{"palette":{"dark-grey":"#222222","blue":"#003262"},"primary":"black"},"logo":{"medium":"images/snap-logo.png"},"typography":{"fonts":[{"family":"Open Sans","source":"google"}],"base":"Open Sans","headings":"Freight Text Pro"}},"brandDir":"C:\\Users\\victo\\snap-manual-new","projectDir":"C:\\Users\\victo\\snap-manual-new","processedData":{"color":{"dark-grey":"#222222","blue":"#003262","primary":"black"},"typography":{"base":"Open Sans","headings":"Freight Text Pro"},"logo":{"images":{},"medium":{"light":{"path":"images/snap-logo.png"},"dark":{"path":"images/snap-logo.png"}}}}}},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","output-file":"snap-manual","include-in-header":["../../styles/latex-preamble.tex"],"include-after-body":{"text":"\\printindex\n"},"toc":true,"number-sections":true,"resource-path":["../../","../../content/assets/","../../content/assets/images/"]},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"block-headings":true,"bibliography":["../../references.bib"],"number-depth":1,"cover-image":"../../cover.png","documentclass":"book","papersize":"letter"},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","pdf"]}