{"title":"Object Oriented Programming with Sprites","markdown":{"headingText":"Object Oriented Programming with Sprites","containsRefs":false,"markdown":"\nObject oriented programming \\index{object oriented programming} is a\nstyle based around the abstraction *object:* a collection of *data* and\n\\index{method} *methods* (procedures, which from our point of view are\njust more data) that you interact with by sending it a \\index{message}\n*message* (just a name, maybe in the form of a text string, and perhaps\nadditional inputs). The object responds to the message by carrying out a\nmethod, which may or may not report a value back to the asker. Some\npeople emphasize the \\index{data hiding} *data hiding* aspect of OOP\n(because each object has local variables that other objects can access\nonly by sending request messages to the owning object) while others\nemphasize the *simulation* aspect (in which each object abstractly\nrepresents something in the world, and the interactions of objects in\nthe program model real interactions of real people or things). Data\nhiding is important for large multi-programmer industrial projects, but\nfor Snap*!* users it’s the simulation \\index{simulation} aspect that’s\nimportant. Our approach is therefore less restrictive than that of some\nother OOP languages; we give objects easy access to each others’ data\nand methods.\n\nTechnically, object oriented programming rests on three legs: (1)\n\\index{message passing} *Message passing:* There is a notation by which\nany object can send a message to another object. (2) \\index{local state}\n*Local state:* Each object can remember the important past history of\nthe computation it has performed. (“Important” means that it need not\nremember every message it has handled, but only the lasting effects of\nthose messages that will affect later computation.) (3)\n\\index{inheritance} *Inheritance:* It would be impractical if each\nindividual object had to contain methods, many of them identical to\nthose of other objects, for all of the messages it can accept. Instead,\nwe need a way to say that this new object is just like that old object\nexcept for a few differences, so that only those differences need be\nprogrammed explicitly.\n\n##  First Class Sprites\n\nLike Scratch, Snap*!* comes with things that are natural objects: its\nsprites \\index{sprite}. Each sprite can own local variables; each\nsprite has its own scripts (methods). A Scratch animation is plainly a\nsimulation of the interaction of characters in a play. There are two\nways in which Scratch sprites are less versatile than the objects of an\nOOP language. First, Scratch message passing is weak in three respects:\nMessages can only be broadcast \\index{broadcast block}, not addressed\nto an individual sprite; messages can’t take inputs; and methods can’t\nreturn values to their caller. Second, and more basic, in the OOP\nparadigm objects are *data;* they can be the value of a variable, an\nelement of a list, and so on, but that’s not the case for Scratch\nsprites.\n\nSnap*!* sprites are ﬁrst class \\index{ﬁrst class sprites} data. They can\nbe created and deleted by a script, stored in a variable or list, and\nsent messages individually. The children of a sprite can inherit\nsprite-local variables, methods (sprite-local procedures), and other\nattributes (e.g., x position).\n\n![image743.png](assets/image743.png) <!--  style=\"width:0.96528in;height:0.19444in\" / --> ![image744.png](assets/image744.png) <!--  style=\"width:1.08333in;height:0.19444in\" / --> ![image745.png](assets/image745.png) <!--  style=\"width:0.66667in;height:0.19444in\" / --> The fundamental means by\nwhich programs get access to sprites is the my reporter block \\index{my\nblock} . It has a dropdown-menu input slot that, when clicked, gives\naccess to all the sprites, plus the stage \\index{stage}. reports a\nsingle sprite, the one asking the question. reports a list of all\nsprites other than the one asking the question. reports a list of all\nsprites that are *near* the one asking—the ones that are candidates for\nhaving collided with this one, for example. The my block \\index{my\nblock} has many other options, discussed below. If you know the name of\na particular sprite, the object reporter will report the sprite itself.\n\n![image746.png](assets/image746.png) <!--  style=\"width:3.55208in;height:0.51042in\" / --> ![image747.png](assets/image747.png) <!--  style=\"width:2.69143in;height:1.25in\" alt=\"C:\\Documents and Settings\\bh\\Desktop\\Scratch002.png\" / --> An object or\nlist of objects reported by my or object can be used as input to any\nblock that accepts any input type, such as set’s second input. If you\nsay an object, the resulting speech balloon will contain a smaller image\nof the object’s costume or (for the stage) background.\n\n##  Permanent and Temporary Clones\n\n![image748.png](assets/image748.png) <!--  style=\"width:1.51389in;height:0.19444in\" alt=\"Macintosh HD:Users:bh:Desktop:pix:clone-block.png\" / --> The block is\nused to create and report an instance (a clone) of any sprite. (There is\nalso a command version, for historical reasons.) There are two different\nkinds of situations in which clones are used. One is that you’ve made an\nexample sprite and, when you start the project, you want a fairly large\nnumber of essentially identical sprites that behave like the example.\n(Hereafter we’ll call the example sprite the “parent” and the others the\n“children.”) Once the game or animation is over, you don’t need the\ncopies any more. (As we’ll see, “copies” is the wrong word because the\nparent and the children *share* a lot of properties. That’s why we use\nthe word “clones” to describe the children rather than “copies.”) These\nare *temporary* clones \\index{temporary clone}. They are automatically\ndeleted when the user presses either the green flag or the red stop\nsign. In Scratch 2.0 and later, all clones \\index{clone:temporary} are\ntemporary.\n\nThe other kind of situation is what happens when you want\nspecializations of sprites. For example, let’s say you have a sprite\nnamed Dog. It has certain behaviors, such as running up to a person who\ncomes near it. Now you decide that the family in your story really likes\ndogs, so they adopt a lot of them. Some are cocker spaniels, who wag\ntheir tails when they see you. Others are rottweilers, who growl at you\nwhen they see you. So you make a clone of Dog, perhaps rename it Cocker\nSpaniel, and give it a new costume and a script for what to do when\nsomeone gets near. You make another clone of Dog, perhaps rename it\nRottweiler, and give it a new costume, etc. Then you make three clones\nof Cocker Spaniel (so there are four altogether) and two clones of\nRottweiler. Maybe you hide the Dog sprite after all this, since it’s no\nbreed in particular. Each dog has its own position, special behaviors,\nand so on. You want to save all of these dogs in the project. These are\n*permanent* clones \\index{permanent clone}. In BYOB 3.1, the\npredecessor to Snap*!,* all clones \\index{clone:permanent} are\npermanent.\n\n![image748.png](assets/image748.png) <!--  style=\"width:1.51389in;height:0.19444in\" alt=\"Macintosh HD:Users:bh:Desktop:pix:clone-block.png\" / --> One advantage\nof temporary clones is that they don’t slow down Snap*!* even when you\nhave a lot of them. (If you’re curious, one reason is that permanent\nclones appear in the sprite corral, where their pictures have to be\nupdated to reflect the clone’s current costume, direction, and so on.)\nWe have tried to anticipate your needs, as follows: When you make a\nclone in a script, using the block, it is “born” temporary. But when you\nmake a clone from the user interface, for example by right-clicking on a\nsprite and choosing “clone,” it is born permanent. The reason this makes\nsense is that you don’t create 100 *kinds* of dogs automatically. Each\nkind has many different characteristics, programmed by hand. But when\nyour project is running, it might create 100 rottweilers, and those will\nbe identical unless you change them in the program.\n\n![image749.png](assets/image749.png) <!--  style=\"width:1.51389in;height:0.25694in\" alt=\"Macintosh HD:Users:bh:Desktop:set-my-temp.png\" / --> You can change a\ntemporary sprite to permanent by right-clicking it and choosing “edit.”\n(It’s called “edit” rather than, say, “permanent” because it also shifts\nthe scripting area to reflect that sprite, as if you’d pressed its\nbutton in the sprite corral.) You can change a permanent sprite to\ntemporary by right-clicking it and choosing “release.” You can also\nchange the status of a clone in your program with with true or false as\nthe second input.\n\n##  Sending Messages to Sprites\n\nThe messages that a sprite accepts are the blocks in its palettes,\nincluding both all-sprites and this-sprite-only blocks. (For custom\nblocks, the corresponding methods are the scripts as seen in the Block\nEditor.\n\nThe way to send a message to a sprite (or the stage) is with the tell\nblock (for command messages) or the ask block (for reporter messages).\n\nA small point to note in the examples above: all dropdown menus include\nan empty entry at the top, which can be selected for use in higher order\nprocedures like the for each and map examples. Each of the sprites in my\nneighbors or my other sprites is used to fill the blank space in turn.\n\nBy the way, if you want a list of *all* the sprites, including this\nsprite, you can use either of these:\n\n![image762.png](assets/image762.png) <!--  style=\"width:3.54514in;height:0.82639in\" / --> Tell and ask wait until the\nother sprite has carried out its method before this sprite’s script\ncontinues. (That has to be the case for ask, since we want to do\nsomething with the value it reports.) So tell is analogous to broadcast\nand wait. Sometimes the other sprite’s method may take a long time, or\nmay even be a forever loop, so you want the originating script to\ncontinue without waiting. For this purpose we have the launch block:\n\nLaunch is analogous to broadcast without the “wait.”\n\nSnap*!* 4.1, following BYOB 3.1, used an extension of the of block to\nprovide access to other sprites’ methods. That interface was designed\nback when we were trying hard to avoid adding new primitive blocks; it\nallowed us to write ask and tell as tool procedures in Snap*!* itself.\nThat technique still works, but is deprecated, because nobody understood\nit, and now we have the more straightforward primitives.\n\n### Polymorphism \\index{polymorphism} \n\n![image763.png](assets/image763.png) <!--  style=\"width:1.67361in;height:1.40208in\" / --> Suppose you have a Dog sprite\nwith two clones CockerSpaniel and PitBull. In the Dog sprite you define\nthis method \\index{method} (“For this sprite only” block\n\\index{block:sprite-local} ):\n\nNote the *loca*tion (map-pin) symbol \\index{map-pin symbol} before the\nblock’s name. The symbol is not part of the block title; it’s a visual\nreminder that this is a sprite-*loca*l block. Sprite-local variables are\nsimilarly marked.\n\nBut you don’t define greet as friend or greet as enemy in Dog. Each kind\nof dog has a different behavior. Here’s what a CockerSpaniel does:\n\nAnd here’s what a PitBull does:\n\nGreet is defined in the Dog sprite. If Fido is a particular cocker\nspaniel, and you ask Fido to greet someone, Fido inherits the greet\nmethod from Dog, but Dog itself couldn’t actually run that method,\nbecause Dog doesn’t have greet as friend or greet as enemy. And perhaps\nonly individual dogs such as Fido have friend? methods. Even though the\ngreet method is defined in the Dog sprite, when it’s running it\nremembers what specific dog sprite called it, so it knows which greet as\nfriend to use. Dog’s greet block is called a *polymorphic* method,\nbecause it means different things to different dogs, even though they\nall share the same script.\n\n##  Local State in Sprites: Variables and Attributes\n\nA sprite’s memory of its own past history takes two main forms. It has\n*variables,* created explicitly by the user with the “Make a variable\n\\index{variable} ” button; it also has *attributes,* the qualities every\nsprite has automatically, such as position, direction, and pen color.\nEach variable can be examined using its own orange oval block; there is\none set block to modify all variables. Attributes, however, have a less\nuniform programming interface in Scratch:\n\n- A sprite’s *direction* can be examined with the direction block, and\n  modified with the point in direction block. It can also be modified\n  less directly using the blocks turn, point towards, and if on edge,\n  bounce.\n\n- There is no way for a script to examine a sprite’s *pen color,* but\n  there are blocks set pen color to \\<color\\>, set pen color to\n  \\<number\\>, and change pen color to modify it.\n\n- A sprite’s *name* can be neither examined nor modified by scripts; it\n  can be modified by typing a new name directly into the box that\n  displays the name, above the scripting area.\n\nThe block, if any, that examines a variable or attribute\n\\index{attribute} is called its \\index{getter} *getter;* a block (there\nmay be more than one, as in the direction example above) that modifies a\nvariable or attribute is called a \\index{setter} *setter.*\n\nIn Snap*!* we allow virtually all attributes to be examined. But instead\nof adding dozens of reporters, we use a more uniform interface for\nattributes: The my block \\index{my block} ’s menu (in Sensing; see page\n[78](#attrib.pnglist-of-attributes)) includes many of the attributes of\na sprite. It serves as a general getter for those attributes, e.g., my\n\\[anchor\\] to find the sprite, if any, to which this sprite is attached\nin a nesting arrangement (see page\n[10](#nesting-sprites-anchors-and-parts)). Similarly, the same set block\nused to set variable values allows setting some sprite attributes.\n\n##  Prototyping: Parents and Children\n\nMost current OOP languages use a *class/instance* approach to creating\nobjects. A class is a particular *kind of object,* and an instance is an\n*actual object* of that type. For example, there might be a Dog class,\nand several instances Fido, Spot, and Runt. The class typically\nspecifies the methods shared by all dogs (RollOver, SitUpAndBeg, Fetch,\nand so on), and the instances contain data such as species, color, and\nfriendliness. Snap*!* uses a different approach called *prototyping,* in\nwhich there is no distinction between classes and instances. Prototyping\n\\index{prototyping} is better suited to an experimental, tinkering style\nof work: You make a single dog sprite, with both methods (blocks) and\ndata (variables); you can actually watch it and interact with it on the\nstage; and when you like it, you use it as the prototype from which to\nclone other dogs. If you later discover a bug in the behavior of dogs,\nyou can edit a method in the parent, and all of the children will\nautomatically share the new version of the method block. Experienced\nclass/instance \\index{class/instance} programmers may find prototyping\n\\index{prototyping} strange at first, but it is actually a more\nexpressive system, because you can easily simulate a class/instance\nhierarchy by hiding the prototype sprite! Prototyping is also a better\nfit with the Scratch design principle \\index{design principle} that\neverything in a project should be concrete and visible on the stage; in\nclass/instance OOP the programming process begins with an abstract,\ninvisible entity, the class, that must be designed before any concrete\nobjects can be made.[7]\n\nThere are three ways to make a child sprite. If you control-click or\nright-click on a sprite in the “sprite corral” at the bottom right\ncorner of the window, you get a menu that includes “clone” as one of the\nchoices. There is an a new clone of block \\index{a new clone of block}\nin the Control palette that creates and reports a child sprite. And\nsprites have a “parent” attribute \\index{parent attribute} that can be\nset, like any attribute, thereby *changing* the parent of an existing\nsprite.\n\n##  Inheritance by Delegation\n\nA clone *inherits* properties of its parent. “Properties” include\nscripts, custom blocks, variables, named lists, system attributes,\ncostumes, and sounds. Each individual property can be shared between\nparent and child, or not shared (with a separate one in the child). The\ngetter block for a shared property, in the child’s palette, is displayed\nin a lighter color; separate properties of the child are displayed in\nthe traditional colors.\n\n> When a new clone is created, by default it shares only its methods,\n> wardrobe, and jukebox with its parent. All other properties are copied\n> to the clone, but not shared. (One exception is that a new *permanent*\n> clone is given a random position. Another is that *temporary* clones\n> share the scripts in their parent’s scripting area. A third is that\n> sprite-local variables that the parent creates *after* cloning are\n> shared with its children.) If the value of a shared property is\n> changed in the parent, then the children see the new value. If the\n> value of a shared property is changed in the *child*, then the sharing\n> link is broken, and a new private version is created in that child.\n> (This is the mechanism by which a child chooses not to share a\n> property with its parent.) “Changed” in this context means using the\n> set or change block for a variable, editing a block in the Block\n> Editor, editing a costume or sound, or inserting, deleting, or\n> reordering costumes or sounds. To change a property from unshared to\n> shared, the child uses the inherit command block. The pulldown menu in\n> the block lists all the things this sprite can inherit from its parent\n> (which might be nothing, if this sprite has no parent) and is not\n> already inheriting. But that would prevent telling a child to inherit,\n> so if the inherit block \\index{inherit block} is inside a ring, its\n> pulldown menu includes all the things a child could inherit from this\n> sprite. Right-clicking on the scripting area of a permanent clone\n> gives a menu option to share the entire collection of scripts from its\n> parent, as a temporary clone does.\n\nThe rules are full of details, but the basic idea is simple: Parents can\nchange their children, but children can’t directly change their parents.\nThat’s what you’d expect from the word “inherit”: the influence just\ngoes in one direction. When a child changes some property, it’s\ndeclaring independence from its parent (with respect to that one\nproperty). What if you really want the child to be able to make a change\nin the parent (and therefore in itself and all its siblings)? Remember\nthat in this system any object can tell any other object to do\nsomething:\n\n![image779.png](assets/image779.png) <!--  style=\"width:5.07292in;height:0.58333in\" / --> When a sprite gets a message\nfor which it doesn’t have a corresponding block, the message is\n*delegated* to that sprite’s parent. When a sprite does have the\ncorresponding block, then the message is not delegated. If the script\nthat implements a delegated message refers to my (self), it means the\nchild to which the message was originally sent, not the parent to which\nthe message was delegated.\n\n## ![image780.png](assets/image780.png) <!--  style=\"width:0.78958in;height:3.46806in\" alt=\"attrib.png\" / --> List of attributes\n\n![image781.png](assets/image781.png) <!--  style=\"width:1.19in;height:0.25in\" / --> ![image782.png](assets/image782.png) <!--  style=\"width:1.17569in;height:6.11667in\" / --> At the right is a picture of\nthe dropdown menu of attributes \\index{attributes, list of} in the my\nblock.\n\nSeveral of these are not real attributes, but things related to\nattributes:\n\n- self \\index{self (in my block)} : this sprite\n\n- neighbors \\index{neighbors (in my block)} : a list of *nearby*\n  sprites[8]\n\n- other sprites \\index{other sprites (in my block)} : a list of all\n  sprites except myself\n\n- stage \\index{stage (in my block)} : the stage, which is first-class,\n  like a sprite\n\n- clones \\index{clones (in my block)} : a list of my *temporary* clones\n\n- other clones \\index{other clones (in my block)} : a list of my\n  *temporary* siblings\n\n- parts \\index{parts (in my block)} : a list of sprites whose anchor\n  attribute is this sprite\n\n- children \\index{children (in my block)} : a list of all my clones,\n  temporary and permanent\n\nThe others are individual attributes:\n\n- anchor \\index{anchor (in my block)} : the sprite of which I am a\n  (nested) part\n\n- parent \\index{parent (in my block)} : the sprite of which I am a clone\n\n- temporary?: am I a temporary clone?\n\n- name \\index{name (in my block)} : my name (same as parent’s name if\n  I’m temporary)\n\n- costumes \\index{costumes (in my block)} : a list of the sprite’s\n  costumes\n\n- sounds \\index{sounds (in my block)} : a list of the sprite’s sounds\n\n- blocks: a list of the blocks visible in this sprite\n\n- categories: a list of all the block category names\n\n- dangling? \\index{dangling? (in my block)} : True if I am a part and\n  not in synchronous orbit\n\n- draggable?: True if the user can move me with the mouse\n\n- width, height, left, right, top, bottom: The width or height of my\n  costume *as seen right now,* or the left, etc., edge of my bounding\n  box, taking rotation into account.\n\n- rotation x \\index{rotation x (in my block)}, rotation y\n  \\index{rotation y (in my block)} : when reading with my, the same as x\n  position, y position. When set, changes the sprite’s rotation center\n  *without moving the sprite,* like dragging the rotation center in the\n  paint editor.\n\n- center x \\index{center x (in my block)}, center y \\index{center y (in\n  my block)} : the x and y position of the center of my\n\n> bounding box, rounded oﬀ–the geometric center of the costume.\n\n## First Class Costumes and Sounds\n\nCostumes and sounds don’t have methods, as sprites do; you can’t ask\nthem to do things. But they *are* first class: \\index{costumes, first\nclass} you can make a list of them, put them in variables, use them as\ninput to a procedure, and so on. My \\[costumes\\] and my \\[sounds\\]\nreport lists of them.\n\n### Media Computation with Costumes\n\n![image783.png](assets/image783.png) <!--  style=\"width:1.63194in;height:0.1875in\" alt=\"Macintosh HD:Users:bh:Desktop:ofcostume.png\" / --> The components of a\ncostume are its name, width, height, and pixels. The block gives access\nto these components \\index{of costume block} using its left menu. From\nits right menu you can choose the current costume, the Turtle costume,\nor any costume in the sprite’s wardrobe. Since costumes are first class,\nyou can also drop an expression whose value is a costume, or a list of\ncostumes, on that second input slot. (Due to a misfeature, even though\nyou can select Turtle in the right menu, the block reports 0 for its\nwidth and height, and an empty string for the other components.) The\ncostume’s width and height are in its standard orientation, regardless\nof the sprite’s current direction. (This is different from the\n*sprite’s* width and height, reported by the my block.)\n\nBut the really interesting part of a costume is its bitmap\n\\index{bitmap}, a list of *pixels*. (A pixel \\index{pixel}, short for\n“picture element,” represents one dot on your display.) Each pixel is\nitself a list of four items, the red, green, and blue components of its\ncolor (in the range 0-255) and what is standardly called its\n“transparency \\index{transparency} ” but should be called its opacity,\nalso in the range 0-255, in which 0 means that the pixel is invisible\nand 255 means that it’s fully opaque: you can’t see anything from a\nrearward layer at that point on the stage. (Costume pixels typically\nhave an opacity of 0 only for points inside the bounding box of the\ncostume but not actually part of the costume; points in the interior of\na costume typically have an opacity of 255. Intermediate values appear\nmainly at the edge of a costume, or at sharp boundaries between colors\ninside the costume, where they are used to reduce “jaggies\n\\index{jaggies} ”: the stairstep-like shape of a diagonal line displayed\non an array of discrete rectangular screen coordinates. Note that the\nopacity of a *sprite* pixel is determined by combining the costume’s\nopacity with the sprite’s ghost effect. (The latter really is a measure\nof transparency: 0 means opaque and 100 means invisible.)\n\nThe bitmap is a one-dimensional list of pixels, not an array of *height*\nrows of *width* pixels each. That’s why the pixel list has to be\ncombined with the dimensions to produce a costume. This choice partly\nreflects the way bitmaps are stored in the computer’s hardware and\noperating system, but also makes it easy to produce transformations of a\ncostume with map:\n\nIn this simplest possible transformation, the red value of all the\npixels have been changed to a constant 150. Colors that were red in the\noriginal (such as the logo printed on the t-shirt) become closer to\nblack (the other color components being near zero); the blue jeans\nbecome purple (blue plus red); perhaps counterintuitively, the white\nt-shirt, which has the maximum value for all three color components,\nloses some of its red and becomes cyan, the color opposite red on the\ncolor wheel. In reading the code, note that the function that is the\nfirst input to map is applied to a single pixel, whose first item is its\nred component. Also note that this process works only on bitmap\ncostumes; if you call pixels of on a vector costume (one with “svg” in\nthe corner of its picture), it will be converted to pixels first.\n\n![image790.png](assets/image790.png) <!--  style=\"width:2.25694in;height:0.28472in\" alt=\"Macintosh HD:Users:bh:Desktop:add-to-wardrobe.png\" / --> One important\npoint to see here is that a bitmap (list of pixels) is not, by itself, a\ncostume. The new costume block \\index{new costume block} creates a\ncostume by combining a bitmap, a width, and a height. But, as in the\nexample above, switch to costume will accept a bitmap as input and will\nautomatically use the width and height of the current costume. Note that\nthere’s no name input; costumes computed in this way are all named\ncostume. Note also that the use of switch to costume does *not* add the\ncomputed costume to the sprite’s wardrobe; to do that, say\n\nHere’s a more interesting example of color manipulation:\n\n![image797.png](assets/image797.png) <!--  style=\"width:4.5625in;height:0.40694in\" / --> Each\ncolor value is constrained to be 0, 80, 160, or 240. This gives the\npicture a more cartoonish look. Alternatively, you can do the\ncomputation taking advantage of hyperblocks:\n\nHere’s one way to exchange red and green values:\n\n![image804.png](assets/image804.png) <!--  style=\"width:0.95833in;height:0.18056in\" alt=\"Macintosh HD:Users:bh:Desktop:2-1-3-4.png\" / --> It’s the list that\ndetermines the rearrangement of colors: green➔red, red➔green, and the\nother two unchanged. That list is inside another list because otherwise\nit would be selecting *rows* of the pixel array, and we want to select\ncolumns. We use pixels of costume current rather than costume apple\nbecause the latter is always a red apple, so this little program would\nget stuck turning it green, instead of alternating colors.\n\n![image809.png](assets/image809.png) <!--  style=\"width:1.72222in;height:0.22917in\" alt=\"Macintosh HD:Users:bh:Desktop:a-costume.png\" / --> The stretch block\n\\index{stretch block} takes a costume as its first input, either by\nselecting a costume from the menu or by dropping a costume-valued\nexpression such as onto it. The other two inputs are percents of the\noriginal width and height, as advertised, so you can make fun house\nmirror versions of costumes:\n\nThe resulting costumes can be used with switch to costume and so on.\n\nFinally, you can use pictures from your computer’s camera in your\nprojects using these blocks:\n\n![image813.png](assets/image813.png) <!--  style=\"width:1.47222in;height:0.24306in\" alt=\"Macintosh HD:Users:bh:Desktop:Jump! script pic.png\" / --> Using the\nvideo on block \\index{video on block} turns on the camera and displays\nwhat it sees on the stage, regardless of the inputs given. The camera\nremains on until you click the red stop button, your program runs the\nstop all block, or you turn it off explicitly with the block. The video\nimage on the stage is partly ghosted, to an extent determined by the set\nvideo transparency block, whose input really is transparency and not\nopacity. (Small numbers make the video more visible.) By default, the\nvideo image is mirrored, like the selfie camera on your cell phone: When\nyou raise your left hand, your image raises its right hand. You can\ncontrol this\n![image814.png](assets/image814.png) <!--  style=\"width:1.40278in;height:0.24306in\" alt=\"Macintosh HD:Users:bh:Desktop:mirror-video.png\" / --> mirroring with\nthe block.\n\n![image815.png](assets/image815.png) <!--  style=\"width:1.20417in;height:1.6125in\" / --> The\nvideo snap on block then takes a still picture from the camera, and\ntrims it to fit on the selected sprite. (Video snap on stage means to\nuse the entire stage-sized rectangle.) For example, here’s a camera\nsnapshot trimmed to fit Alonzo:\n\n![image816.png](assets/image816.png) <!--  style=\"width:2.67014in;height:1.29861in\" alt=\"Macintosh HD:Users:bh:Desktop:Video Capture script 1.png\" / --> The\n“Video Capture” project in the Examples collection repeatedly takes such\ntrimmed snapshots and has the Alonzo sprite use the current snapshot as\nits costume, so it looks like this:\n\n![image817.png](assets/image817.png) <!--  style=\"width:2.66667in;height:2in\" alt=\"Macintosh HD:Users:bh:Desktop:offset-video.png\" / --> ![image818.png](assets/image818.png) <!--  style=\"width:3.33333in;height:2.5in\" alt=\"Macintosh HD:Users:bh:Desktop:video.png\" / --> (The picture above was\nactually taken with transparency set to 50, to make the background more\nvisible for printing.) Because the sprite is always still in the place\nwhere the snapshot was taken, its costume exactly fits in with the rest\nof the full-stage video. If you were to add a move 100 steps block after\nthe switch to costume, you’d see something like this:\n\nThis time, the sprite’s costume was captured at one position, and then\nthe sprite is shown at a different position. (You probably wouldn’t want\nto do this, but perhaps it’s helpful for explanatory purposes.)\n\nWhat you *would* want to do is push the sprite around the stage:\n\n![image825.png](assets/image825.png) <!--  style=\"width:3.09028in;height:1.92361in\" alt=\"Macintosh HD:Users:bh:Desktop:microphone.png\" / --> (Really these\nshould be Jens’s picture; it’s his project. But he’s vacationing. ☺)\nVideo motion compares two snapshots a moment apart, looking only at the\npart within the given trim (here myself, meaning the current sprite, not\nthe person looking into the camera), to detect a difference between\nthem. It reports a number, measuring the number of pixels through which\nsome part of the picture has moved. Video direction also compares two\nsnapshots to detect motion, but what it reports is the direction (in the\npoint in direction sense) of the motion. So the script above moves the\nsprite in the direction in which it’s being pushed, but only if a\nsignificant amount of motion is found; otherwise the sprite would jiggle\naround too much. And yes, you can run the second script without the\nfirst to push a balloon around the stage.\n\n### Media Computation with Sounds\n\nThe starting point for computation with sound \\index{sound} is the\nmicrophone block \\index{microphone block}. It starts by recording a\nbrief burst of sound from your microphone \\index{microphone}. (How\nbrief? On my computer, 0.010667 seconds, but you’ll see shortly how to\nﬁnd out or control the sample size on your computer.)\n\n![image826.png](assets/image826.png) <!--  style=\"width:1.96528in;height:0.25694in\" alt=\"Macintosh HD:Users:bh:Desktop:sample-rate.png\" / --> ![image827.png](assets/image827.png) <!--  style=\"width:5.99931in;height:2.62014in\" alt=\"Macintosh HD:Users:bh:Desktop:samples.png\" / --> Just as the *pixel* is\nthe smallest piece of a picture, the *sample* is the smallest piece of a\nsound. It says here: that on my computer, 48,000 samples are recorded\nper second, so each sample \\index{sample} is 1/48,000 of a second. The\nvalue of a sample is between -1 and 1, and represents the sound pressure\non the microphone—how hard the air is pushing—at that instant. (You can\nskip the next page or so if you know about Fourier analysis.) Here’s a\npicture of 400 samples:\n\nIn this graph, the *x* axis represents the time at which each sample was\nmeasured; the *y* axis measures the value of the sample at that time.\nThe first obvious thing about this graph is that it has a lot of ups and\ndowns. The most basic up-and-down function is the *sine wave:*\n\nEvery periodic function (more or less, any sample that sounds like music\nrather than sounding like static) is composed of a sum of sine wave\n\\index{sine wave} s of different frequencies.\n\nLook back at the graph of our sampled sound. There is a green dot every\nseven samples. There’s nothing magic about the number seven; I tried\ndifferent values until I found one that looked right. What “right” means\nis that, for the first few dots at least, they coincide almost perfectly\nwith the high points and low points of the graph. Near the middle\n(horizontally) of the graph, the green dots don’t seem anywhere near the\nhigh and low points, but if you find the very lowest point of the graph,\nabout 2/3 of the way along, the dots start lining up almost perfectly\nagain.\n\nThe red graph above shows two *cycles* of a sine wave. One cycle goes\nup, then down, then up again. The amount of time taken for one cycle is\nthe *period* of the sine function. If the green dots match both ups and\ndowns in the captured sound, then two dots—14 samples, or 14/48000 of a\nsecond—represent the period. The first cycle and a half of the graph\nlooks like it could be a pure sine wave, but after that, the tops and\nbottoms don’t line up, and there are peculiar little jiggles, such as\nthe one before the fifth green dot. This happens because sine waves of\ndifferent periods are added together.\n\nIt turns out to be more useful to measure the reciprocal of the period,\nin our case, 48000/14 or about 3429 *cycles per second.* Another name\nfor “cycles per second” is “Hertz,” abbreviated Hz, so our sound has a\ncomponent at 3249 Hz. As a musical note, that’s about an A (a little\nflat), four octaves above middle C. (Don’t worry too much about the note\nbeing a little off; remember that the 14-sample period was just\neyeballed and is unlikely to be exactly right.)\n\nFour octaves above middle C is really high! That would be a\nshrill-sounding note. But remember that a complex waveform is the sum of\nmultiple sine waves at different frequency. Here’s a different\nup-and-down regularity:\n\n![image828.png](assets/image828.png) <!--  style=\"width:2.79514in;height:1.22222in\" alt=\"Macintosh HD:Users:bh:Desktop:red-sine.png\" / --> ![image829.png](assets/image829.png) <!--  style=\"width:2.78472in;height:1.04861in\" alt=\"Macintosh HD:Users:bh:Desktop:sine.png\" / --> It’s not obvious, but in\nthe left part of the graph, the signal is more above the *x* axis than\nbelow it. Toward the right, it seems to be more below than above the\naxis. At the very right it looks like it might be climbing again.\n\nThe period of the red sine wave is 340 samples, or 340/48000 second.\nThat’s a frequency of about 141 Hz, about D below middle C. Again, this\nis measuring by eyeball, but likely to be close to the right frequency.\n\nAll this eyeballing doesn’t seem very scientific. Can’t we just get the\ncomputer to find all the relevant frequencies? Yes, we can, using a\nmathematical technique called *Fourier analysis.* (Jean-Baptiste Joseph\nFourier, 1768–1830, made many contributions to mathematics and physics,\nbut is best known for working out the nature of periodic functions as a\nsum of sine waves.) Luckily we don’t have to do the math; the microphone\nblock will do it for us, if we ask for microphone spectrum:\n\nThese are frequency spectra from (samples of) three different songs. The\nmost obvious thing about these graphs is that their overall slope is\ndownward; the loudest frequency is the lowest frequency. That’s typical\nof music.\n\nThe next thing to notice is that there’s a regularity in the spacing of\nspikes in the graph. This is partly just an artifact; the frequency\n(horizontal) axis isn’t continuous. There are a finite number of\n“buckets” (default: 512), and all the frequencies within a bucket\ncontribute to the amplitude (vertical axis) of that bucket. The spectrum\nis a list of that many amplitudes. But the patterns of alternating\nrising and falling values are real; the frequencies that are multiples\nof the main note being sampled will have higher amplitude than other\nfrequencies.\n\nSamples and spectrum are the two most detailed representations of a\nsound. But the microphone block has other, simpler options also:\n\nvolume the instantaneous volume when the block is called\n\nnote the MIDI note number (as in play note) of the main note heard\n\nfrequency the frequency in Hz of the main note heard\n\nsample rate the number of samples being collected per second\n\n![image258.png](assets/image258.png) <!--  style=\"width:2.91667in;height:0.28125in\" alt=\"Macintosh HD:Users:bh:Desktop:new-sound.png\" / --> resolution the size\nof the array in which data are collected (typically 512, must be a power\nof 2)\n\nThe block for sounds that corresponds to new picture for pictures is\n\\index{new sound block}\n\nIts first input is a list of samples, and its second input specifies how\nmany samples occupy one second.\n\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"brand":{"brand":{"color":{"palette":{"dark-grey":"#222222","blue":"#003262"},"primary":"black"},"logo":{"medium":"images/snap-logo.png"},"typography":{"fonts":[{"family":"Open Sans","source":"google"}],"base":"Open Sans","headings":"Freight Text Pro"}},"data":{"color":{"palette":{"dark-grey":"#222222","blue":"#003262"},"primary":"black"},"logo":{"medium":"images/snap-logo.png"},"typography":{"fonts":[{"family":"Open Sans","source":"google"}],"base":"Open Sans","headings":"Freight Text Pro"}},"brandDir":"C:\\Users\\victo\\snap-manual-new","projectDir":"C:\\Users\\victo\\snap-manual-new","processedData":{"color":{"dark-grey":"#222222","blue":"#003262","primary":"black"},"typography":{"base":"Open Sans","headings":"Freight Text Pro"},"logo":{"images":{},"medium":{"light":{"path":"images/snap-logo.png"},"dark":{"path":"images/snap-logo.png"}}}}}},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","filters":["../../scripts/collect-index.lua"],"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.42","bibliography":["../../references.bib"],"number-depth":1,"theme":["none","../../styles/snap-manual.scss"],"strip-comment":true,"navbar":{"logo":"../../images/snap-logo.png"}},"extensions":{"book":{"multiFile":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":true,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"brand":{"brand":{"color":{"palette":{"dark-grey":"#222222","blue":"#003262"},"primary":"black"},"logo":{"medium":"images/snap-logo.png"},"typography":{"fonts":[{"family":"Open Sans","source":"google"}],"base":"Open Sans","headings":"Freight Text Pro"}},"data":{"color":{"palette":{"dark-grey":"#222222","blue":"#003262"},"primary":"black"},"logo":{"medium":"images/snap-logo.png"},"typography":{"fonts":[{"family":"Open Sans","source":"google"}],"base":"Open Sans","headings":"Freight Text Pro"}},"brandDir":"C:\\Users\\victo\\snap-manual-new","projectDir":"C:\\Users\\victo\\snap-manual-new","processedData":{"color":{"dark-grey":"#222222","blue":"#003262","primary":"black"},"typography":{"base":"Open Sans","headings":"Freight Text Pro"},"logo":{"images":{},"medium":{"light":{"path":"images/snap-logo.png"},"dark":{"path":"images/snap-logo.png"}}}}}},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","output-file":"snap-manual","include-in-header":["../../styles/latex-preamble.tex"],"include-after-body":{"text":"\\printindex\n"},"toc":true,"number-sections":true,"resource-path":["../../","../../content/assets/","../../content/assets/images/"]},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"block-headings":true,"bibliography":["../../references.bib"],"number-depth":1,"cover-image":"../../cover.png","documentclass":"book","papersize":"letter"},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","pdf"]}